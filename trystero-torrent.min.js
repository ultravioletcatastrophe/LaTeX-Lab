const{floor:e,random:r}=Math,t="Trystero",n=(e,r)=>Array(e).fill().map(r),a="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",o=t=>n(t,(()=>a[e(62*r())])).join(""),s=o(20),i=Promise.all.bind(Promise),c="undefined"!=typeof window,{entries:l,fromEntries:d,keys:u}=Object,f=()=>{},p=e=>Error(`${t}: ${e}`),y=new TextEncoder,m=new TextDecoder,w=e=>y.encode(e),g=e=>m.decode(e),h=(...e)=>e.join("@"),b=JSON.stringify,k=JSON.parse,v={},P="AES-GCM",T={},A=async e=>T[e]||=Array.from(await(async(e,r)=>new Uint8Array(await crypto.subtle.digest(e,w(r))))("SHA-1",e)).map((e=>e.toString(36))).join(""),S=async(e,r)=>{const t=crypto.getRandomValues(new Uint8Array(16));return t.join(",")+"$"+(n=await crypto.subtle.encrypt({name:P,iv:t},await e,w(r)),btoa(String.fromCharCode.apply(null,new Uint8Array(n))));var n},L=async(e,r)=>{const[t,n]=r.split("$");return g(await crypto.subtle.decrypt({name:P,iv:new Uint8Array(t.split(","))},await e,(e=>{const r=atob(e);return new Uint8Array(r.length).map(((e,t)=>r.charCodeAt(t))).buffer})(n)))},D="icegatheringstatechange",I="offer";var $=(e,{rtcConfig:r,rtcPolyfill:t,turnConfig:n})=>{const a=new(t||RTCPeerConnection)({iceServers:C.concat(n||[]),...r}),o={};let s=!1,c=!1,l=null;const d=e=>{e.binaryType="arraybuffer",e.bufferedAmountLowThreshold=65535,e.onmessage=e=>o.data?.(e.data),e.onopen=()=>o.connect?.(),e.onclose=()=>o.close?.(),e.onerror=e=>o.error?.(e)},u=e=>Promise.race([new Promise((r=>{const t=()=>{"complete"===e.iceGatheringState&&(e.removeEventListener(D,t),r())};e.addEventListener(D,t),t()})),new Promise((e=>setTimeout(e,5e3)))]).then((()=>({type:e.localDescription.type,sdp:e.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")})));return e?(l=a.createDataChannel("data"),d(l)):a.ondatachannel=({channel:e})=>{l=e,d(e)},a.onnegotiationneeded=async()=>{try{s=!0,await a.setLocalDescription();const e=await u(a);o.signal?.(e)}catch(e){o.error?.(e)}finally{s=!1}},a.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(a.connectionState)&&o.close?.()},a.ontrack=e=>{o.track?.(e.track,e.streams[0]),o.stream?.(e.streams[0])},a.onremovestream=e=>o.stream?.(e.stream),e&&(a.canTrickleIceCandidates||a.onnegotiationneeded()),{created:Date.now(),connection:a,get channel(){return l},get isDead(){return"closed"===a.connectionState},async signal(r){if("open"!==l?.readyState||r.sdp?.includes("a=rtpmap"))try{if(r.type===I){if(s||"stable"!==a.signalingState&&!c){if(e)return;await i([a.setLocalDescription({type:"rollback"}),a.setRemoteDescription(r)])}else await a.setRemoteDescription(r);await a.setLocalDescription();const t=await u(a);return o.signal?.(t),t}if("answer"===r.type){c=!0;try{await a.setRemoteDescription(r)}finally{c=!1}}}catch(e){o.error?.(e)}},sendData(e){return l.send(e)},destroy(){l?.close(),a.close(),s=!1,c=!1},setHandlers(e){return Object.assign(o,e)},offerPromise:e?new Promise((e=>o.signal=r=>{r.type===I&&e(r)})):Promise.resolve(),addStream(e){return e.getTracks().forEach((r=>a.addTrack(r,e)))},removeStream(e){return a.getSenders().filter((r=>e.getTracks().includes(r.track))).forEach((e=>a.removeTrack(e)))},addTrack(e,r){return a.addTrack(e,r)},removeTrack(e){const r=a.getSenders().find((r=>r.track===e));r&&a.removeTrack(r)},replaceTrack(e,r){const t=a.getSenders().find((r=>r.track===e));if(t)return t.replaceTrack(r)}}};const C=[...n(3,((e,r)=>`stun:stun${r||""}.l.google.com:19302`)),"stun:stun.cloudflare.com:3478"].map((e=>({urls:e}))),E=Object.getPrototypeOf(Uint8Array),U=16369,_=255,O="bufferedamountlow",j=e=>"@_"+e;var H=(e,r,a)=>{const o={},s={},y={},m={},h={},v={},P={},T={onPeerJoin:f,onPeerLeave:f,onPeerStream:f,onPeerTrack:f},A=(e,r)=>(e?Array.isArray(e)?e:[e]:u(o)).flatMap((e=>{const n=o[e];return n?r(e,n):(console.warn(`${t}: no peer with id ${e} found`),[])})),S=e=>{o[e]&&(o[e].destroy(),delete o[e],delete m[e],delete h[e],T.onPeerLeave(e),r(e))},L=e=>{if(s[e])return y[e];if(!e)throw p("action type argument is required");const r=w(e);if(r.byteLength>12)throw p(`action type string "${e}" (${r.byteLength}b) exceeds byte limit (12). Hint: choose a shorter name.`);const t=new Uint8Array(12);t.set(r);let a=0;return s[e]={onComplete:f,onProgress:f,setOnComplete(r){return s[e]={...s[e],onComplete:r}},setOnProgress(r){return s[e]={...s[e],onProgress:r}},async send(e,r,s,c){if(s&&"object"!=typeof s)throw p("action meta argument must be an object");const l=typeof e;if("undefined"===l)throw p("action data cannot be undefined");const d="string"!==l,u=e instanceof Blob,f=u||e instanceof ArrayBuffer||e instanceof E;if(s&&!f)throw p("action meta argument can only be used with binary data");const y=f?new Uint8Array(u?await e.arrayBuffer():e):w(d?b(e):e),m=s?w(b(s)):null,g=Math.ceil(y.byteLength/U)+(s?1:0)||1,h=n(g,((e,r)=>{const n=r===g-1,o=s&&0===r,i=new Uint8Array(15+(o?m.byteLength:n?y.byteLength-U*(g-(s?2:1)):U));return i.set(t),i.set([a],12),i.set([n|o<<1|f<<2|d<<3],13),i.set([Math.round((r+1)/g*_)],14),i.set(s?o?m:y.subarray((r-1)*U,r*U):y.subarray(r*U,(r+1)*U),15),i}));return a=a+1&_,i(A(r,(async(e,r)=>{const{channel:t}=r;let n=0;for(;n<g;){const a=h[n];if(t.bufferedAmount>t.bufferedAmountLowThreshold&&await new Promise((e=>{const r=()=>{t.removeEventListener(O,r),e()};t.addEventListener(O,r)})),!o[e])break;r.sendData(a),n++,c?.(a[14]/_,e,s)}})))}},y[e]||=[s[e].send,s[e].setOnComplete,s[e].setOnProgress]},D=async()=>{await G(""),await new Promise((e=>setTimeout(e,99))),l(o).forEach((([e,r])=>{r.destroy(),delete o[e]})),a()},[I,$]=L(j("ping")),[C,H]=L(j("pong")),[J,M]=L(j("signal")),[R,x]=L(j("stream")),[q,B]=L(j("track")),[G,N]=L(j("leave"));return e(((e,r)=>{o[r]||(o[r]=e,e.setHandlers({data(e){return((e,r)=>{const n=new Uint8Array(r),a=g(n.subarray(0,12)).replaceAll("\0",""),[o]=n.subarray(12,13),[i]=n.subarray(13,14),[c]=n.subarray(14,15),l=n.subarray(15),d=!!(1&i),u=!!(2&i),f=!!(4&i),p=!!(8&i);if(!s[a])return void console.warn(`${t}: received message with unregistered type (${a})`);m[e]||={},m[e][a]||={};const y=m[e][a][o]||={chunks:[]};if(u?y.meta=k(g(l)):y.chunks.push(l),s[a].onProgress(c/_,e,y.meta),!d)return;const w=new Uint8Array(y.chunks.reduce(((e,r)=>e+r.byteLength),0));if(y.chunks.reduce(((e,r)=>(w.set(r,e),e+r.byteLength)),0),delete m[e][a][o],f)s[a].onComplete(w,e,y.meta);else{const r=g(w);s[a].onComplete(p?k(r):r,e)}})(r,e)},stream(e){T.onPeerStream(e,r,v[r]),delete v[r]},track(e,t){T.onPeerTrack(e,t,r,P[r]),delete P[r]},signal(e){return J(e,r)},close(){return S(r)},error(e){console.error(e),S(r)}}),T.onPeerJoin(r))})),$(((e,r)=>C("",r))),H(((e,r)=>{h[r]?.(),delete h[r]})),M(((e,r)=>o[r]?.signal(e))),x(((e,r)=>v[r]=e)),B(((e,r)=>P[r]=e)),N(((e,r)=>S(r))),c&&addEventListener("beforeunload",D),{makeAction:L,leave:D,async ping(e){if(!e)throw p("ping() must be called with target peer ID");const r=Date.now();return I("",e),await new Promise((r=>h[e]=r)),Date.now()-r},getPeers(){return d(l(o).map((([e,r])=>[e,r.connection])))},addStream(e,r,t){return A(r,(async(r,n)=>{t&&await R(t,r),n.addStream(e)}))},removeStream(e,r){return A(r,((r,t)=>t.removeStream(e)))},addTrack(e,r,t,n){return A(t,(async(t,a)=>{n&&await q(n,t),a.addTrack(e,r)}))},removeTrack(e,r){return A(r,((r,t)=>t.removeTrack(e)))},replaceTrack(e,r,t,n){return A(t,(async(t,a)=>{n&&await q(n,t),a.replaceTrack(e,r)}))},onPeerJoin(e){return T.onPeerJoin=e},onPeerLeave(e){return T.onPeerLeave=e},onPeerStream(e){return T.onPeerStream=e},onPeerTrack(e){return T.onPeerTrack=e}}};const J={},M={},R={},x={},q={},B={},G={},N={},z=async e=>{if(M[e])return M[e];const r=(await A(e)).slice(0,20);return M[e]=r,R[r]=e,r},K=async(e,r,t)=>e.send(b({action:"announce",info_hash:await z(r),peer_id:s,...t})),V=(e,r,n)=>console.warn(`${t}: torrent tracker ${n?"failure":"warning"} from ${e} - ${r}`),W=(({init:e,subscribe:r,announce:a})=>{const o={};let c,l,d,u=!1;return(y,m,g)=>{const{appId:v}=y;if(o[v]?.[m])return o[v][m];const T={},D={},I=h(t,v,m),C=A(I),E=A(h(I,s)),U=(async(e,r,t)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},w(`${e}:${r}:${t}`)),{name:P},!1,["encrypt","decrypt"]))(y.password||"",v,m),_=e=>async r=>({type:r.type,sdp:await e(U,r.sdp)}),O=_(L),j=_(S),J=()=>$(!0,y),M=(e,r,t)=>{D[r]?D[r]!==e&&e.destroy():(D[r]=e,K(e,r),T[r]?.forEach(((e,r)=>{r!==t&&e.destroy()})),delete T[r])},R=(e,r)=>{D[r]===e&&delete D[r]},x=e=>(l.push(...n(e,J)),i(l.splice(0,e).map((e=>e.offerPromise.then(j).then((r=>({peer:e,offer:r}))))))),q=(e,r)=>g?.({error:`incorrect password (${y.password}) when decrypting ${r}`,appId:v,peerId:e,roomId:m}),B=e=>async(r,t,n)=>{const[a,o]=await i([C,E]);if(r!==a&&r!==o)return;const{peerId:c,offer:l,answer:d,peer:u}="string"==typeof t?k(t):t;if(c!==s&&!D[c])if(!c||l||d){if(l){const r=T[c]?.[e];if(r&&s>c)return;const t=$(!1,y);let a;t.setHandlers({connect(){return M(t,c,e)},close(){return R(t,c)}});try{a=await O(l)}catch{return void q(c,"offer")}if(t.isDead)return;const[o,d]=await i([A(h(I,c)),t.signal(a)]);n(o,b({peerId:s,answer:await j(d)}))}else if(d){let r;try{r=await O(d)}catch(e){return void q(c,"answer")}if(u)u.setHandlers({connect(){return M(u,c,e)},close(){return R(u,c)}}),u.signal(r);else{const t=T[c]?.[e];t&&!t.isDead&&t.signal(r)}}}else{if(T[c]?.[e])return;const[[{peer:r,offer:t}],a]=await i([x(1),A(h(I,c))]);T[c]||=[],T[c][e]=r,setTimeout((()=>((e,r)=>{if(D[e])return;const t=T[e]?.[r];t&&(delete T[e][r],t.destroy())})(c,e)),.9*G[e]),r.setHandlers({connect(){return M(r,c,e)},close(){return R(r,c)}}),n(a,b({peerId:s,offer:t}))}};if(!y)throw p("requires a config map as the first argument");if(!v&&!y.firebaseApp)throw p("config map is missing appId field");if(!m)throw p("roomId argument required");if(!u){const r=e(y);l=n(20,J),c=Array.isArray(r)?r:[r],u=!0,d=setInterval((()=>l=l.filter((e=>{const r=Date.now()-e.created<57333;return r||e.destroy(),r}))),59052.99)}const G=c.map((()=>5333)),N=[],z=c.map((async(e,t)=>r(await e,await C,await E,B(t),x)));i([C,E]).then((([e,r])=>{const t=async(n,o)=>{const s=await a(n,e,r);"number"==typeof s&&(G[o]=s),N[o]=setTimeout((()=>t(n,o)),G[o])};z.forEach((async(e,r)=>{await e,t(await c[r],r)}))}));let K=f;return o[v]||={},o[v][m]=H((e=>K=e),(e=>delete D[e]),(()=>{delete o[v][m],N.forEach(clearTimeout),z.forEach((async e=>(await e)())),clearInterval(d)}))}})({init(e){return((e,r,t)=>(e.relayUrls||r).slice(0,e.relayUrls?e.relayUrls.length:e.relayRedundancy||t))(e,X,3).map((e=>{const r=((e,r)=>{const t={},n=()=>{const a=new WebSocket(e);a.onclose=()=>{v[e]??=3333,setTimeout(n,v[e]),v[e]*=2},a.onmessage=e=>r(e.data),t.socket=a,t.url=a.url,t.ready=new Promise((r=>a.onopen=()=>{r(t),v[e]=3333})),t.send=e=>{1===a.readyState&&a.send(e)}};return n(),t})(e,(e=>{const r=k(e),n=r["failure reason"],a=r["warning message"],{interval:o}=r,s=R[r.info_hash];if(n)V(t,n,!0);else{if(a&&V(t,a),o&&1e3*o>B[t]&&q[t][s]){const e=Math.min(1e3*o,120333);clearInterval(x[t][s]),B[t]=e,x[t][s]=setInterval(q[t][s],e)}G[r.offer_id]||(r.offer||r.answer)&&(G[r.offer_id]=!0,N[t][s]?.(r))}})),{url:t}=r;return J[t]=r,N[t]={},r.ready}))},subscribe(e,r,t,n,a){const{url:s}=e,i=async()=>{const t=d((await a(10)).map((e=>[o(20),e])));N[e.url][r]=a=>{if(a.offer)n(r,{offer:a.offer,peerId:a.peer_id},((t,n)=>K(e,r,{answer:k(n).answer,offer_id:a.offer_id,to_peer_id:a.peer_id})));else if(a.answer){const e=t[a.offer_id];e&&n(r,{answer:a.answer,peerId:a.peer_id,peer:e.peer})}},K(e,r,{numwant:10,offers:l(t).map((([e,{offer:r}])=>({offer_id:e,offer:r})))})};return B[s]=33333,q[s]||={},q[s][r]=i,x[s]||={},x[s][r]=setInterval(i,B[s]),i(),()=>{clearInterval(x[s][r]),delete N[s][r],delete q[s][r]}},announce(e){return B[e.url]}}),F=(Q=J,()=>d(l(Q).map((([e,r])=>[e,r.socket]))));var Q;const X=["tracker.webtorrent.dev","tracker.openwebtorrent.com","tracker.btorrent.xyz","tracker.files.fm:7073/announce"].map((e=>"wss://"+e));export{X as defaultRelayUrls,F as getRelaySockets,W as joinRoom,s as selfId};