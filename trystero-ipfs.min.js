function e(e=0){return new Uint8Array(e)}function t(e=0){return new Uint8Array(e)}const r=268435456,n=34359738368,s=4398046511104,o=Math.pow(2,49),i=128,a=127;function c(e){if(e<128)return 1;if(e<16384)return 2;if(e<2097152)return 3;if(e<r)return 4;if(e<n)return 5;if(e<s)return 6;if(e<o)return 7;if(null!=Number.MAX_SAFE_INTEGER&&e>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function l(e,t,r=0){switch(c(e)){case 8:t[r++]=255&e|i,e/=128;case 7:t[r++]=255&e|i,e/=128;case 6:t[r++]=255&e|i,e/=128;case 5:t[r++]=255&e|i,e/=128;case 4:t[r++]=255&e|i,e>>>=7;case 3:t[r++]=255&e|i,e>>>=7;case 2:t[r++]=255&e|i,e>>>=7;case 1:t[r++]=255&e,e>>>=7;break;default:throw Error("unreachable")}return t}function u(e,t){let c=e[t],l=0;if(l+=c&a,c<i)return l;if(c=e[t+1],l+=(c&a)<<7,c<i)return l;if(c=e[t+2],l+=(c&a)<<14,c<i)return l;if(c=e[t+3],l+=(c&a)<<21,c<i)return l;if(c=e[t+4],l+=(c&a)*r,c<i)return l;if(c=e[t+5],l+=(c&a)*n,c<i)return l;if(c=e[t+6],l+=(c&a)*s,c<i)return l;if(c=e[t+7],l+=(c&a)*o,c<i)return l;throw new RangeError("Could not decode varint")}function h(e,r,n=0){return null==r&&(r=t(c(e))),r instanceof Uint8Array?l(e,r,n):function(e,t,r=0){switch(c(e)){case 8:t.set(r++,255&e|i),e/=128;case 7:t.set(r++,255&e|i),e/=128;case 6:t.set(r++,255&e|i),e/=128;case 5:t.set(r++,255&e|i),e/=128;case 4:t.set(r++,255&e|i),e>>>=7;case 3:t.set(r++,255&e|i),e>>>=7;case 2:t.set(r++,255&e|i),e>>>=7;case 1:t.set(r++,255&e),e>>>=7;break;default:throw Error("unreachable")}return t}(e,r,n)}function d(e,t=0){return e instanceof Uint8Array?u(e,t):function(e,t){let c=e.get(t),l=0;if(l+=c&a,c<i)return l;if(c=e.get(t+1),l+=(c&a)<<7,c<i)return l;if(c=e.get(t+2),l+=(c&a)<<14,c<i)return l;if(c=e.get(t+3),l+=(c&a)<<21,c<i)return l;if(c=e.get(t+4),l+=(c&a)*r,c<i)return l;if(c=e.get(t+5),l+=(c&a)*n,c<i)return l;if(c=e.get(t+6),l+=(c&a)*s,c<i)return l;if(c=e.get(t+7),l+=(c&a)*o,c<i)return l;throw new RangeError("Could not decode varint")}(e,t)}const p=new Float32Array([-0]),f=new Uint8Array(p.buffer);function g(e,t,r){p[0]=e,t[r]=f[0],t[r+1]=f[1],t[r+2]=f[2],t[r+3]=f[3]}const m=new Float64Array([-0]),y=new Uint8Array(m.buffer);function b(e,t,r){m[0]=e,t[r]=y[0],t[r+1]=y[1],t[r+2]=y[2],t[r+3]=y[3],t[r+4]=y[4],t[r+5]=y[5],t[r+6]=y[6],t[r+7]=y[7]}const w=BigInt(Number.MAX_SAFE_INTEGER),v=BigInt(Number.MIN_SAFE_INTEGER);class E{lo;hi;constructor(e,t){this.lo=0|e,this.hi=0|t}toNumber(e=!1){if(!e&&this.hi>>>31>0){const e=1+~this.lo>>>0;let t=~this.hi>>>0;return 0===e&&(t=t+1>>>0),-(e+4294967296*t)}return this.lo+4294967296*this.hi}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31!=0){const e=1+~this.lo>>>0;let t=~this.hi>>>0;return 0===e&&(t=t+1>>>0),-(BigInt(e)+(BigInt(t)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return 0===r?0===t?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:r<128?9:10}static fromBigInt(e){if(0n===e)return S;if(e<w&&e>v)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let r=e>>32n,n=e-(r<<32n);return t&&(r=0n|~r,n=0n|~n,++n>A&&(n=0n,++r>A&&(r=0n))),new E(Number(n),Number(r))}static fromNumber(e){if(0===e)return S;const t=e<0;t&&(e=-e);let r=e>>>0,n=(e-r)/4294967296>>>0;return t&&(n=~n>>>0,r=~r>>>0,++r>4294967295&&(r=0,++n>4294967295&&(n=0))),new E(r,n)}static from(e){return"number"==typeof e?E.fromNumber(e):"bigint"==typeof e?E.fromBigInt(e):"string"==typeof e?E.fromBigInt(BigInt(e)):null!=e.low||null!=e.high?new E(e.low>>>0,e.high>>>0):S}}const S=new E(0,0);S.toBigInt=()=>0n,S.zzEncode=S.zzDecode=function(){return this},S.length=()=>1;const A=4294967296n;function C(e,t,r){const n=r;let s,o;for(let n=0;n<e.length;++n)s=e.charCodeAt(n),s<128?t[r++]=s:s<2048?(t[r++]=s>>6|192,t[r++]=63&s|128):55296==(64512&s)&&56320==(64512&(o=e.charCodeAt(n+1)))?(s=65536+((1023&s)<<10)+(1023&o),++n,t[r++]=s>>18|240,t[r++]=s>>12&63|128,t[r++]=s>>6&63|128,t[r++]=63&s|128):(t[r++]=s>>12|224,t[r++]=s>>6&63|128,t[r++]=63&s|128);return r-n}function I(e,t){return RangeError(`index out of range: ${e.pos} + ${t??1} > ${e.len}`)}function x(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}class k{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return e;if((this.pos+=5)>this.len)throw this.pos=this.len,I(this,10);return e}int32(){return 0|this.uint32()}sint32(){const e=this.uint32();return e>>>1^-(1&e)}bool(){return 0!==this.uint32()}fixed32(){if(this.pos+4>this.len)throw I(this,4);return x(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw I(this,4);return 0|x(this.buf,this.pos+=4)}float(){if(this.pos+4>this.len)throw I(this,4);const e=(t=this.buf,r=this.pos,f[0]=t[r],f[1]=t[r+1],f[2]=t[r+2],f[3]=t[r+3],p[0]);var t,r;return this.pos+=4,e}double(){if(this.pos+8>this.len)throw I(this,4);const e=(t=this.buf,r=this.pos,y[0]=t[r],y[1]=t[r+1],y[2]=t[r+2],y[3]=t[r+3],y[4]=t[r+4],y[5]=t[r+5],y[6]=t[r+6],y[7]=t[r+7],m[0]);var t,r;return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,r=this.pos+e;if(r>this.len)throw I(this,e);return this.pos+=e,t===r?new Uint8Array(0):this.buf.subarray(t,r)}string(){const e=this.bytes();return function(e,t,r){if(r-t<1)return"";let n;const s=[];let o,i=0;for(;t<r;)o=e[t++],o<128?s[i++]=o:o>191&&o<224?s[i++]=(31&o)<<6|63&e[t++]:o>239&&o<365?(o=((7&o)<<18|(63&e[t++])<<12|(63&e[t++])<<6|63&e[t++])-65536,s[i++]=55296+(o>>10),s[i++]=56320+(1023&o)):s[i++]=(15&o)<<12|(63&e[t++])<<6|63&e[t++],i>8191&&((n??(n=[])).push(String.fromCharCode.apply(String,s)),i=0);return null!=n?(i>0&&n.push(String.fromCharCode.apply(String,s.slice(0,i))),n.join("")):String.fromCharCode.apply(String,s.slice(0,i))}(e,0,e.length)}skip(e){if("number"==typeof e){if(this.pos+e>this.len)throw I(this,e);this.pos+=e}else do{if(this.pos>=this.len)throw I(this)}while(128&this.buf[this.pos++]);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(e=7&this.uint32());)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new E(0,0);let t=0;if(!(this.len-this.pos>4)){for(;t<3;++t){if(this.pos>=this.len)throw I(this);if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(127&this.buf[this.pos++])<<7*t)>>>0,e}for(;t<4;++t)if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(127&this.buf[this.pos])<<28)>>>0,e.hi=(e.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return e;if(t=0,this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw I(this);if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw I(this,8);const e=x(this.buf,this.pos+=4),t=x(this.buf,this.pos+=4);return new E(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=u(this.buf,this.pos);return this.pos+=c(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function P(e,t,r){const n=function(e){return new k(e instanceof Uint8Array?e:e.subarray())}(e);return t.decode(n,void 0,r)}function T(e){if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw Error("Unknown type, must be binary type")}var _=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var s=0;s<e.length;s++){var o=e.charAt(s),i=o.charCodeAt(0);if(255!==r[i])throw new TypeError(o+" is ambiguous");r[i]=s}var a=e.length,c=e.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var n=0,s=0;e[t]===c;)n++,t++;for(var o=(e.length-t)*l+1>>>0,i=new Uint8Array(o);e[t];){var u=r[e.charCodeAt(t)];if(255===u)return;for(var h=0,d=o-1;(0!==u||h<s)&&-1!==d;d--,h++)u+=a*i[d]>>>0,i[d]=u%256>>>0,u=u/256>>>0;if(0!==u)throw Error("Non-zero carry");s=h,t++}if(" "!==e[t]){for(var p=o-s;p!==o&&0===i[p];)p++;for(var f=new Uint8Array(n+(o-p)),g=n;p!==o;)f[g++]=i[p++];return f}}}return{encode(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,n=0,s=0,o=t.length;s!==o&&0===t[s];)s++,r++;for(var i=(o-s)*u+1>>>0,l=new Uint8Array(i);s!==o;){for(var h=t[s],d=0,p=i-1;(0!==h||d<n)&&-1!==p;p--,d++)h+=256*l[p]>>>0,l[p]=h%a>>>0,h=h/a>>>0;if(0!==h)throw Error("Non-zero carry");n=d,s++}for(var f=i-n;f!==i&&0===l[f];)f++;for(var g=c.repeat(r);f<i;++f)g+=e.charAt(l[f]);return g},decodeUnsafe:h,decode(e){var r=h(e);if(r)return r;throw Error(`Non-${t} character`)}}},R=_;let L=class{name;prefix;baseEncode;constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},D=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,r){this.name=e,this.prefix=t;const n=t.codePointAt(0);if(void 0===n)throw Error("Invalid prefix character");this.prefixCodePoint=n,this.baseDecode=r}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return M(this,e)}};class N{decoders;constructor(e){this.decoders=e}or(e){return M(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(null!=r)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function M(e,t){return new N({...e.decoders??{[e.prefix]:e},...t.decoders??{[t.prefix]:t}})}class O{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,r,n){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=n,this.encoder=new L(e,t,r),this.decoder=new D(e,t,n)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function F({name:e,prefix:t,encode:r,decode:n}){return new O(e,t,r,n)}function U({name:e,prefix:t,alphabet:r}){const{encode:n,decode:s}=R(r,e);return F({prefix:t,name:e,encode:n,decode(e){return T(s(e))}})}function B({name:e,prefix:t,bitsPerChar:r,alphabet:n}){const s=function(e){const t={};for(let r=0;r<e.length;++r)t[e[r]]=r;return t}(n);return F({prefix:t,name:e,encode:e=>function(e,t,r){const n="="===t[t.length-1],s=(1<<r)-1;let o="",i=0,a=0;for(let n=0;n<e.length;++n)for(a=a<<8|e[n],i+=8;i>r;)i-=r,o+=t[s&a>>i];if(0!==i&&(o+=t[s&a<<r-i]),n)for(;o.length*r&7;)o+="=";return o}(e,n,r),decode:t=>function(e,t,r,n){let s=e.length;for(;"="===e[s-1];)--s;const o=new Uint8Array(s*r/8|0);let i=0,a=0,c=0;for(let l=0;l<s;++l){const s=t[e[l]];if(void 0===s)throw new SyntaxError(`Non-${n} character`);a=a<<r|s,i+=r,i>=8&&(i-=8,o[c++]=255&a>>i)}if(i>=r||255&a<<8-i)throw new SyntaxError("Unexpected end of data");return o}(t,s,r,e)})}const q=U({prefix:"9",name:"base10",alphabet:"0123456789"});var $=Object.freeze({__proto__:null,base10:q});const z=B({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),K=B({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var V=Object.freeze({__proto__:null,base16:z,base16upper:K});const H=B({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var j=Object.freeze({__proto__:null,base2:H});const G=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),W=G.reduce(((e,t,r)=>(e[r]=t,e)),[]),X=G.reduce(((e,t,r)=>{const n=t.codePointAt(0);if(null==n)throw Error("Invalid character: "+t);return e[n]=r,e}),[]);const Z=F({prefix:"ðŸš€",name:"base256emoji",encode(e){return e.reduce(((e,t)=>e+=W[t]),"")},decode(e){const t=[];for(const r of e){const e=r.codePointAt(0);if(null==e)throw Error("Invalid character: "+r);const n=X[e];if(null==n)throw Error("Non-base256emoji character: "+r);t.push(n)}return new Uint8Array(t)}});var Y=Object.freeze({__proto__:null,base256emoji:Z});const Q=B({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),J=B({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),ee=B({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),te=B({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),re=B({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),ne=B({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),se=B({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),oe=B({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),ie=B({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var ae=Object.freeze({__proto__:null,base32:Q,base32hex:re,base32hexpad:se,base32hexpadupper:oe,base32hexupper:ne,base32pad:ee,base32padupper:te,base32upper:J,base32z:ie});const ce=U({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),le=U({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var ue=Object.freeze({__proto__:null,base36:ce,base36upper:le});const he=U({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),de=U({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var pe=Object.freeze({__proto__:null,base58btc:he,base58flickr:de});const fe=B({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),ge=B({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),me=B({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),ye=B({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var be=Object.freeze({__proto__:null,base64:fe,base64pad:ge,base64url:me,base64urlpad:ye});const we=B({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var ve=Object.freeze({__proto__:null,base8:we});const Ee=F({prefix:"\0",name:"identity",encode(e){return t=e,(new TextDecoder).decode(t);var t},decode(e){return function(e){return(new TextEncoder).encode(e)}(e)}});var Se=Object.freeze({__proto__:null,identity:Ee});new TextEncoder,new TextDecoder;var Ae=function e(t,r,n){r=r||[];var s=n=n||0;for(;t>=xe;)r[n++]=255&t|Ce,t/=128;for(;t&Ie;)r[n++]=255&t|Ce,t>>>=7;return r[n]=0|t,e.bytes=n-s+1,r},Ce=128,Ie=-128,xe=2147483648;var ke=function e(t,r){var n,s=0,o=0,i=r=r||0,a=t.length;do{if(i>=a)throw e.bytes=0,new RangeError("Could not decode varint");n=t[i++],s+=o<28?(n&Te)<<o:(n&Te)*Math.pow(2,o),o+=7}while(n>=Pe);return e.bytes=i-r,s},Pe=128,Te=127;var _e=Math.pow(2,63),Re={encode:Ae,decode:ke,encodingLength(e){return e<128?1:e<16384?2:e<2097152?3:e<268435456?4:e<34359738368?5:e<4398046511104?6:e<562949953421312?7:e<72057594037927940?8:e<_e?9:10}};function Le(e,t=0){return[Re.decode(e,t),Re.decode.bytes]}function De(e,t,r=0){return Re.encode(e,t,r),t}function Ne(e){return Re.encodingLength(e)}function Me(e,t){const r=t.byteLength,n=Ne(e),s=n+Ne(r),o=new Uint8Array(s+r);return De(e,o,0),De(r,o,n),o.set(t,s),new Fe(e,r,t,o)}function Oe(e){const t=T(e),[r,n]=Le(t),[s,o]=Le(t.subarray(n)),i=t.subarray(n+o);if(i.byteLength!==s)throw Error("Incorrect length");return new Fe(r,s,i,t)}class Fe{code;size;digest;bytes;constructor(e,t,r,n){this.code=e,this.size=t,this.digest=r,this.bytes=n}}const Ue=T;const Be={code:0,name:"identity",encode:Ue,digest(e){return Me(0,Ue(e))}};class qe{name;code;encode;constructor(e,t,r){this.name=e,this.code=t,this.encode=r}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?Me(this.code,t):t.then((e=>Me(this.code,e)))}throw Error("Unknown type, must be binary type")}}const $e=function({name:e,code:t,encode:r}){return new qe(e,t,r)}({name:"sha2-256",code:18,encode:function(e){return async t=>new Uint8Array(await crypto.subtle.digest(e,t))}("SHA-256")});function ze(e,t){const{bytes:r,version:n}=e;return 0===n?function(e,t,r){const{prefix:n}=r;if(n!==he.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const s=t.get(n);if(null==s){const s=r.encode(e).slice(1);return t.set(n,s),s}return s}(r,Ve(e),t??he.encoder):function(e,t,r){const{prefix:n}=r,s=t.get(n);if(null==s){const s=r.encode(e);return t.set(n,s),s}return s}(r,Ve(e),t??Q.encoder)}const Ke=new WeakMap;function Ve(e){const t=Ke.get(e);if(null==t){const t=new Map;return Ke.set(e,t),t}return t}class He{code;version;multihash;bytes;"/";constructor(e,t,r,n){this.code=t,this.version=e,this.multihash=r,this.bytes=n,this["/"]=n}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==je)throw Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Ge)throw Error("Cannot convert non sha2-256 multihash CID to CIDv0");return He.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=Me(e,t);return He.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return He.equals(this,e)}static equals(e,t){const r=t;return null!=r&&e.code===r.code&&e.version===r.version&&function(e,t){if(e===t)return!0;{const r=t;return e.code===r.code&&e.size===r.size&&r.bytes instanceof Uint8Array&&((e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0})(e.bytes,r.bytes)}}(e.multihash,r.multihash)}toString(e){return ze(this,e)}toJSON(){return{"/":ze(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(null==e)return null;const t=e;if(t instanceof He)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:r,multihash:n,bytes:s}=t;return new He(e,r,n,s??We(e,r,n.bytes))}if(!0===t[Xe]){const{version:e,multihash:r,code:n}=t,s=Oe(r);return He.create(e,n,s)}return null}static create(e,t,r){if("number"!=typeof t)throw Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw Error("Invalid digest");switch(e){case 0:if(t!==je)throw Error(`Version 0 CID must use dag-pb (code: ${je}) block encoding`);return new He(e,t,r,r.bytes);case 1:{const n=We(e,t,r.bytes);return new He(e,t,r,n)}default:throw Error("Invalid version")}}static createV0(e){return He.create(0,je,e)}static createV1(e,t){return He.create(1,e,t)}static decode(e){const[t,r]=He.decodeFirst(e);if(0!==r.length)throw Error("Incorrect length");return t}static decodeFirst(e){const t=He.inspectBytes(e),r=t.size-t.multihashSize,n=T(e.subarray(r,r+t.multihashSize));if(n.byteLength!==t.multihashSize)throw Error("Incorrect length");const s=n.subarray(t.multihashSize-t.digestSize),o=new Fe(t.multihashCode,t.digestSize,s,n);return[0===t.version?He.createV0(o):He.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[r,n]=Le(e.subarray(t));return t+=n,r};let n=r(),s=je;if(18===n?(n=0,t=0):s=r(),0!==n&&1!==n)throw new RangeError("Invalid CID version "+n);const o=t,i=r(),a=r(),c=t+a;return{version:n,codec:s,multihashCode:i,digestSize:a,multihashSize:c-o,size:c}}static parse(e,t){const[r,n]=function(e,t){switch(e[0]){case"Q":{const r=t??he;return[he.prefix,r.decode(`${he.prefix}${e}`)]}case he.prefix:{const r=t??he;return[he.prefix,r.decode(e)]}case Q.prefix:{const r=t??Q;return[Q.prefix,r.decode(e)]}case ce.prefix:{const r=t??ce;return[ce.prefix,r.decode(e)]}default:if(null==t)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}}(e,t),s=He.decode(n);if(0===s.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return Ve(s).set(r,e),s}}const je=112,Ge=18;function We(e,t,r){const n=Ne(e),s=n+Ne(t),o=new Uint8Array(s+r.byteLength);return De(e,o,0),De(t,o,n),o.set(r,s),o}const Xe=Symbol.for("@ipld/js-cid/CID"),Ze={...Se,...j,...ve,...$,...V,...ae,...ue,...pe,...be,...Y};function Ye(e,t,r,n){return{name:e,prefix:t,encoder:{name:e,prefix:t,encode:r},decoder:{decode:n}}}const Qe=Ye("utf8","u",(e=>"u"+new TextDecoder("utf8").decode(e)),(e=>(new TextEncoder).encode(e.substring(1)))),Je=Ye("ascii","a",(e=>{let t="a";for(let r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t}),(e=>{const r=t((e=e.substring(1)).length);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return r})),et={utf8:Qe,"utf-8":Qe,hex:Ze.base16,latin1:Je,ascii:Je,binary:Je,...Ze};function tt(e,t="utf8"){const r=et[t];if(null==r)throw Error(`Unsupported encoding "${t}"`);return r.decoder.decode(`${r.prefix}${e}`)}class rt{fn;len;next;val;constructor(e,t,r){this.fn=e,this.len=t,this.next=void 0,this.val=r}}function nt(){}class st{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const ot=function(){const e=8192;let r,n=e;return function(s){if(s<1||s>4096)return t(s);n+s>e&&(r=t(e),n=0);const o=r.subarray(n,n+=s);return 7&n&&(n=1+(7|n)),o}}();class it{len;head;tail;states;constructor(){this.len=0,this.head=new rt(nt,0,0),this.tail=this.head,this.states=null}_push(e,t,r){return this.tail=this.tail.next=new rt(e,t,r),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new lt((e>>>=0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(ut,10,E.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=E.fromBigInt(e);return this._push(ut,t.length(),t)}uint64Number(e){return this._push(l,c(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=E.fromBigInt(e).zzEncode();return this._push(ut,t.length(),t)}sint64Number(e){const t=E.fromNumber(e).zzEncode();return this._push(ut,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(at,1,e?1:0)}fixed32(e){return this._push(ht,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=E.fromBigInt(e);return this._push(ht,4,t.lo)._push(ht,4,t.hi)}fixed64Number(e){const t=E.fromNumber(e);return this._push(ht,4,t.lo)._push(ht,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(g,4,e)}double(e){return this._push(b,8,e)}bytes(e){const t=e.length>>>0;return 0===t?this._push(at,1,0):this.uint32(t)._push(dt,t,e)}string(e){const t=function(e){let t=0,r=0;for(let n=0;n<e.length;++n)r=e.charCodeAt(n),r<128?t+=1:r<2048?t+=2:55296==(64512&r)&&56320==(64512&e.charCodeAt(n+1))?(++n,t+=4):t+=3;return t}(e);return 0!==t?this.uint32(t)._push(C,t,e):this._push(at,1,0)}fork(){return this.states=new st(this),this.head=this.tail=new rt(nt,0,0),this.len=0,this}reset(){return null!=this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new rt(nt,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,r=this.len;return this.reset().uint32(r),0!==r&&(this.tail.next=e.next,this.tail=t,this.len+=r),this}finish(){let e=this.head.next;const r=(n=this.len,null!=globalThis.Buffer?t(n):ot(n));var n;let s=0;for(;null!=e;)e.fn(e.val,r,s),s+=e.len,e=e.next;return r}}function at(e,t,r){t[r]=255&e}function ct(e,t,r){for(;e>127;)t[r++]=127&e|128,e>>>=7;t[r]=e}class lt extends rt{next;constructor(e,t){super(ct,e,t),this.next=void 0}}function ut(e,t,r){for(;0!==e.hi;)t[r++]=127&e.lo|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[r++]=127&e.lo|128,e.lo=e.lo>>>7;t[r++]=e.lo}function ht(e,t,r){t[r]=255&e,t[r+1]=e>>>8&255,t[r+2]=e>>>16&255,t[r+3]=e>>>24}function dt(e,t,r){t.set(e,r)}function pt(e,t,r){t.set(e,r)}function ft(e,t,r){e.length<40?C(e,t,r):null!=t.utf8Write?t.utf8Write(e,r):t.set(tt(e),r)}function gt(e,t){const r=new it;return t.encode(e,r,{lengthDelimited:!1}),r.finish()}var mt,yt,bt,wt,vt,Et,St,At,Ct,It,xt,kt,Pt,Tt,_t,Rt,Lt,Dt,Nt,Mt,Ot,Ft,Ut,Bt,qt,$t,zt,Kt,Vt,Ht,jt,Gt;function Wt(e,t,r,n){return{name:e,type:t,encode:r,decode:n}}function Xt(e){function t(t){if(null==e[t.toString()])throw Error("Invalid enum value");return e[t]}return Wt("enum",mt.VARINT,(function(e,r){const n=t(e);r.int32(n)}),(function(e){return t(e.int32())}))}function Zt(e,t){return Wt("message",mt.LENGTH_DELIMITED,e,t)}null!=globalThis.Buffer&&(it.prototype.bytes=function(e){const t=e.length>>>0;return this.uint32(t),t>0&&this._push(pt,t,e),this},it.prototype.string=function(e){const t=globalThis.Buffer.byteLength(e);return this.uint32(t),t>0&&this._push(ft,t,e),this}),(e=>{e[e.VARINT=0]="VARINT",e[e.BIT64=1]="BIT64",e[e.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",e[e.START_GROUP=3]="START_GROUP",e[e.END_GROUP=4]="END_GROUP",e[e.BIT32=5]="BIT32"})(mt||(mt={}));class Yt extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"}class Qt extends Error{code="ERR_MAX_SIZE";name="MaxSizeError"}function Jt(e){return!!e}function er(e){const t=new Map;return e.forEach((e=>{let r=t.get(e.contentTopic);r||(t.set(e.contentTopic,[]),r=t.get(e.contentTopic)),r.push(e)})),t}(t=>{let r;t.codec=()=>(null==r&&(r=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.proof&&e.proof.byteLength>0&&(t.uint32(10),t.bytes(e.proof)),null!=e.merkleRoot&&e.merkleRoot.byteLength>0&&(t.uint32(18),t.bytes(e.merkleRoot)),null!=e.epoch&&e.epoch.byteLength>0&&(t.uint32(26),t.bytes(e.epoch)),null!=e.shareX&&e.shareX.byteLength>0&&(t.uint32(34),t.bytes(e.shareX)),null!=e.shareY&&e.shareY.byteLength>0&&(t.uint32(42),t.bytes(e.shareY)),null!=e.nullifier&&e.nullifier.byteLength>0&&(t.uint32(50),t.bytes(e.nullifier)),null!=e.rlnIdentifier&&e.rlnIdentifier.byteLength>0&&(t.uint32(58),t.bytes(e.rlnIdentifier)),!1!==r.lengthDelimited&&t.ldelim()}),((t,r)=>{const n={proof:e(0),merkleRoot:e(0),epoch:e(0),shareX:e(0),shareY:e(0),nullifier:e(0),rlnIdentifier:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.proof=t.bytes();break;case 2:n.merkleRoot=t.bytes();break;case 3:n.epoch=t.bytes();break;case 4:n.shareX=t.bytes();break;case 5:n.shareY=t.bytes();break;case 6:n.nullifier=t.bytes();break;case 7:n.rlnIdentifier=t.bytes();break;default:t.skipType(7&e)}}return n}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(yt||(yt={})),(t=>{let r;t.codec=()=>(null==r&&(r=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(10),t.bytes(e.payload)),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),null!=e.version&&(t.uint32(24),t.uint32(e.version)),null!=e.timestamp&&(t.uint32(80),t.sint64(e.timestamp)),null!=e.meta&&(t.uint32(90),t.bytes(e.meta)),null!=e.rateLimitProof&&(t.uint32(170),yt.codec().encode(e.rateLimitProof,t)),null!=e.ephemeral&&(t.uint32(248),t.bool(e.ephemeral)),!1!==r.lengthDelimited&&t.ldelim()}),((t,r,n={})=>{const s={payload:e(0),contentTopic:""},o=null==r?t.len:t.pos+r;for(;t.pos<o;){const e=t.uint32();switch(e>>>3){case 1:s.payload=t.bytes();break;case 2:s.contentTopic=t.string();break;case 3:s.version=t.uint32();break;case 10:s.timestamp=t.sint64();break;case 11:s.meta=t.bytes();break;case 21:s.rateLimitProof=yt.codec().decode(t,t.uint32(),{limits:n.limits?.rateLimitProof});break;case 31:s.ephemeral=t.bool();break;default:t.skipType(7&e)}}return s}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(bt||(bt={})),(e=>{let t;(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(10),t.string(e.contentTopic)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={contentTopic:""},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();if(t>>>3==1)r.contentTopic=e.string();else e.skipType(7&t)}return r}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(e.ContentFilter||(e.ContentFilter={})),e.codec=()=>(null==t&&(t=Zt(((t,r,n={})=>{if(!1!==n.lengthDelimited&&r.fork(),null!=t.subscribe&&!1!==t.subscribe&&(r.uint32(8),r.bool(t.subscribe)),null!=t.topic&&""!==t.topic&&(r.uint32(18),r.string(t.topic)),null!=t.contentFilters)for(const n of t.contentFilters)r.uint32(26),e.ContentFilter.codec().encode(n,r);!1!==n.lengthDelimited&&r.ldelim()}),((t,r,n={})=>{const s={subscribe:!1,topic:"",contentFilters:[]},o=null==r?t.len:t.pos+r;for(;t.pos<o;){const r=t.uint32();switch(r>>>3){case 1:s.subscribe=t.bool();break;case 2:s.topic=t.string();break;case 3:if(null!=n.limits?.contentFilters&&s.contentFilters.length===n.limits.contentFilters)throw new Yt('Decode error - map field "contentFilters" had too many elements');s.contentFilters.push(e.ContentFilter.codec().decode(t,t.uint32(),{limits:n.limits?.contentFilters$}));break;default:t.skipType(7&r)}}return s}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(wt||(wt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.messages)for(const r of e.messages)t.uint32(10),At.codec().encode(r,t);!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={messages:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();if(t>>>3==1){if(null!=r.limits?.messages&&n.messages.length===r.limits.messages)throw new Yt('Decode error - map field "messages" had too many elements');n.messages.push(At.codec().decode(e,e.uint32(),{limits:r.limits?.messages$}))}else e.skipType(7&t)}return n}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(vt||(vt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.request&&(t.uint32(18),wt.codec().encode(e.request,t)),null!=e.push&&(t.uint32(26),vt.codec().encode(e.push,t)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={requestId:""},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.requestId=e.string();break;case 2:n.request=wt.codec().decode(e,e.uint32(),{limits:r.limits?.request});break;case 3:n.push=vt.codec().decode(e,e.uint32(),{limits:r.limits?.push});break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(Et||(Et={})),(t=>{let r;t.codec=()=>(null==r&&(r=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.proof&&e.proof.byteLength>0&&(t.uint32(10),t.bytes(e.proof)),null!=e.merkleRoot&&e.merkleRoot.byteLength>0&&(t.uint32(18),t.bytes(e.merkleRoot)),null!=e.epoch&&e.epoch.byteLength>0&&(t.uint32(26),t.bytes(e.epoch)),null!=e.shareX&&e.shareX.byteLength>0&&(t.uint32(34),t.bytes(e.shareX)),null!=e.shareY&&e.shareY.byteLength>0&&(t.uint32(42),t.bytes(e.shareY)),null!=e.nullifier&&e.nullifier.byteLength>0&&(t.uint32(50),t.bytes(e.nullifier)),null!=e.rlnIdentifier&&e.rlnIdentifier.byteLength>0&&(t.uint32(58),t.bytes(e.rlnIdentifier)),!1!==r.lengthDelimited&&t.ldelim()}),((t,r)=>{const n={proof:e(0),merkleRoot:e(0),epoch:e(0),shareX:e(0),shareY:e(0),nullifier:e(0),rlnIdentifier:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.proof=t.bytes();break;case 2:n.merkleRoot=t.bytes();break;case 3:n.epoch=t.bytes();break;case 4:n.shareX=t.bytes();break;case 5:n.shareY=t.bytes();break;case 6:n.nullifier=t.bytes();break;case 7:n.rlnIdentifier=t.bytes();break;default:t.skipType(7&e)}}return n}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(St||(St={})),(t=>{let r;t.codec=()=>(null==r&&(r=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(10),t.bytes(e.payload)),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),null!=e.version&&(t.uint32(24),t.uint32(e.version)),null!=e.timestamp&&(t.uint32(80),t.sint64(e.timestamp)),null!=e.meta&&(t.uint32(90),t.bytes(e.meta)),null!=e.rateLimitProof&&(t.uint32(170),St.codec().encode(e.rateLimitProof,t)),null!=e.ephemeral&&(t.uint32(248),t.bool(e.ephemeral)),!1!==r.lengthDelimited&&t.ldelim()}),((t,r,n={})=>{const s={payload:e(0),contentTopic:""},o=null==r?t.len:t.pos+r;for(;t.pos<o;){const e=t.uint32();switch(e>>>3){case 1:s.payload=t.bytes();break;case 2:s.contentTopic=t.string();break;case 3:s.version=t.uint32();break;case 10:s.timestamp=t.sint64();break;case 11:s.meta=t.bytes();break;case 21:s.rateLimitProof=St.codec().decode(t,t.uint32(),{limits:n.limits?.rateLimitProof});break;case 31:s.ephemeral=t.bool();break;default:t.skipType(7&e)}}return s}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(At||(At={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={contentTopic:""},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();if(t>>>3==2)r.contentTopic=e.string();else e.skipType(7&t)}return r}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(Ct||(Ct={})),(e=>{let t,r,n;(e=>{e.SUBSCRIBER_PING="SUBSCRIBER_PING",e.SUBSCRIBE="SUBSCRIBE",e.UNSUBSCRIBE="UNSUBSCRIBE",e.UNSUBSCRIBE_ALL="UNSUBSCRIBE_ALL"})(t=e.FilterSubscribeType||(e.FilterSubscribeType={})),(e=>{e[e.SUBSCRIBER_PING=0]="SUBSCRIBER_PING",e[e.SUBSCRIBE=1]="SUBSCRIBE",e[e.UNSUBSCRIBE=2]="UNSUBSCRIBE",e[e.UNSUBSCRIBE_ALL=3]="UNSUBSCRIBE_ALL"})(r||(r={})),(e=>{e.codec=()=>Xt(r)})(t=e.FilterSubscribeType||(e.FilterSubscribeType={})),e.codec=()=>(null==n&&(n=Zt(((t,n,s={})=>{if(!1!==s.lengthDelimited&&n.fork(),null!=t.requestId&&""!==t.requestId&&(n.uint32(10),n.string(t.requestId)),null!=t.filterSubscribeType&&0!==r[t.filterSubscribeType]&&(n.uint32(16),e.FilterSubscribeType.codec().encode(t.filterSubscribeType,n)),null!=t.pubsubTopic&&(n.uint32(82),n.string(t.pubsubTopic)),null!=t.contentTopics)for(const e of t.contentTopics)n.uint32(90),n.string(e);!1!==s.lengthDelimited&&n.ldelim()}),((r,n,s={})=>{const o={requestId:"",filterSubscribeType:t.SUBSCRIBER_PING,contentTopics:[]},i=null==n?r.len:r.pos+n;for(;r.pos<i;){const t=r.uint32();switch(t>>>3){case 1:o.requestId=r.string();break;case 2:o.filterSubscribeType=e.FilterSubscribeType.codec().decode(r);break;case 10:o.pubsubTopic=r.string();break;case 11:if(null!=s.limits?.contentTopics&&o.contentTopics.length===s.limits.contentTopics)throw new Yt('Decode error - map field "contentTopics" had too many elements');o.contentTopics.push(r.string());break;default:r.skipType(7&t)}}return o}))),n),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(It||(It={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.statusCode&&0!==e.statusCode&&(t.uint32(80),t.uint32(e.statusCode)),null!=e.statusDesc&&(t.uint32(90),t.string(e.statusDesc)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={requestId:"",statusCode:0},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.requestId=e.string();break;case 10:r.statusCode=e.uint32();break;case 11:r.statusDesc=e.string();break;default:e.skipType(7&t)}}return r}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(xt||(xt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.wakuMessage&&(t.uint32(10),Tt.codec().encode(e.wakuMessage,t)),null!=e.pubsubTopic&&(t.uint32(18),t.string(e.pubsubTopic)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.wakuMessage=Tt.codec().decode(e,e.uint32(),{limits:r.limits?.wakuMessage});break;case 2:n.pubsubTopic=e.string();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(kt||(kt={})),(t=>{let r;t.codec=()=>(null==r&&(r=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.proof&&e.proof.byteLength>0&&(t.uint32(10),t.bytes(e.proof)),null!=e.merkleRoot&&e.merkleRoot.byteLength>0&&(t.uint32(18),t.bytes(e.merkleRoot)),null!=e.epoch&&e.epoch.byteLength>0&&(t.uint32(26),t.bytes(e.epoch)),null!=e.shareX&&e.shareX.byteLength>0&&(t.uint32(34),t.bytes(e.shareX)),null!=e.shareY&&e.shareY.byteLength>0&&(t.uint32(42),t.bytes(e.shareY)),null!=e.nullifier&&e.nullifier.byteLength>0&&(t.uint32(50),t.bytes(e.nullifier)),null!=e.rlnIdentifier&&e.rlnIdentifier.byteLength>0&&(t.uint32(58),t.bytes(e.rlnIdentifier)),!1!==r.lengthDelimited&&t.ldelim()}),((t,r)=>{const n={proof:e(0),merkleRoot:e(0),epoch:e(0),shareX:e(0),shareY:e(0),nullifier:e(0),rlnIdentifier:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.proof=t.bytes();break;case 2:n.merkleRoot=t.bytes();break;case 3:n.epoch=t.bytes();break;case 4:n.shareX=t.bytes();break;case 5:n.shareY=t.bytes();break;case 6:n.nullifier=t.bytes();break;case 7:n.rlnIdentifier=t.bytes();break;default:t.skipType(7&e)}}return n}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(Pt||(Pt={})),(t=>{let r;t.codec=()=>(null==r&&(r=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(10),t.bytes(e.payload)),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),null!=e.version&&(t.uint32(24),t.uint32(e.version)),null!=e.timestamp&&(t.uint32(80),t.sint64(e.timestamp)),null!=e.meta&&(t.uint32(90),t.bytes(e.meta)),null!=e.rateLimitProof&&(t.uint32(170),Pt.codec().encode(e.rateLimitProof,t)),null!=e.ephemeral&&(t.uint32(248),t.bool(e.ephemeral)),!1!==r.lengthDelimited&&t.ldelim()}),((t,r,n={})=>{const s={payload:e(0),contentTopic:""},o=null==r?t.len:t.pos+r;for(;t.pos<o;){const e=t.uint32();switch(e>>>3){case 1:s.payload=t.bytes();break;case 2:s.contentTopic=t.string();break;case 3:s.version=t.uint32();break;case 10:s.timestamp=t.sint64();break;case 11:s.meta=t.bytes();break;case 21:s.rateLimitProof=Pt.codec().decode(t,t.uint32(),{limits:n.limits?.rateLimitProof});break;case 31:s.ephemeral=t.bool();break;default:t.skipType(7&e)}}return s}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(Tt||(Tt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.pubsubTopic&&""!==e.pubsubTopic&&(t.uint32(10),t.string(e.pubsubTopic)),null!=e.message&&(t.uint32(18),Nt.codec().encode(e.message,t)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={pubsubTopic:""},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.pubsubTopic=e.string();break;case 2:n.message=Nt.codec().decode(e,e.uint32(),{limits:r.limits?.message});break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(_t||(_t={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.isSuccess&&!1!==e.isSuccess&&(t.uint32(8),t.bool(e.isSuccess)),null!=e.info&&(t.uint32(18),t.string(e.info)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={isSuccess:!1},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.isSuccess=e.bool();break;case 2:r.info=e.string();break;default:e.skipType(7&t)}}return r}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(Rt||(Rt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.request&&(t.uint32(18),_t.codec().encode(e.request,t)),null!=e.response&&(t.uint32(26),Rt.codec().encode(e.response,t)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={requestId:""},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.requestId=e.string();break;case 2:n.request=_t.codec().decode(e,e.uint32(),{limits:r.limits?.request});break;case 3:n.response=Rt.codec().decode(e,e.uint32(),{limits:r.limits?.response});break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(Lt||(Lt={})),(t=>{let r;t.codec=()=>(null==r&&(r=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.proof&&e.proof.byteLength>0&&(t.uint32(10),t.bytes(e.proof)),null!=e.merkleRoot&&e.merkleRoot.byteLength>0&&(t.uint32(18),t.bytes(e.merkleRoot)),null!=e.epoch&&e.epoch.byteLength>0&&(t.uint32(26),t.bytes(e.epoch)),null!=e.shareX&&e.shareX.byteLength>0&&(t.uint32(34),t.bytes(e.shareX)),null!=e.shareY&&e.shareY.byteLength>0&&(t.uint32(42),t.bytes(e.shareY)),null!=e.nullifier&&e.nullifier.byteLength>0&&(t.uint32(50),t.bytes(e.nullifier)),null!=e.rlnIdentifier&&e.rlnIdentifier.byteLength>0&&(t.uint32(58),t.bytes(e.rlnIdentifier)),!1!==r.lengthDelimited&&t.ldelim()}),((t,r)=>{const n={proof:e(0),merkleRoot:e(0),epoch:e(0),shareX:e(0),shareY:e(0),nullifier:e(0),rlnIdentifier:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.proof=t.bytes();break;case 2:n.merkleRoot=t.bytes();break;case 3:n.epoch=t.bytes();break;case 4:n.shareX=t.bytes();break;case 5:n.shareY=t.bytes();break;case 6:n.nullifier=t.bytes();break;case 7:n.rlnIdentifier=t.bytes();break;default:t.skipType(7&e)}}return n}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(Dt||(Dt={})),(t=>{let r;t.codec=()=>(null==r&&(r=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(10),t.bytes(e.payload)),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),null!=e.version&&(t.uint32(24),t.uint32(e.version)),null!=e.timestamp&&(t.uint32(80),t.sint64(e.timestamp)),null!=e.meta&&(t.uint32(90),t.bytes(e.meta)),null!=e.rateLimitProof&&(t.uint32(170),Dt.codec().encode(e.rateLimitProof,t)),null!=e.ephemeral&&(t.uint32(248),t.bool(e.ephemeral)),!1!==r.lengthDelimited&&t.ldelim()}),((t,r,n={})=>{const s={payload:e(0),contentTopic:""},o=null==r?t.len:t.pos+r;for(;t.pos<o;){const e=t.uint32();switch(e>>>3){case 1:s.payload=t.bytes();break;case 2:s.contentTopic=t.string();break;case 3:s.version=t.uint32();break;case 10:s.timestamp=t.sint64();break;case 11:s.meta=t.bytes();break;case 21:s.rateLimitProof=Dt.codec().decode(t,t.uint32(),{limits:n.limits?.rateLimitProof});break;case 31:s.ephemeral=t.bool();break;default:t.skipType(7&e)}}return s}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(Nt||(Nt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.messageHash&&(t.uint32(10),t.bytes(e.messageHash)),null!=e.message&&(t.uint32(18),Bt.codec().encode(e.message,t)),null!=e.pubsubTopic&&(t.uint32(26),t.string(e.pubsubTopic)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.messageHash=e.bytes();break;case 2:n.message=Bt.codec().decode(e,e.uint32(),{limits:r.limits?.message});break;case 3:n.pubsubTopic=e.string();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(Mt||(Mt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.includeData&&!1!==e.includeData&&(t.uint32(16),t.bool(e.includeData)),null!=e.pubsubTopic&&(t.uint32(82),t.string(e.pubsubTopic)),null!=e.contentTopics)for(const r of e.contentTopics)t.uint32(90),t.string(r);if(null!=e.timeStart&&(t.uint32(96),t.sint64(e.timeStart)),null!=e.timeEnd&&(t.uint32(104),t.sint64(e.timeEnd)),null!=e.messageHashes)for(const r of e.messageHashes)t.uint32(162),t.bytes(r);null!=e.paginationCursor&&(t.uint32(410),t.bytes(e.paginationCursor)),null!=e.paginationForward&&!1!==e.paginationForward&&(t.uint32(416),t.bool(e.paginationForward)),null!=e.paginationLimit&&(t.uint32(424),t.uint64(e.paginationLimit)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={requestId:"",includeData:!1,contentTopics:[],messageHashes:[],paginationForward:!1},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.requestId=e.string();break;case 2:n.includeData=e.bool();break;case 10:n.pubsubTopic=e.string();break;case 11:if(null!=r.limits?.contentTopics&&n.contentTopics.length===r.limits.contentTopics)throw new Yt('Decode error - map field "contentTopics" had too many elements');n.contentTopics.push(e.string());break;case 12:n.timeStart=e.sint64();break;case 13:n.timeEnd=e.sint64();break;case 20:if(null!=r.limits?.messageHashes&&n.messageHashes.length===r.limits.messageHashes)throw new Yt('Decode error - map field "messageHashes" had too many elements');n.messageHashes.push(e.bytes());break;case 51:n.paginationCursor=e.bytes();break;case 52:n.paginationForward=e.bool();break;case 53:n.paginationLimit=e.uint64();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(Ot||(Ot={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.statusCode&&(t.uint32(80),t.uint32(e.statusCode)),null!=e.statusDesc&&(t.uint32(90),t.string(e.statusDesc)),null!=e.messages)for(const r of e.messages)t.uint32(162),Mt.codec().encode(r,t);null!=e.paginationCursor&&(t.uint32(410),t.bytes(e.paginationCursor)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={requestId:"",messages:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.requestId=e.string();break;case 10:n.statusCode=e.uint32();break;case 11:n.statusDesc=e.string();break;case 20:if(null!=r.limits?.messages&&n.messages.length===r.limits.messages)throw new Yt('Decode error - map field "messages" had too many elements');n.messages.push(Mt.codec().decode(e,e.uint32(),{limits:r.limits?.messages$}));break;case 51:n.paginationCursor=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(Ft||(Ft={})),(t=>{let r;t.codec=()=>(null==r&&(r=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.proof&&e.proof.byteLength>0&&(t.uint32(10),t.bytes(e.proof)),null!=e.merkleRoot&&e.merkleRoot.byteLength>0&&(t.uint32(18),t.bytes(e.merkleRoot)),null!=e.epoch&&e.epoch.byteLength>0&&(t.uint32(26),t.bytes(e.epoch)),null!=e.shareX&&e.shareX.byteLength>0&&(t.uint32(34),t.bytes(e.shareX)),null!=e.shareY&&e.shareY.byteLength>0&&(t.uint32(42),t.bytes(e.shareY)),null!=e.nullifier&&e.nullifier.byteLength>0&&(t.uint32(50),t.bytes(e.nullifier)),null!=e.rlnIdentifier&&e.rlnIdentifier.byteLength>0&&(t.uint32(58),t.bytes(e.rlnIdentifier)),!1!==r.lengthDelimited&&t.ldelim()}),((t,r)=>{const n={proof:e(0),merkleRoot:e(0),epoch:e(0),shareX:e(0),shareY:e(0),nullifier:e(0),rlnIdentifier:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.proof=t.bytes();break;case 2:n.merkleRoot=t.bytes();break;case 3:n.epoch=t.bytes();break;case 4:n.shareX=t.bytes();break;case 5:n.shareY=t.bytes();break;case 6:n.nullifier=t.bytes();break;case 7:n.rlnIdentifier=t.bytes();break;default:t.skipType(7&e)}}return n}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(Ut||(Ut={})),(t=>{let r;t.codec=()=>(null==r&&(r=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(10),t.bytes(e.payload)),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),null!=e.version&&(t.uint32(24),t.uint32(e.version)),null!=e.timestamp&&(t.uint32(80),t.sint64(e.timestamp)),null!=e.meta&&(t.uint32(90),t.bytes(e.meta)),null!=e.rateLimitProof&&(t.uint32(170),Ut.codec().encode(e.rateLimitProof,t)),null!=e.ephemeral&&(t.uint32(248),t.bool(e.ephemeral)),!1!==r.lengthDelimited&&t.ldelim()}),((t,r,n={})=>{const s={payload:e(0),contentTopic:""},o=null==r?t.len:t.pos+r;for(;t.pos<o;){const e=t.uint32();switch(e>>>3){case 1:s.payload=t.bytes();break;case 2:s.contentTopic=t.string();break;case 3:s.version=t.uint32();break;case 10:s.timestamp=t.sint64();break;case 11:s.meta=t.bytes();break;case 21:s.rateLimitProof=Ut.codec().decode(t,t.uint32(),{limits:n.limits?.rateLimitProof});break;case 31:s.ephemeral=t.bool();break;default:t.skipType(7&e)}}return s}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(Bt||(Bt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.enr&&(t.uint32(10),t.bytes(e.enr)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();if(t>>>3==1)r.enr=e.bytes();else e.skipType(7&t)}return r}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(qt||(qt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.numPeers&&(t.uint32(8),t.uint64(e.numPeers)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();if(t>>>3==1)r.numPeers=e.uint64();else e.skipType(7&t)}return r}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})($t||($t={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.peerInfos)for(const r of e.peerInfos)t.uint32(10),qt.codec().encode(r,t);!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={peerInfos:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();if(t>>>3==1){if(null!=r.limits?.peerInfos&&n.peerInfos.length===r.limits.peerInfos)throw new Yt('Decode error - map field "peerInfos" had too many elements');n.peerInfos.push(qt.codec().decode(e,e.uint32(),{limits:r.limits?.peerInfos$}))}else e.skipType(7&t)}return n}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(zt||(zt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.query&&(t.uint32(10),$t.codec().encode(e.query,t)),null!=e.response&&(t.uint32(18),zt.codec().encode(e.response,t)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.query=$t.codec().decode(e,e.uint32(),{limits:r.limits?.query});break;case 2:n.response=zt.codec().decode(e,e.uint32(),{limits:r.limits?.response});break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(Kt||(Kt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.clusterId&&(t.uint32(8),t.uint32(e.clusterId)),null!=e.shards)for(const r of e.shards)t.uint32(16),t.uint32(r);!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={shards:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.clusterId=e.uint32();break;case 2:if(null!=r.limits?.shards&&n.shards.length===r.limits.shards)throw new Yt('Decode error - map field "shards" had too many elements');n.shards.push(e.uint32());break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(Vt||(Vt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.clusterId&&(t.uint32(8),t.uint32(e.clusterId)),null!=e.shards)for(const r of e.shards)t.uint32(16),t.uint32(r);!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={shards:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.clusterId=e.uint32();break;case 2:if(null!=r.limits?.shards&&n.shards.length===r.limits.shards)throw new Yt('Decode error - map field "shards" had too many elements');n.shards.push(e.uint32());break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(Ht||(Ht={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.messageId&&""!==e.messageId&&(t.uint32(10),t.string(e.messageId)),null!=e.retrievalHint&&(t.uint32(18),t.bytes(e.retrievalHint)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={messageId:""},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.messageId=e.string();break;case 2:r.retrievalHint=e.bytes();break;default:e.skipType(7&t)}}return r}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(jt||(jt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.messageId&&""!==e.messageId&&(t.uint32(18),t.string(e.messageId)),null!=e.channelId&&""!==e.channelId&&(t.uint32(26),t.string(e.channelId)),null!=e.lamportTimestamp&&(t.uint32(80),t.int32(e.lamportTimestamp)),null!=e.causalHistory)for(const r of e.causalHistory)t.uint32(90),jt.codec().encode(r,t);null!=e.bloomFilter&&(t.uint32(98),t.bytes(e.bloomFilter)),null!=e.content&&(t.uint32(162),t.bytes(e.content)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={messageId:"",channelId:"",causalHistory:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 2:n.messageId=e.string();break;case 3:n.channelId=e.string();break;case 10:n.lamportTimestamp=e.int32();break;case 11:if(null!=r.limits?.causalHistory&&n.causalHistory.length===r.limits.causalHistory)throw new Yt('Decode error - map field "causalHistory" had too many elements');n.causalHistory.push(jt.codec().decode(e,e.uint32(),{limits:r.limits?.causalHistory$}));break;case 12:n.bloomFilter=e.bytes();break;case 20:n.content=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(Gt||(Gt={}));function tr(e){return new Promise((t=>{setTimeout(t,e)}))}const rr=e=>e.length/1048576<=1,nr="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;function sr(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function or(e){if(!Number.isSafeInteger(e)||e<0)throw Error("positive integer expected, got "+e)}function ir(e,...t){if(!sr(e))throw Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw Error("Uint8Array expected of length "+t+", got length="+e.length)}function ar(e){if("function"!=typeof e||"function"!=typeof e.create)throw Error("Hash should be wrapped by utils.createHasher");or(e.outputLen),or(e.blockLen)}function cr(e,t=!0){if(e.destroyed)throw Error("Hash instance has been destroyed");if(t&&e.finished)throw Error("Hash#digest() has already been called")}function lr(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function ur(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function hr(e,t){return e<<32-t|e>>>t}const dr=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)(),pr=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function fr(e){if(ir(e),dr)return e.toHex();let t="";for(let r=0;r<e.length;r++)t+=pr[e[r]];return t}const gr=48,mr=57,yr=65,br=70,wr=97,vr=102;function Er(e){return e>=gr&&e<=mr?e-gr:e>=yr&&e<=br?e-(yr-10):e>=wr&&e<=vr?e-(wr-10):void 0}function Sr(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);if(dr)return Uint8Array.fromHex(e);const t=e.length,r=t/2;if(t%2)throw Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let t=0,s=0;t<r;t++,s+=2){const r=Er(e.charCodeAt(s)),o=Er(e.charCodeAt(s+1));if(void 0===r||void 0===o){const t=e[s]+e[s+1];throw Error('hex string expected, got non-hex character "'+t+'" at index '+s)}n[t]=16*r+o}return n}function Ar(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}(e)),ir(e),e}function Cr(...e){let t=0;for(let r=0;r<e.length;r++){const n=e[r];ir(n),t+=n.length}const r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const s=e[t];r.set(s,n),n+=s.length}return r}class Ir{}function xr(e){const t=t=>e().update(Ar(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}function kr(e=32){if(nr&&"function"==typeof nr.getRandomValues)return nr.getRandomValues(new Uint8Array(e));if(nr&&"function"==typeof nr.randomBytes)return Uint8Array.from(nr.randomBytes(e));throw Error("crypto.getRandomValues must be defined")}function Pr(e,t,r){return e&t^e&r^t&r}class Tr extends Ir{constructor(e,t,r,n){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.buffer=new Uint8Array(e),this.view=ur(this.buffer)}update(e){cr(this),ir(e=Ar(e));const{view:t,buffer:r,blockLen:n}=this,s=e.length;for(let o=0;o<s;){const i=Math.min(n-this.pos,s-o);if(i!==n)r.set(e.subarray(o,o+i),this.pos),this.pos+=i,o+=i,this.pos===n&&(this.process(t,0),this.pos=0);else{const t=ur(e);for(;n<=s-o;o+=n)this.process(t,o)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){cr(this),function(e,t){ir(e);const r=t.outputLen;if(e.length<r)throw Error("digestInto() expects output buffer of length at least "+r)}(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:n,isLE:s}=this;let{pos:o}=this;t[o++]=128,lr(this.buffer.subarray(o)),this.padOffset>n-o&&(this.process(r,0),o=0);for(let e=o;e<n;e++)t[e]=0;!function(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const s=BigInt(32),o=BigInt(4294967295),i=Number(r>>s&o),a=Number(r&o),c=n?4:0,l=n?0:4;e.setUint32(t+c,i,n),e.setUint32(t+l,a,n)}(r,n-8,BigInt(8*this.length),s),this.process(r,0);const i=ur(e),a=this.outputLen;if(a%4)throw Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,l=this.get();if(c>l.length)throw Error("_sha2: outputLen bigger than state");for(let e=0;e<c;e++)i.setUint32(4*e,l[e],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:s,destroyed:o,pos:i}=this;return e.destroyed=o,e.finished=s,e.length=n,e.pos=i,n%t&&e.buffer.set(r),e}clone(){return this._cloneInto()}}const _r=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Rr=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Lr=BigInt(2**32-1),Dr=BigInt(32);function Nr(e,t=!1){return t?{h:Number(e&Lr),l:Number(e>>Dr&Lr)}:{h:0|Number(e>>Dr&Lr),l:0|Number(e&Lr)}}const Mr=(e,t,r)=>e>>>r,Or=(e,t,r)=>e<<32-r|t>>>r,Fr=(e,t,r)=>e>>>r|t<<32-r,Ur=(e,t,r)=>e<<32-r|t>>>r,Br=(e,t,r)=>e<<64-r|t>>>r-32,qr=(e,t,r)=>e>>>r-32|t<<64-r;function $r(e,t,r,n){const s=(t>>>0)+(n>>>0);return{h:e+r+(s/2**32|0)|0,l:0|s}}const zr=(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),Kr=(e,t,r,n)=>t+r+n+(e/2**32|0)|0,Vr=(e,t,r,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),Hr=(e,t,r,n,s)=>t+r+n+s+(e/2**32|0)|0,jr=(e,t,r,n,s)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0)+(s>>>0),Gr=(e,t,r,n,s,o)=>t+r+n+s+o+(e/2**32|0)|0,Wr=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Xr=new Uint32Array(64);class Zr extends Tr{constructor(e=32){super(64,e,8,!1),this.A=0|_r[0],this.B=0|_r[1],this.C=0|_r[2],this.D=0|_r[3],this.E=0|_r[4],this.F=0|_r[5],this.G=0|_r[6],this.H=0|_r[7]}get(){const{A:e,B:t,C:r,D:n,E:s,F:o,G:i,H:a}=this;return[e,t,r,n,s,o,i,a]}set(e,t,r,n,s,o,i,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|s,this.F=0|o,this.G=0|i,this.H=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)Xr[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=Xr[e-15],r=Xr[e-2],n=hr(t,7)^hr(t,18)^t>>>3,s=hr(r,17)^hr(r,19)^r>>>10;Xr[e]=s+Xr[e-7]+n+Xr[e-16]|0}let{A:r,B:n,C:s,D:o,E:i,F:a,G:c,H:l}=this;for(let e=0;e<64;e++){const t=l+(hr(i,6)^hr(i,11)^hr(i,25))+((u=i)&a^~u&c)+Wr[e]+Xr[e]|0,h=(hr(r,2)^hr(r,13)^hr(r,22))+Pr(r,n,s)|0;l=c,c=a,a=i,i=o+t|0,o=s,s=n,n=r,r=t+h|0}var u;r=r+this.A|0,n=n+this.B|0,s=s+this.C|0,o=o+this.D|0,i=i+this.E|0,a=a+this.F|0,c=c+this.G|0,l=l+this.H|0,this.set(r,n,s,o,i,a,c,l)}roundClean(){lr(Xr)}destroy(){this.set(0,0,0,0,0,0,0,0),lr(this.buffer)}}const Yr=(()=>function(e,t=!1){const r=e.length;let n=new Uint32Array(r),s=new Uint32Array(r);for(let o=0;o<r;o++){const{h:r,l:i}=Nr(e[o],t);[n[o],s[o]]=[r,i]}return[n,s]}(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((e=>BigInt(e)))))(),Qr=(()=>Yr[0])(),Jr=(()=>Yr[1])(),en=new Uint32Array(80),tn=new Uint32Array(80);class rn extends Tr{constructor(e=64){super(128,e,16,!1),this.Ah=0|Rr[0],this.Al=0|Rr[1],this.Bh=0|Rr[2],this.Bl=0|Rr[3],this.Ch=0|Rr[4],this.Cl=0|Rr[5],this.Dh=0|Rr[6],this.Dl=0|Rr[7],this.Eh=0|Rr[8],this.El=0|Rr[9],this.Fh=0|Rr[10],this.Fl=0|Rr[11],this.Gh=0|Rr[12],this.Gl=0|Rr[13],this.Hh=0|Rr[14],this.Hl=0|Rr[15]}get(){const{Ah:e,Al:t,Bh:r,Bl:n,Ch:s,Cl:o,Dh:i,Dl:a,Eh:c,El:l,Fh:u,Fl:h,Gh:d,Gl:p,Hh:f,Hl:g}=this;return[e,t,r,n,s,o,i,a,c,l,u,h,d,p,f,g]}set(e,t,r,n,s,o,i,a,c,l,u,h,d,p,f,g){this.Ah=0|e,this.Al=0|t,this.Bh=0|r,this.Bl=0|n,this.Ch=0|s,this.Cl=0|o,this.Dh=0|i,this.Dl=0|a,this.Eh=0|c,this.El=0|l,this.Fh=0|u,this.Fl=0|h,this.Gh=0|d,this.Gl=0|p,this.Hh=0|f,this.Hl=0|g}process(e,t){for(let r=0;r<16;r++,t+=4)en[r]=e.getUint32(t),tn[r]=e.getUint32(t+=4);for(let e=16;e<80;e++){const t=0|en[e-15],r=0|tn[e-15],n=Fr(t,r,1)^Fr(t,r,8)^Mr(t,0,7),s=Ur(t,r,1)^Ur(t,r,8)^Or(t,r,7),o=0|en[e-2],i=0|tn[e-2],a=Fr(o,i,19)^Br(o,i,61)^Mr(o,0,6),c=Ur(o,i,19)^qr(o,i,61)^Or(o,i,6),l=Vr(s,c,tn[e-7],tn[e-16]),u=Hr(l,n,a,en[e-7],en[e-16]);en[e]=0|u,tn[e]=0|l}let{Ah:r,Al:n,Bh:s,Bl:o,Ch:i,Cl:a,Dh:c,Dl:l,Eh:u,El:h,Fh:d,Fl:p,Gh:f,Gl:g,Hh:m,Hl:y}=this;for(let e=0;e<80;e++){const t=Fr(u,h,14)^Fr(u,h,18)^Br(u,h,41),b=Ur(u,h,14)^Ur(u,h,18)^qr(u,h,41),w=u&d^~u&f,v=jr(y,b,h&p^~h&g,Jr[e],tn[e]),E=Gr(v,m,t,w,Qr[e],en[e]),S=0|v,A=Fr(r,n,28)^Br(r,n,34)^Br(r,n,39),C=Ur(r,n,28)^qr(r,n,34)^qr(r,n,39),I=r&s^r&i^s&i,x=n&o^n&a^o&a;m=0|f,y=0|g,f=0|d,g=0|p,d=0|u,p=0|h,({h:u,l:h}=$r(0|c,0|l,0|E,0|S)),c=0|i,l=0|a,i=0|s,a=0|o,s=0|r,o=0|n;const k=zr(S,C,x);r=Kr(k,E,A,I),n=0|k}({h:r,l:n}=$r(0|this.Ah,0|this.Al,0|r,0|n)),({h:s,l:o}=$r(0|this.Bh,0|this.Bl,0|s,0|o)),({h:i,l:a}=$r(0|this.Ch,0|this.Cl,0|i,0|a)),({h:c,l}=$r(0|this.Dh,0|this.Dl,0|c,0|l)),({h:u,l:h}=$r(0|this.Eh,0|this.El,0|u,0|h)),({h:d,l:p}=$r(0|this.Fh,0|this.Fl,0|d,0|p)),({h:f,l:g}=$r(0|this.Gh,0|this.Gl,0|f,0|g)),({h:m,l:y}=$r(0|this.Hh,0|this.Hl,0|m,0|y)),this.set(r,n,s,o,i,a,c,l,u,h,d,p,f,g,m,y)}roundClean(){lr(en,tn)}destroy(){lr(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const nn=xr((()=>new Zr)),sn=xr((()=>new rn)),on=nn;var an,cn,ln,un,hn;(e=>{e.Relay="relay",e.Store="store",e.LightPush="lightpush",e.Filter="filter"})(an||(an={})),(e=>{e.GENERIC_FAIL="Generic error",e.REMOTE_PEER_REJECTED="Remote peer rejected",e.DECODE_FAILED="Failed to decode",e.NO_PEER_AVAILABLE="No peer available",e.NO_STREAM_AVAILABLE="No stream available",e.NO_RESPONSE="No response received",e.ENCODE_FAILED="Failed to encode",e.EMPTY_PAYLOAD="Payload is empty",e.SIZE_TOO_BIG="Size is too big",e.TOPIC_NOT_CONFIGURED="Topic not configured",e.STREAM_ABORTED="Stream aborted",e.RLN_PROOF_GENERATION="Proof generation failed",e.TOPIC_DECODER_MISMATCH="Topic decoder mismatch",e.INVALID_DECODER_TOPICS="Invalid decoder topics"})(cn||(cn={})),(e=>{e.BOOTSTRAP="bootstrap",e.PEER_EXCHANGE="peer-exchange",e.LOCAL="local-peer-cache"})(ln||(ln={})),(e=>{e.PEER_DISCOVERY_BOOTSTRAP="peer:discovery:bootstrap",e.PEER_DISCOVERY_PEER_EXCHANGE="peer:discovery:peer-exchange",e.PEER_CONNECT_BOOTSTRAP="peer:connected:bootstrap",e.PEER_CONNECT_PEER_EXCHANGE="peer:connected:peer-exchange"})(un||(un={})),(e=>{e.CONNECTION_STATUS="waku:connection"})(hn||(hn={}));const dn="@waku/bootstrap",pn={clusterId:1,shards:[0,1,2,3,4,5,6,7,8]};var fn,gn;function mn(e,t="utf8"){const r=et[t];if(null==r)throw Error(`Unsupported encoding "${t}"`);return r.encoder.encode(e).substring(1)}function yn(e){if("string"==typeof e){return tt(e.replace(/^0x/i,"").toLowerCase(),"base16")}return e}(e=>{e.StatusChange="health:change"})(fn||(fn={})),(e=>{e.Unhealthy="Unhealthy",e.MinimallyHealthy="MinimallyHealthy",e.SufficientlyHealthy="SufficientlyHealthy"})(gn||(gn={}));const bn=e=>mn(e,"base16"),wn=e=>mn(e,"utf8"),vn=e=>tt(e,"utf8");function En(e){const t=e.reduce(((e,t)=>e+t.length),0),r=new Uint8Array(t);let n=0;for(const t of e)r.set(t,n),n+=t.length;return r}const Sn=e=>{if("contentTopics"in e&&e.contentTopics)return Array.from(new Set(e.contentTopics.map((t=>kn(t,e.clusterId)))));if("shards"in e){if(void 0===e.shards)throw Error("Invalid shard");return Array.from(new Set(e.shards.map((t=>`/waku/2/rs/${e.clusterId??1}/${t}`))))}if("application"in e&&"version"in e)return[kn(`/${e.application}/${e.version}/default/default`,e.clusterId)];throw Error("Missing required configuration in shard parameters")},An=e=>{const t=e.split("/");if(6!=t.length||"waku"!==t[1]||"2"!==t[2]||"rs"!==t[3])throw Error("Invalid pubsub topic");const r=parseInt(t[4]),n=parseInt(t[5]);if(isNaN(r)||isNaN(n))throw Error("Invalid clusterId or shard");return{clusterId:r,shard:n}},Cn=e=>{const t=new Set,r=new Set;for(const n of e){const{clusterId:e,shard:s}=An(n);t.add(`${e}:${s}`),r.add(e)}if(0===t.size)throw Error("No valid pubsub topics provided");if(r.size>1)throw Error("Pubsub topics from multiple cluster IDs are not supported");return{clusterId:r.values().next().value,shards:Array.from(t).map((e=>parseInt(e.split(":")[1])))}};function In(e,t){if(!t.includes(e))throw Error(`Pubsub topic ${e} has not been configured on this instance. Configured topics are: ${t}. Please update your configuration by passing in the topic during Waku node instantiation.`)}function xn(e,t=8){const{application:r,version:n}=function(e){const t=e.split("/");if(t.length<5||t.length>6)throw Error("Content topic format is invalid");let r=0;if(6==t.length){if(r=parseInt(t[1]),isNaN(r))throw Error("Invalid generation field in content topic");if(r>0)throw Error("Generation greater than 0 is not supported")}const n=t.splice(-4);if(0==n[0].length)throw Error("Application field cannot be empty");if(0==n[1].length)throw Error("Version field cannot be empty");if(0==n[2].length)throw Error("Topic name field cannot be empty");if(0==n[3].length)throw Error("Encoding field cannot be empty");return{generation:r,application:n[0],version:n[1],topicName:n[2],encoding:n[3]}}(e),s=on(En([vn(r),vn(n)])),o=new DataView(s.buffer.slice(-8));return Number(o.getBigUint64(0,!1)%BigInt(t))}function kn(e,t=1,r=8){if(!e)throw Error("Content topic must be specified");return`/waku/2/rs/${t}/${xn(e,r)}`}function Pn(e,t){return"string"==typeof t?t:void 0!==t?.shard?(e=>{if(void 0===e.shard)throw Error("Invalid shard");return`/waku/2/rs/${e.clusterId??1}/${e.shard}`})(t):kn(e,t?.clusterId??1)}const Tn=e=>{if((e=new Uint8Array(e)).length<3)throw Error("Insufficient data");const t=new DataView(e.buffer),r=t.getUint16(0),n=[];if(130===e.length)for(let e=0;e<1024;e++){const r=Math.floor(e/8)+2,s=7-e%8;t.getUint8(r)&1<<s&&n.push(e)}else{const r=t.getUint8(2);for(let s=0,o=3;s<r;s++,o+=2){if(o+1>=e.length)throw Error("Unexpected end of data");n.push(t.getUint16(o))}}return{clusterId:r,shards:n}},_n=e=>{const{clusterId:t,shards:r}=e,n=r.length>=64?130:3+2*r.length,s=new ArrayBuffer(n),o=new DataView(s);if(o.setUint16(0,t),r.length>=64)for(const e of r){const t=Math.floor(e/8)+2,r=7-e%8;o.setUint8(t,o.getUint8(t)|1<<r)}else{o.setUint8(2,r.length);for(let e=0,t=3;e<r.length;e++,t+=2)o.setUint16(t,r[e])}return new Uint8Array(s)};var Rn="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function Ln(e){return e&&e.__esModule&&{}.hasOwnProperty.call(e,"default")?e.default:e}var Dn,Nn,Mn,On,Fn,Un={exports:{}};function Bn(){if(Nn)return Dn;Nn=1;var e=1e3,t=60*e,r=60*t,n=24*r,s=7*n,o=365.25*n;function i(e,t,r,n){var s=t>=1.5*r;return Math.round(e/r)+" "+n+(s?"s":"")}return Dn=(a,c)=>{c=c||{};var l=typeof a;if("string"===l&&a.length>0)return function(i){if((i+="").length>100)return;var a=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(i);if(!a)return;var c=parseFloat(a[1]);switch((a[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return c*o;case"weeks":case"week":case"w":return c*s;case"days":case"day":case"d":return c*n;case"hours":case"hour":case"hrs":case"hr":case"h":return c*r;case"minutes":case"minute":case"mins":case"min":case"m":return c*t;case"seconds":case"second":case"secs":case"sec":case"s":return c*e;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return c;default:return}}(a);if("number"===l&&isFinite(a))return c.long?function(s){var o=Math.abs(s);if(o>=n)return i(s,o,n,"day");if(o>=r)return i(s,o,r,"hour");if(o>=t)return i(s,o,t,"minute");if(o>=e)return i(s,o,e,"second");return s+" ms"}(a):function(s){var o=Math.abs(s);if(o>=n)return Math.round(s/n)+"d";if(o>=r)return Math.round(s/r)+"h";if(o>=t)return Math.round(s/t)+"m";if(o>=e)return Math.round(s/e)+"s";return s+"ms"}(a);throw Error("val is not a non-empty string or a valid number. val="+JSON.stringify(a))},Dn}var qn=(Fn||(Fn=1,function(e,t){t.formatArgs=function(t){if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const r="color: "+this.color;t.splice(1,0,r,"color: inherit");let n=0,s=0;t[0].replace(/%[a-zA-Z%]/g,(e=>{"%%"!==e&&(n++,"%c"===e&&(s=n))})),t.splice(s,0,r)},t.save=e=>{try{e?t.storage.setItem("debug",e):t.storage.removeItem("debug")}catch(e){}},t.load=()=>{let e;try{e=t.storage.getItem("debug")||t.storage.getItem("DEBUG")}catch(e){}return!e&&"undefined"!=typeof process&&"env"in process&&(e=process.env.DEBUG),e},t.useColors=()=>{if("undefined"!=typeof window&&window.process&&("renderer"===window.process.type||window.process.__nwjs))return!0;if("undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let e;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&(e=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(e[1],10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},t.storage=(()=>{try{return localStorage}catch(e){}})(),t.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.log=console.debug||console.log||(()=>{}),e.exports=(On||(On=1,Mn=function(e){function t(e){let n,s,o,i=null;function a(...e){if(!a.enabled)return;const r=a,s=Number(new Date),o=s-(n||s);r.diff=o,r.prev=n,r.curr=s,n=s,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let i=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,((n,s)=>{if("%%"===n)return"%";i++;const o=t.formatters[s];if("function"==typeof o){const t=e[i];n=o.call(r,t),e.splice(i,1),i--}return n})),t.formatArgs.call(r,e),(r.log||t.log).apply(r,e)}return a.namespace=e,a.useColors=t.useColors(),a.color=t.selectColor(e),a.extend=r,a.destroy=t.destroy,Object.defineProperty(a,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==i?i:(s!==t.namespaces&&(s=t.namespaces,o=t.enabled(e)),o),set(e){i=e}}),"function"==typeof t.init&&t.init(a),a}function r(e,r){const n=t(this.namespace+(void 0===r?":":r)+e);return n.log=this.log,n}function n(e,t){let r=0,n=0,s=-1,o=0;for(;r<e.length;)if(n<t.length&&(t[n]===e[r]||"*"===t[n]))"*"===t[n]?(s=n,o=r,n++):(r++,n++);else{if(-1===s)return!1;n=s+1,o++,r=o}for(;n<t.length&&"*"===t[n];)n++;return n===t.length}return t.debug=t,t.default=t,t.coerce=e=>e instanceof Error?e.stack||e.message:e,t.disable=()=>{const e=[...t.names,...t.skips.map((e=>"-"+e))].join(",");return t.enable(""),e},t.enable=e=>{t.save(e),t.namespaces=e,t.names=[],t.skips=[];const r=("string"==typeof e?e:"").trim().replace(/\s+/g,",").split(",").filter(Boolean);for(const e of r)"-"===e[0]?t.skips.push(e.slice(1)):t.names.push(e)},t.enabled=e=>{for(const r of t.skips)if(n(e,r))return!1;for(const r of t.names)if(n(e,r))return!0;return!1},t.humanize=Bn(),t.destroy=()=>{console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(e).forEach((r=>{t[r]=e[r]})),t.names=[],t.skips=[],t.formatters={},t.selectColor=e=>{let r=0;for(let t=0;t<e.length;t++)r=(r<<5)-r+e.charCodeAt(t),r|=0;return t.colors[Math.abs(r)%t.colors.length]},t.enable(t.load()),t}),Mn)(t);const{formatters:r}=e.exports;r.j=e=>{try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}}(Un,Un.exports)),Un.exports),$n=Ln(qn);const zn="waku";let Kn=class e{_info;_warn;_error;static createDebugNamespace(e,t){return t?`${zn}:${e}:${t}`:`${zn}:${e}`}constructor(t){this._info=$n(e.createDebugNamespace("info",t)),this._warn=$n(e.createDebugNamespace("warn",t)),this._error=$n(e.createDebugNamespace("error",t))}get info(){return this._info}get warn(){return this._warn}get error(){return this._error}log(e,...t){(0,this[e])(...t)}};const Vn=new Kn("message:version-0"),Hn=BigInt(1e6);class jn{pubsubTopic;proto;constructor(e,t){this.pubsubTopic=e,this.proto=t}get ephemeral(){return!!this.proto.ephemeral}get payload(){return this.proto.payload}get contentTopic(){return this.proto.contentTopic}get _rawTimestamp(){return this.proto.timestamp}get timestamp(){try{if(this.proto.timestamp){const e=this.proto.timestamp/Hn;return new Date(Number(e))}return}catch(e){return}}get meta(){return this.proto.meta}get version(){return this.proto.version??0}get rateLimitProof(){return this.proto.rateLimitProof}}let Gn=class{contentTopic;ephemeral;pubsubTopic;metaSetter;constructor(e,t=!1,r,n){if(this.contentTopic=e,this.ephemeral=t,this.pubsubTopic=r,this.metaSetter=n,!e||""===e)throw Error("Content topic must be specified")}async toWire(e){return bt.encode(await this.toProtoObj(e))}async toProtoObj(e){const t=e.timestamp??new Date,r={payload:e.payload,version:0,contentTopic:this.contentTopic,timestamp:BigInt(t.valueOf())*Hn,meta:void 0,rateLimitProof:e.rateLimitProof,ephemeral:this.ephemeral};if(this.metaSetter){const e=this.metaSetter(r);return{...r,meta:e}}return r}};function Wn({pubsubTopic:e,pubsubTopicShardInfo:t,contentTopic:r,ephemeral:n,metaSetter:s}){return new Gn(r,n,Pn(r,e??t),s)}let Xn=class{pubsubTopic;contentTopic;constructor(e,t){if(this.pubsubTopic=e,this.contentTopic=t,!t||""===t)throw Error("Content topic must be specified")}fromWireToProtoObj(e){const t=bt.decode(e);return Promise.resolve({payload:t.payload,contentTopic:t.contentTopic,version:t.version??void 0,timestamp:t.timestamp??void 0,meta:t.meta??void 0,rateLimitProof:t.rateLimitProof??void 0,ephemeral:t.ephemeral??!1})}async fromProtoObj(e,t){return t.version?(Vn.error("Failed to decode due to incorrect version, expected:",0,", actual:",t.version),Promise.resolve(void 0)):new jn(e,t)}};function Zn(e,t){return new Xn(Pn(e,t),e)}function Yn(e){if(null!=e[Symbol.asyncIterator])return(async()=>{const t=[];for await(const r of e)t.push(r);return t})();const t=[];for(const r of e)t.push(r);return t}function Qn(e,r){null==r&&(r=e.reduce(((e,t)=>e+t.length),0));const n=t(r);let s=0;for(const t of e)n.set(t,s),s+=t.length;return n}function Jn(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0}const es=Symbol.for("@achingbrain/uint8arraylist");function ts(e,t){if(null==t||t<0)throw new RangeError("index is out of bounds");let r=0;for(const n of e){const e=r+n.byteLength;if(t<e)return{buf:n,index:t-r};r=e}throw new RangeError("index is out of bounds")}function rs(e){return!!e?.[es]}class ns{bufs;length;[es]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const r of e)if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.push(r);else{if(!rs(r))throw Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");t+=r.byteLength,this.bufs.push(...r.bufs)}this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const r of e.reverse())if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.unshift(r);else{if(!rs(r))throw Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");t+=r.byteLength,this.bufs.unshift(...r.bufs)}this.length+=t}get(e){const t=ts(this.bufs,e);return t.buf[t.index]}set(e,t){const r=ts(this.bufs,e);r.buf[r.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let r=0;r<e.length;r++)this.set(t+r,e[r]);else{if(!rs(e))throw Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");for(let r=0;r<e.length;r++)this.set(t+r,e.get(r))}}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength)return this.bufs=[],void(this.length=0);for(;this.bufs.length>0;){if(!(e>=this.bufs[0].byteLength)){this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift()}}}slice(e,t){const{bufs:r,length:n}=this._subList(e,t);return Qn(r,n)}subarray(e,t){const{bufs:r,length:n}=this._subList(e,t);return 1===r.length?r[0]:Qn(r,n)}sublist(e,t){const{bufs:r,length:n}=this._subList(e,t),s=new ns;return s.length=n,s.bufs=[...r],s}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(0===e&&t===this.length)return{bufs:this.bufs,length:this.length};const r=[];let n=0;for(let s=0;s<this.bufs.length;s++){const o=this.bufs[s],i=n,a=i+o.byteLength;if(n=a,e>=a)continue;const c=e>=i&&e<a,l=t>i&&t<=a;if(c&&l){if(e===i&&t===a){r.push(o);break}const n=e-i;r.push(o.subarray(n,n+(t-e)));break}if(c){if(0===e){r.push(o);continue}r.push(o.subarray(e-i))}else{if(l){if(t===a){r.push(o);break}r.push(o.subarray(0,t-i));break}r.push(o)}}return{bufs:r,length:t-e}}indexOf(e,t=0){if(!(rs(e)||e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const r=e instanceof Uint8Array?e:e.subarray();if(isNaN(t=Number(t??0))&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),0===e.length)return t>this.length?this.length:t;const n=r.byteLength;if(0===n)throw new TypeError("search must be at least 1 byte long");const s=new Int32Array(256);for(let e=0;e<256;e++)s[e]=-1;for(let e=0;e<n;e++)s[r[e]]=e;const o=s,i=this.byteLength-r.byteLength,a=r.byteLength-1;let c;for(let e=t;e<=i;e+=c){c=0;for(let t=a;t>=0;t--){const n=this.get(e+t);if(r[t]!==n){c=Math.max(1,t-o[n]);break}}if(0===c)return e}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,r){const n=t(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,r),this.write(n,e)}getInt16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,t)}setInt16(t,r,n){const s=e(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,r,n),this.write(s,t)}getInt32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,t)}setInt32(t,r,n){const s=e(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,r,n),this.write(s,t)}getBigInt64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,t)}setBigInt64(t,r,n){const s=e(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,r,n),this.write(s,t)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,r){const n=t(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,r),this.write(n,e)}getUint16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,t)}setUint16(t,r,n){const s=e(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,r,n),this.write(s,t)}getUint32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,t)}setUint32(t,r,n){const s=e(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,r,n),this.write(s,t)}getBigUint64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,t)}setBigUint64(t,r,n){const s=e(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,r,n),this.write(s,t)}getFloat32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,t)}setFloat32(t,r,n){const s=e(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,r,n),this.write(s,t)}getFloat64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,t)}setFloat64(t,r,n){const s=e(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,r,n),this.write(s,t)}equals(e){if(null==e)return!1;if(!(e instanceof ns))return!1;if(e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!Jn(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const r=new ns;return r.bufs=e,null==t&&(t=e.reduce(((e,t)=>e+t.byteLength),0)),r.length=t,r}}function ss(e){return null!=e[Symbol.asyncIterator]}const os=e=>{const r=c(e),n=t(r);return h(e,n),os.bytes=r,n};function is(e,t){const r=(t=t??{}).lengthEncoder??os;function*n(e){const t=r(e.byteLength);t instanceof Uint8Array?yield t:yield*t,e instanceof Uint8Array?yield e:yield*e}return ss(e)?async function*(){for await(const t of e)yield*n(t)}():function*(){for(const t of e)yield*n(t)}()}os.bytes=0,is.single=(e,t)=>{const r=(t=t??{}).lengthEncoder??os;return new ns(r(e.byteLength),e)};let as=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},cs=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},ls=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"},us=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};var hs;(e=>{e[e.LENGTH=0]="LENGTH",e[e.DATA=1]="DATA"})(hs||(hs={}));const ds=e=>{const t=d(e);return ds.bytes=c(t),t};function ps(e,t){const r=new ns;let n=hs.LENGTH,s=-1;const o=t?.lengthDecoder??ds,i=t?.maxLengthLength??8,a=t?.maxDataLength??4194304;function*c(){for(;r.byteLength>0;){if(n===hs.LENGTH)try{if(s=o(r),s<0)throw new as("Invalid message length");if(s>a)throw new cs("Message length too long");const e=o.bytes;r.consume(e),null!=t?.onLength&&t.onLength(s),n=hs.DATA}catch(e){if(e instanceof RangeError){if(r.byteLength>i)throw new ls("Message length length too long");break}throw e}if(n===hs.DATA){if(r.byteLength<s)break;const e=r.sublist(0,s);r.consume(s),null!=t?.onData&&t.onData(e),yield e,n=hs.LENGTH}}}return ss(e)?async function*(){for await(const t of e)r.append(t),yield*c();if(r.byteLength>0)throw new us("Unexpected end of input")}():function*(){for(const t of e)r.append(t),yield*c();if(r.byteLength>0)throw new us("Unexpected end of input")}()}function fs(){const e={};return e.promise=new Promise(((t,r)=>{e.resolve=t,e.reject=r})),e}ds.bytes=0,ps.fromReader=(e,t)=>{let r=1;return ps(async function*(){for(;;)try{const{done:t,value:n}=await e.next(r);if(!0===t)return;null!=n&&(yield n)}catch(e){if("ERR_UNDER_READ"===e.code)return{done:!0,value:null};throw e}finally{r=1}}(),{...t??{},onLength(e){r=e}})};class gs{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||e-1&e)throw Error("Max size for a FixedFIFO should be a power of two");this.buffer=Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return void 0===this.buffer[this.top]&&(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(void 0!==e)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return void 0===this.buffer[this.btm]}}class ms{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new gs(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return null!=e?.byteLength?e.byteLength:1}push(e){if(null!=e?.value&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new gs(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(void 0===e&&null!=this.tail.next){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return null!=e?.value&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let ys=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function bs(e={}){return function(e,t){t=t??{};let r,n,s,o=t.onEnd,i=new ms,a=fs();const c=async()=>{try{return i.isEmpty()?s?{done:!0}:await new Promise(((t,s)=>{n=o=>{n=null,i.push(o);try{t(e(i))}catch(e){s(e)}return r}})):e(i)}finally{i.isEmpty()&&queueMicrotask((()=>{a.resolve(),a=fs()}))}},l=e=>null!=n?n(e):(i.push(e),r),u=e=>(i=new ms,null!=n?n({error:e}):(i.push({error:e}),r)),h=e=>{if(s)return r;if(!0!==t?.objectMode&&null==e?.byteLength)throw Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:e})},d=e=>s?r:(s=!0,null!=e?u(e):l({done:!0})),p=()=>(i=new ms,d(),{done:!0}),f=e=>(d(e),{done:!0});if(r={[Symbol.asyncIterator](){return this},next:c,return:p,throw:f,push:h,end:d,get readableLength(){return i.size},async onEmpty(e){const t=e?.signal;if(t?.throwIfAborted(),i.isEmpty())return;let r,n;null!=t&&(r=new Promise(((e,r)=>{n=()=>{r(new ys)},t.addEventListener("abort",n)})));try{await Promise.race([a.promise,r])}finally{null!=n&&null!=t&&t?.removeEventListener("abort",n)}}},null==o)return r;const g=r;return r={[Symbol.asyncIterator](){return this},next:()=>g.next(),throw:e=>(g.throw(e),null!=o&&(o(e),o=void 0),{done:!0}),return:()=>(g.return(),null!=o&&(o(),o=void 0),{done:!0}),push:h,end:e=>(g.end(e),null!=o&&(o(e),o=void 0),r),get readableLength(){return g.readableLength},onEmpty(e){return g.onEmpty(e)}},r}((e=>{const t=e.shift();if(null==t)return{done:!0};if(null!=t.error)throw t.error;return{done:!0===t.done,value:t.value}}),e)}let ws=class extends Error{type;code;constructor(e,t,r){super(e??"The operation was aborted"),this.type="aborted",this.name=r??"AbortError",this.code=t??"ABORT_ERR"}};async function vs(e,t,r){if(null==t)return e;if(t.aborted)return e.catch((()=>{})),Promise.reject(new ws(r?.errorMessage,r?.errorCode,r?.errorName));let n;const s=new ws(r?.errorMessage,r?.errorCode,r?.errorName);try{return await Promise.race([e,new Promise(((e,r)=>{n=()=>{r(s)},t.addEventListener("abort",n)}))])}finally{null!=n&&t.removeEventListener("abort",n)}}let Es=class{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=fs(),this.haveNext=fs()}[Symbol.asyncIterator](){return this}async next(){if(null==this.nextResult&&await this.haveNext.promise,null==this.nextResult)throw Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=fs(),e}async throw(e){this.ended=!0,this.error=e,null!=e&&(this.haveNext.promise.catch((()=>{})),this.haveNext.reject(e));return{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){null!=e?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(null!=e&&this.ended)throw this.error??Error("Cannot push value onto an ended pushable");for(;null!=this.nextResult;)await this.readNext.promise;null!=e?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=fs(),await vs(this.readNext.promise,t?.signal,t)}};function Ss(){return new Es}async function*As(e){const t=new AbortController,r=Ss();(async function(e,t,r){try{await Promise.all(e.map((async e=>{for await(const n of e)await t.push(n,{signal:r}),r.throwIfAborted()}))),await t.end(void 0,{signal:r})}catch(e){await t.end(e,{signal:r}).catch((()=>{}))}})(e,r,t.signal).catch((()=>{}));try{yield*r}finally{t.abort()}}function Cs(...e){const t=[];for(const r of e)null==r[Symbol.asyncIterator]&&t.push(r);return t.length===e.length?function*(e){for(const t of e)yield*t}(t):As(e)}function Is(e,...t){if(null==e)throw Error("Empty pipeline");if(Ts(e)){const t=e;e=()=>t.source}else if(Ps(e)||ks(e)){const t=e;e=()=>t}const r=[e,...t];if(r.length>1&&Ts(r[r.length-1])&&(r[r.length-1]=r[r.length-1].sink),r.length>2)for(let e=1;e<r.length-1;e++)Ts(r[e])&&(r[e]=_s(r[e]));return xs(...r)}const xs=(...e)=>{let t;for(;e.length>0;)t=e.shift()(t);return t},ks=e=>null!=e?.[Symbol.asyncIterator],Ps=e=>null!=e?.[Symbol.iterator],Ts=e=>null!=e&&(null!=e.sink&&null!=e.source),_s=e=>t=>{const r=e.sink(t);if(null!=r?.then){const t=bs({objectMode:!0});let n;r.then((()=>{t.end()}),(e=>{t.end(e)}));const s=e.source;if(ks(s))n=async function*(){yield*s,t.end()};else{if(!Ps(s))throw Error("Unknown duplex source type - must be Iterable or AsyncIterable");n=function*(){yield*s,t.end()}}return Cs(t,n())}return e.source};function Rs(e){return e.filter((e=>"open"===e.status)).sort(((e,t)=>t.timeline.open-e.timeline.open)).at(0)}const Ls="consumed";let Ds,Ns=class{multicodec;getConnections;addEventListener;log;ongoingCreation=new Set;streamPool=new Map;constructor(e,t,r){this.multicodec=e,this.getConnections=t,this.addEventListener=r,this.log=new Kn("stream-manager:"+e),this.addEventListener("peer:update",this.handlePeerUpdateStreamPool)}async getStream(e){const t=e.toString(),r=this.streamPool.get(t);r&&(this.streamPool.delete(t),await r);let n=this.getOpenStreamForCodec(e);return n?(this.log.info(`Found existing stream peerId=${t} multicodec=${this.multicodec}`),this.lockStream(t,n),n):(n=await this.createStream(e),this.lockStream(t,n),n)}async createStream(e,t=0){const r=Rs(this.getConnections(e));if(!r)throw Error(`Failed to get a connection to the peer peerId=${e.toString()} multicodec=${this.multicodec}`);let n,s;for(let o=0;o<t+1;o++)try{this.log.info(`Attempting to create a stream for peerId=${e.toString()} multicodec=${this.multicodec}`),s=await r.newStream(this.multicodec),this.log.info(`Created stream for peerId=${e.toString()} multicodec=${this.multicodec}`);break}catch(e){n=e}if(!s)throw Error(`Failed to create a new stream for ${e.toString()} -- `+n);return s}async createStreamWithLock(e){const t=e.id.toString();if(this.ongoingCreation.has(t))this.log.info(`Skipping creation of a stream due to lock for peerId=${t} multicodec=${this.multicodec}`);else try{this.ongoingCreation.add(t),await this.createStream(e.id)}catch(e){this.log.error("Failed to createStreamWithLock:",e)}finally{this.ongoingCreation.delete(t)}}handlePeerUpdateStreamPool=e=>{const{peer:t}=e.detail;if(!t.protocols.includes(this.multicodec))return;this.getOpenStreamForCodec(t.id)||this.scheduleNewStream(t)};scheduleNewStream(e){this.log.info(`Scheduling creation of a stream for peerId=${e.id.toString()} multicodec=${this.multicodec}`),this.streamPool.has(e.id.toString())&&this.streamPool.delete(e.id.toString()),this.streamPool.set(e.id.toString(),this.createStreamWithLock(e))}getOpenStreamForCodec(e){const t=Rs(this.getConnections(e));if(!t)return;const r=t.streams.find((e=>e.protocol===this.multicodec));if(!r)return;return["done","closed","closing"].includes(r.writeStatus||"")||this.isStreamLocked(r)?void 0:r}lockStream(e,t){this.log.info(`Locking stream for peerId:${e}\tstreamId:${t.id}`),t.metadata[Ls]=!0}isStreamLocked(e){return!!e.metadata[Ls]}},Ms=class{multicodec;components;pubsubTopics;addLibp2pEventListener;removeLibp2pEventListener;streamManager;constructor(e,t,r){this.multicodec=e,this.components=t,this.pubsubTopics=r,this.addLibp2pEventListener=t.events.addEventListener.bind(t.events),this.removeLibp2pEventListener=t.events.removeEventListener.bind(t.events),this.streamManager=new Ns(e,t.connectionManager.getConnections.bind(t.connectionManager),this.addLibp2pEventListener)}async getStream(e){return this.streamManager.getStream(e)}};const Os=new Uint8Array(16);function Fs(){if(!Ds&&(Ds="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!Ds))throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return Ds(Os)}const Us=[];for(let e=0;e<256;++e)Us.push((e+256).toString(16).slice(1));var Bs={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function qs(e){if(Bs.randomUUID&&!e)return Bs.randomUUID();const t=(e=e||{}).random||(e.rng||Fs)();return t[6]=15&t[6]|64,t[8]=63&t[8]|128,function(e,t=0){return Us[e[t+0]]+Us[e[t+1]]+Us[e[t+2]]+Us[e[t+3]]+"-"+Us[e[t+4]]+Us[e[t+5]]+"-"+Us[e[t+6]]+Us[e[t+7]]+"-"+Us[e[t+8]]+Us[e[t+9]]+"-"+Us[e[t+10]]+Us[e[t+11]]+Us[e[t+12]]+Us[e[t+13]]+Us[e[t+14]]+Us[e[t+15]]}(t)}class $s{proto;constructor(e){this.proto=e}static decode(e){const t=kt.decode(e);return new $s(t)}encode(){return kt.encode(this.proto)}get wakuMessage(){return this.proto.wakuMessage}get pubsubTopic(){return this.proto.pubsubTopic}}class zs{proto;constructor(e){this.proto=e}static createSubscribeRequest(e,t){return new zs({requestId:qs(),filterSubscribeType:It.FilterSubscribeType.SUBSCRIBE,pubsubTopic:e,contentTopics:t})}static createUnsubscribeRequest(e,t){return new zs({requestId:qs(),filterSubscribeType:It.FilterSubscribeType.UNSUBSCRIBE,pubsubTopic:e,contentTopics:t})}static createUnsubscribeAllRequest(e){return new zs({requestId:qs(),filterSubscribeType:It.FilterSubscribeType.UNSUBSCRIBE_ALL,pubsubTopic:e,contentTopics:[]})}static createSubscriberPingRequest(){return new zs({requestId:qs(),filterSubscribeType:It.FilterSubscribeType.SUBSCRIBER_PING,pubsubTopic:"",contentTopics:[]})}static decode(e){const t=It.decode(e);return new zs(t)}encode(){return It.encode(this.proto)}get filterSubscribeType(){return this.proto.filterSubscribeType}get requestId(){return this.proto.requestId}get pubsubTopic(){return this.proto.pubsubTopic}get contentTopics(){return this.proto.contentTopics}}class Ks{proto;constructor(e){this.proto=e}static decode(e){const t=xt.decode(e);return new Ks(t)}encode(){return xt.encode(this.proto)}get statusCode(){return this.proto.statusCode}get statusDesc(){return this.proto.statusDesc}get requestId(){return this.proto.requestId}}const Vs=new Kn("filter:v2"),Hs="/vac/waku/filter-subscribe/2.0.0-beta1",js="/vac/waku/filter-push/2.0.0-beta1";class Gs extends Ms{handleIncomingMessage;pubsubTopics;constructor(e,t,r){super(Hs,r.components,t),this.handleIncomingMessage=e,this.pubsubTopics=t,r.handle(js,this.onRequest.bind(this),{maxInboundStreams:100}).catch((e=>{Vs.error("Failed to register ",js,e)}))}async subscribe(e,t,r){const n=await this.getStream(t),s=zs.createSubscribeRequest(e,r);let o;try{o=await Is([s.encode()],is,n,ps,(async e=>await Yn(e)))}catch(e){return Vs.error("Failed to send subscribe request",e),{success:null,failure:{error:cn.GENERIC_FAIL,peerId:t}}}const{statusCode:i,requestId:a,statusDesc:c}=Ks.decode(o[0].slice());return i<200||i>=300?(Vs.error(`Filter subscribe request ${a} failed with status code ${i}: ${c}`),{failure:{error:cn.REMOTE_PEER_REJECTED,peerId:t},success:null}):{failure:null,success:t}}async unsubscribe(e,t,r){let n;try{n=await this.getStream(t)}catch(e){return Vs.error("Failed to get a stream for remote peer"+t.toString(),e),{success:null,failure:{error:cn.NO_STREAM_AVAILABLE,peerId:t}}}const s=zs.createUnsubscribeRequest(e,r);try{await Is([s.encode()],is,n.sink)}catch(e){return Vs.error("Failed to send unsubscribe request",e),{success:null,failure:{error:cn.GENERIC_FAIL,peerId:t}}}return{success:t,failure:null}}async unsubscribeAll(e,t){const r=await this.getStream(t),n=zs.createUnsubscribeAllRequest(e),s=await Is([n.encode()],is,r,ps,(async e=>await Yn(e)));if(!s||!s.length)return{failure:{error:cn.NO_RESPONSE,peerId:t},success:null};const{statusCode:o,requestId:i,statusDesc:a}=Ks.decode(s[0].slice());return o<200||o>=300?(Vs.error(`Filter unsubscribe all request ${i} failed with status code ${o}: ${a}`),{failure:{error:cn.REMOTE_PEER_REJECTED,peerId:t},success:null}):{failure:null,success:t}}async ping(e){let t;try{t=await this.getStream(e)}catch(t){return Vs.error("Failed to get a stream for remote peer"+e.toString(),t),{success:null,failure:{error:cn.NO_STREAM_AVAILABLE,peerId:e}}}const r=zs.createSubscriberPingRequest();let n;try{n=await Is([r.encode()],is,t,ps,(async e=>await Yn(e)))}catch(t){return Vs.error("Failed to send ping request",t),{success:null,failure:{error:cn.GENERIC_FAIL,peerId:e}}}if(!n||!n.length)return{success:null,failure:{error:cn.NO_RESPONSE,peerId:e}};const{statusCode:s,requestId:o,statusDesc:i}=Ks.decode(n[0].slice());return s<200||s>=300?(Vs.error(`Filter ping request ${o} failed with status code ${s}: ${i}`),{success:null,failure:{error:cn.REMOTE_PEER_REJECTED,peerId:e}}):{success:e,failure:null}}onRequest(e){const{connection:t,stream:r}=e,{remotePeer:n}=t;Vs.info("Received message from "+n.toString());try{Is(r,ps,(async e=>{for await(const r of e){const e=$s.decode(r.slice()),{pubsubTopic:n,wakuMessage:s}=e;if(!s)return void Vs.error("Received empty message");if(!n)return void Vs.error("Pubsub topic missing from push message");await this.handleIncomingMessage(n,s,t.remotePeer.toString())}})).then((()=>{Vs.info("Receiving pipe closed.")}),(async e=>{Vs.error(`Error with receiving pipe on peer:${t.remotePeer.toString()} -- stream:${r.id} -- protocol:${r.protocol}: `,e)}))}catch(e){Vs.error("Error decoding message",e)}}}class Ws{proto;constructor(e){this.proto=e}static createRequest(e,t){return new Ws({requestId:qs(),request:{message:e,pubsubTopic:t},response:void 0})}static decode(e){const t=Lt.decode(e);return new Ws(t)}encode(){return Lt.encode(this.proto)}get query(){return this.proto.request}get response(){return this.proto.response}}const Xs=new Kn("light-push"),Zs="/vac/waku/lightpush/2.0.0-beta1";class Ys extends Ms{pubsubTopics;constructor(e,t){super(Zs,t.components,e),this.pubsubTopics=e}async preparePushMessage(e,t){try{if(!t.payload||0===t.payload.length)return Xs.error("Failed to send waku light push: payload is empty"),{query:null,error:cn.EMPTY_PAYLOAD};if(!await async function(e,t){const r=await e.toWire(t);return!!r&&rr(r)}(e,t))return Xs.error("Failed to send waku light push: message is bigger than 1MB"),{query:null,error:cn.SIZE_TOO_BIG};const r=await e.toProtoObj(t);if(!r)return Xs.error("Failed to encode to protoMessage, aborting push"),{query:null,error:cn.ENCODE_FAILED};return{query:Ws.createRequest(r,e.pubsubTopic),error:null}}catch(e){return Xs.error("Failed to prepare push message",e),{query:null,error:cn.GENERIC_FAIL}}}async send(e,t,r){const{query:n,error:s}=await this.preparePushMessage(e,t);if(s||!n)return{success:null,failure:{error:s,peerId:r}};let o,i;try{o=await this.getStream(r)}catch(e){return Xs.error("Failed to get stream",e),{success:null,failure:{error:cn.NO_STREAM_AVAILABLE,peerId:r}}}try{i=await Is([n.encode()],is,o,ps,(async e=>await Yn(e)))}catch(e){return Xs.error("Failed to send waku light push request",e),{success:null,failure:{error:cn.STREAM_ABORTED,peerId:r}}}const a=new ns;let c;i.forEach((e=>{a.append(e)}));try{c=Ws.decode(a).response}catch(e){return Xs.error("Failed to decode push reply",e),{success:null,failure:{error:cn.DECODE_FAILED,peerId:r}}}return c?(l=c.info)&&(l.includes("could not generate rln proof")||l.includes("could not get new message id to generate an rln proof")||l.includes("RLN validation failed"))?(Xs.error("Remote peer fault: RLN generation"),{success:null,failure:{error:cn.RLN_PROOF_GENERATION,peerId:r}}):c.isSuccess?{success:r,failure:null}:(Xs.error("Remote peer rejected the message: ",c.info),{success:null,failure:{error:cn.REMOTE_PEER_REJECTED,peerId:r}}):(Xs.error("Remote peer fault: No response in PushRPC"),{success:null,failure:{error:cn.NO_RESPONSE,peerId:r}});var l}}const Qs={payload:new Uint8Array,contentTopic:"",version:void 0,timestamp:void 0,meta:void 0,rateLimitProof:void 0,ephemeral:void 0};const Js=1e6;class eo{proto;constructor(e){this.proto=e}static create(e){const t=new eo({...e,requestId:qs(),timeStart:e.timeStart?BigInt(e.timeStart.getTime()*Js):void 0,timeEnd:e.timeEnd?BigInt(e.timeEnd.getTime()*Js):void 0,messageHashes:e.messageHashes||[],paginationLimit:e.paginationLimit?BigInt(e.paginationLimit):void 0});if(e.pubsubTopic&&!e.contentTopics||!e.pubsubTopic&&e.contentTopics)throw Error("Both pubsubTopic and contentTopics must be set or unset");if(e.messageHashes&&(e.pubsubTopic||e.contentTopics||e.timeStart||e.timeEnd))throw Error("Message hash lookup queries cannot include content filter criteria");return t}static decode(e){const t=Ot.decode(e);return new eo(t)}encode(){return Ot.encode(this.proto)}}class to{proto;constructor(e){this.proto=e}static decode(e){const t=Ft.decode(e);return new to(t)}encode(){return Ft.encode(this.proto)}get statusCode(){return this.proto.statusCode}get statusDesc(){return this.proto.statusDesc}get messages(){return this.proto.messages}get paginationCursor(){return this.proto.paginationCursor}}const ro=new Kn("store"),no="/vac/waku/store-query/3.0.0";class so extends Ms{pubsubTopics;constructor(e,t){super(no,t.components,e),this.pubsubTopics=e}async*queryPerPage(e,t,r){if(e.contentTopics.toString()!==Array.from(t.keys()).toString())throw Error("Internal error, the decoders should match the query's content topics");let n=e.paginationCursor;for(;;){const s=eo.create({...e,paginationCursor:n});let o;try{o=await this.getStream(r)}catch(e){ro.error("Failed to get stream",e);break}const i=await Is([s.encode()],is,o,ps,(async e=>await Yn(e))),a=new ns;i.forEach((e=>{a.append(e)}));const c=to.decode(a);if(!c.statusCode||c.statusCode>=300){const e=`Store query failed with status code: ${c.statusCode}, description: ${c.statusDesc}`;throw ro.error(e),Error(e)}if(!c.messages||!c.messages.length){ro.warn("Stopping pagination due to empty messages in response");break}ro.info(c.messages.length+" messages retrieved from store");const l=c.messages.map((e=>{if(!e.message)return Promise.resolve(void 0);const r=e.message.contentTopic;if(r){const s=t.get(r);if(s)return s.fromProtoObj(e.pubsubTopic||"",(n=e.message,{...Qs,...n}))}var n;return Promise.resolve(void 0)}));if(yield l,n=e.paginationForward?c.messages[c.messages.length-1].messageHash:c.messages[0].messageHash,c.messages.length>100&&c.messages.length<(e.paginationLimit||20))break}}}const oo=Symbol.for("@libp2p/connection"),io=Symbol.for("@libp2p/content-routing"),ao=Symbol.for("@libp2p/peer-discovery"),co=Symbol.for("@libp2p/peer-id");function lo(e){return!!e?.[co]}const uo=Symbol.for("@libp2p/peer-routing"),ho="keep-alive",po=Symbol.for("@libp2p/transport");var fo;(e=>{e[e.FATAL_ALL=0]="FATAL_ALL",e[e.NO_FATAL=1]="NO_FATAL"})(fo||(fo={}));let go=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}};class mo extends Error{static name="UnexpectedPeerError";constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}let yo=class extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}};class bo extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}class wo extends Error{static name="ConnectionClosingError";constructor(e="The connection is closing"){super(e),this.name="ConnectionClosingError"}}class vo extends Error{static name="ConnectionClosedError";constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}class Eo extends Error{static name="ConnectionFailedError";constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}class So extends Error{static name="MuxerClosedError";constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}class Ao extends Error{static name="StreamResetError";constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}class Co extends Error{static name="StreamStateError";constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}let Io=class extends Error{static name="NotFoundError";constructor(e="Not found"){super(e),this.name="NotFoundError"}};class xo extends Error{static name="InvalidPeerIdError";constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}let ko=class extends Error{static name="InvalidMultiaddrError";constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}};class Po extends Error{static name="InvalidCIDError";constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}class To extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}class _o extends Error{static name="UnsupportedProtocolError";constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}class Ro extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}class Lo extends Error{static name="ProtocolError";constructor(e="Protocol error"){super(e),this.name="ProtocolError"}}let Do=class extends Error{static name="TimeoutError";constructor(e="Timed out"){super(e),this.name="TimeoutError"}};class No extends Error{static name="NotStartedError";constructor(e="Not started"){super(e),this.name="NotStartedError"}}class Mo extends Error{static name="DialError";constructor(e="Dial error"){super(e),this.name="DialError"}}class Oo extends Error{static name="LimitedConnectionError";constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}class Fo extends Error{static name="TooManyInboundProtocolStreamsError";constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}class Uo extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}class Bo extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}class qo extends EventTarget{#e=new Map;constructor(){super()}listenerCount(e){const t=this.#e.get(e);return null==t?0:t.length}addEventListener(e,t,r){super.addEventListener(e,t,r);let n=this.#e.get(e);null==n&&(n=[],this.#e.set(e,n)),n.push({callback:t,once:(!0!==r&&!1!==r&&r?.once)??!1})}removeEventListener(e,t,r){super.removeEventListener(e.toString(),t??null,r);let n=this.#e.get(e);null!=n&&(n=n.filter((({callback:e})=>e!==t)),this.#e.set(e,n))}dispatchEvent(e){const t=super.dispatchEvent(e);let r=this.#e.get(e.type);return null==r||(r=r.filter((({once:e})=>!e)),this.#e.set(e.type,r)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}}function $o(e){return null!=e&&"function"==typeof e.start&&"function"==typeof e.stop}const zo=Symbol.for("@libp2p/service-capabilities"),Ko=Symbol.for("@libp2p/service-dependencies");class Vo extends Error{static name="InvalidMultiaddrError";name="InvalidMultiaddrError"}class Ho extends Error{static name="ValidationError";name="ValidationError"}class jo extends Error{static name="InvalidParametersError";name="InvalidParametersError"}class Go extends Error{static name="UnknownProtocolError";name="UnknownProtocolError"}const Wo=new class{index=0;input="";new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,r=e();return void 0===r&&(this.index=t),r}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically((()=>{const t=this.readChar();if(t===e)return t}))}readSeparator(e,t,r){return this.readAtomically((()=>{if(!(t>0&&void 0===this.readGivenChar(e)))return r()}))}readNumber(e,t,r,n){return this.readAtomically((()=>{let s=0,o=0;const i=this.peekChar();if(void 0===i)return;const a="0"===i,c=2**(8*n)-1;for(;;){const r=this.readAtomically((()=>{const t=this.readChar();if(void 0===t)return;const r=Number.parseInt(t,e);return Number.isNaN(r)?void 0:r}));if(void 0===r)break;if(s*=e,s+=r,s>c)return;if(o+=1,void 0!==t&&o>t)return}return 0===o||!r&&a&&o>1?void 0:s}))}readIPv4Addr(){return this.readAtomically((()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const r=this.readSeparator(".",t,(()=>this.readNumber(10,3,!1,1)));if(void 0===r)return;e[t]=r}return e}))}readIPv6Addr(){const e=e=>{for(let t=0;t<e.length/2;t++){const r=2*t;if(t<e.length-3){const n=this.readSeparator(":",t,(()=>this.readIPv4Addr()));if(void 0!==n)return e[r]=n[0],e[r+1]=n[1],e[r+2]=n[2],e[r+3]=n[3],[r+4,!0]}const n=this.readSeparator(":",t,(()=>this.readNumber(16,4,!0,2)));if(void 0===n)return[r,!1];e[r]=n>>8,e[r+1]=255&n}return[e.length,!1]};return this.readAtomically((()=>{const t=new Uint8Array(16),[r,n]=e(t);if(16===r)return t;if(n)return;if(void 0===this.readGivenChar(":"))return;if(void 0===this.readGivenChar(":"))return;const s=new Uint8Array(14),o=16-(r+2),[i]=e(s.subarray(0,o));return t.set(s.subarray(0,i),16-i),t}))}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}};function Xo(e){if(!(e.length>15))return Wo.new(e).parseWith((()=>Wo.readIPv4Addr()))}function Zo(e){if(e.includes("%")&&(e=e.split("%")[0]),!(e.length>45))return Wo.new(e).parseWith((()=>Wo.readIPv6Addr()))}function Yo(e,t=!1){if(e.includes("%")&&(e=e.split("%")[0]),e.length>45)return;const r=Wo.new(e).parseWith((()=>Wo.readIPAddr()));return r?t&&4===r.length?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,r[0],r[1],r[2],r[3]]):r:void 0}function Qo(e){return!!Xo(e)}function Jo(e){return!!Zo(e)}const ei=41;function ti(e){return t=>mn(t,e)}function ri(e){return t=>tt(t,e)}function ni(e){return new DataView(e.buffer).getUint16(e.byteOffset).toString()}function si(e){const t=new ArrayBuffer(2);return new DataView(t).setUint16(0,"string"==typeof e?parseInt(e):e),new Uint8Array(t)}function oi(e){const t=e.subarray(0,e.length-2),r=e.subarray(e.length-2);return`${mn(t,"base32")}:${ni(r)}`}const ii=e=>{e=e.toString().trim();const t=new Uint8Array(4);return e.split(/\./g).forEach(((e,r)=>{const n=parseInt(e,10);if(isNaN(n)||n<0||n>255)throw new Vo("Invalid byte value in IP address");t[r]=n})),t};const ai=Object.values(Ze).map((e=>e.decoder)),ci=(()=>{let e=ai[0].or(ai[1]);return ai.slice(2).forEach((t=>e=e.or(t))),e})();const li=function(...e){return t=>{for(const r of e)r(t)}}((function(e){if(parseInt(e).toString()!==e)throw new Ho("Value must be an integer")}),(function(e){if(e<0)throw new Ho("Value must be a positive integer, or zero")}),(ui=65535,e=>{if(e>ui)throw new Ho("Value must be smaller than or equal to "+ui)}));var ui;const hi=-1;const di=new class{protocolsByCode=new Map;protocolsByName=new Map;getProtocol(e){let t;if(t="string"==typeof e?this.protocolsByName.get(e):this.protocolsByCode.get(e),null==t)throw new Go(`Protocol ${e} was unknown`);return t}addProtocol(e){this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),e.aliases?.forEach((t=>{this.protocolsByName.set(t,e)}))}removeProtocol(e){const t=this.protocolsByCode.get(e);null!=t&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),t.aliases?.forEach((e=>{this.protocolsByName.delete(e)})))}},pi=[{code:4,name:"ip4",size:32,valueToBytes:ii,bytesToValue(e){if(4!==e.byteLength)throw new Vo("IPv4 address was incorrect length");const t=[];for(let r=0;r<e.byteLength;r++)t.push(e[r]);return t.join(".")},validate(e){if(!Qo(e))throw new Ho(`Invalid IPv4 address "${e}"`)}},{code:6,name:"tcp",size:16,valueToBytes:si,bytesToValue:ni,validate:li},{code:273,name:"udp",size:16,valueToBytes:si,bytesToValue:ni,validate:li},{code:33,name:"dccp",size:16,valueToBytes:si,bytesToValue:ni,validate:li},{code:ei,name:"ip6",size:128,valueToBytes(e){let t=0;const r=(e=e.toString().trim()).split(":",8);let n;for(n=0;n<r.length;n++){let e;Qo(r[n])&&(e=ii(r[n]),r[n]=mn(e.subarray(0,2),"base16")),null!=e&&++n<8&&r.splice(n,0,mn(e.subarray(2,4),"base16"))}if(""===r[0])for(;r.length<8;)r.unshift("0");else if(""===r[r.length-1])for(;r.length<8;)r.push("0");else if(r.length<8){for(n=0;n<r.length&&""!==r[n];n++);const e=[n,1];for(n=9-r.length;n>0;n--)e.push("0");r.splice.apply(r,e)}const s=new Uint8Array(t+16);for(n=0;n<r.length;n++){""===r[n]&&(r[n]="0");const e=parseInt(r[n],16);if(isNaN(e)||e<0||e>65535)throw new Vo("Invalid byte value in IP address");s[t++]=e>>8&255,s[t++]=255&e}return s},bytesToValue(e){if(16!==e.byteLength)throw new Vo("IPv6 address was incorrect length");const t=[];for(let r=0;r<e.byteLength;r+=2){const n=e[r],s=e[r+1],o=`${n.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;t.push(o)}const r=t.join(":");try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new Vo(`Invalid IPv6 address "${r}"`)}},stringToValue(e){try{const t=new URL(`http://[${e}]`);return t.hostname.substring(1,t.hostname.length-1)}catch{throw new Vo(`Invalid IPv6 address "${e}"`)}},validate(e){if(!Jo(e))throw new Ho(`Invalid IPv6 address "${e}"`)}},{code:42,name:"ip6zone",size:hi},{code:43,name:"ipcidr",size:8,bytesToValue:ti("base10"),valueToBytes:ri("base10")},{code:53,name:"dns",size:hi,resolvable:!0},{code:54,name:"dns4",size:hi,resolvable:!0},{code:55,name:"dns6",size:hi,resolvable:!0},{code:56,name:"dnsaddr",size:hi,resolvable:!0},{code:132,name:"sctp",size:16,valueToBytes:si,bytesToValue:ni,validate:li},{code:301,name:"udt"},{code:302,name:"utp"},{code:400,name:"unix",size:hi,path:!0,stringToValue(e){return decodeURIComponent(e)},valueToString(e){return encodeURIComponent(e)}},{code:421,name:"p2p",aliases:["ipfs"],size:hi,bytesToValue:ti("base58btc"),valueToBytes(e){return e.startsWith("Q")||e.startsWith("1")?ri("base58btc")(e):He.parse(e).multihash.bytes}},{code:444,name:"onion",size:96,bytesToValue:oi,valueToBytes(e){const t=e.split(":");if(2!==t.length)throw Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(16!==t[0].length)throw Error(`failed to parse onion addr: ${t[0]} not a Tor onion address.`);const r=tt(t[0],"base32"),n=parseInt(t[1],10);if(n<1||n>65536)throw Error("Port number is not in range(1, 65536)");const s=si(n);return Qn([r,s],r.length+s.length)}},{code:445,name:"onion3",size:296,bytesToValue:oi,valueToBytes(e){const t=e.split(":");if(2!==t.length)throw Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(56!==t[0].length)throw Error(`failed to parse onion addr: ${t[0]} not a Tor onion3 address.`);const r=Q.decode("b"+t[0]),n=parseInt(t[1],10);if(n<1||n>65536)throw Error("Port number is not in range(1, 65536)");const s=si(n);return Qn([r,s],r.length+s.length)}},{code:446,name:"garlic64",size:hi},{code:447,name:"garlic32",size:hi},{code:448,name:"tls"},{code:449,name:"sni",size:hi},{code:454,name:"noise"},{code:460,name:"quic"},{code:461,name:"quic-v1"},{code:465,name:"webtransport"},{code:466,name:"certhash",size:hi,bytesToValue:function(e){return t=>e.encoder.encode(t)}(me),valueToBytes(e){return ci.decode(e)}},{code:480,name:"http"},{code:481,name:"http-path",size:hi,stringToValue(e){return"/"+decodeURIComponent(e)},valueToString(e){return encodeURIComponent(e.substring(1))}},{code:443,name:"https"},{code:477,name:"ws"},{code:478,name:"wss"},{code:479,name:"p2p-websocket-star"},{code:277,name:"p2p-stardust"},{code:275,name:"p2p-webrtc-star"},{code:276,name:"p2p-webrtc-direct"},{code:280,name:"webrtc-direct"},{code:281,name:"webrtc"},{code:290,name:"p2p-circuit"},{code:777,name:"memory",size:hi}];function fi(e,t,r){return null==e.size||0===e.size?0:e.size>0?e.size/8:d(t,r)}pi.forEach((e=>{di.addProtocol(e)}));const gi=Symbol.for("nodejs.util.inspect.custom"),mi=Symbol.for("@multiformats/multiaddr"),yi=[53,54,55,56];class bi extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}function wi(e){if(null==e&&(e="/"),_i(e))return e.getComponents();if(e instanceof Uint8Array)return function(e){const t=[];let r=0;for(;r<e.length;){const n=d(e,r),s=di.getProtocol(n),o=c(n),i=fi(s,e,r+o);let a=0;i>0&&s.size===hi&&(a=c(i));const l=o+a+i,u={code:n,name:s.name,bytes:e.subarray(r,r+l)};if(i>0){const t=r+o+a,n=e.subarray(t,t+i);u.value=s.bytesToValue?.(n)??mn(n)}t.push(u),r+=l}return t}(e);if("string"==typeof e)return""===(e=e.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""))&&(e="/"),function(e){if("/"!==e.charAt(0))throw new Vo('String multiaddr must start with "/"');const t=[];let r="protocol",n="",s="";for(let o=1;o<e.length;o++){const i=e.charAt(o);"/"!==i&&("protocol"===r?s+=e.charAt(o):n+=e.charAt(o));const a=o===e.length-1;if("/"===i||a){const e=di.getProtocol(s);if("protocol"===r){if(null==e.size||0===e.size){t.push({code:e.code,name:e.name}),n="",s="",r="protocol";continue}if(a)throw new Vo(`Component ${s} was missing value`);r="value"}else if("value"===r){const o={code:e.code,name:e.name};if(null!=e.size&&0!==e.size){if(""===n)throw new Vo(`Component ${s} was missing value`);o.value=e.stringToValue?.(n)??n}t.push(o),n="",s="",r="protocol"}}}if(""!==s&&""!==n)throw new Vo("Incomplete multiaddr");return t}(e);if(Array.isArray(e))return e;throw new Vo("Must be a string, Uint8Array, Component[], or another Multiaddr")}class vi{[mi]=!0;#t;#r;#n;constructor(e="/",t={}){this.#t=wi(e),!1!==t.validate&&function(e){e.getComponents().forEach((e=>{const t=di.getProtocol(e.code);null!=e.value&&t.validate?.(e.value)}))}(this)}get bytes(){return null==this.#n&&(this.#n=function(e){let t=0;const r=[];for(const n of e){if(null==n.bytes){const e=di.getProtocol(n.code),t=c(n.code);let r,s=0,o=0;null!=n.value&&(r=e.valueToBytes?.(n.value)??tt(n.value),s=r.byteLength,e.size===hi&&(o=c(s)));const i=new Uint8Array(t+o+s);let a=0;l(n.code,i,a),a+=t,null!=r&&(e.size===hi&&(l(s,i,a),a+=o),i.set(r,a)),n.bytes=i}r.push(n.bytes),t+=n.bytes.byteLength}return Qn(r,t)}(this.#t)),this.#n}toString(){return null==this.#r&&(this.#r="/"+this.#t.flatMap((e=>{if(null==e.value)return e.name;const t=di.getProtocol(e.code);if(null==t)throw new Vo("Unknown protocol code "+e.code);return[e.name,t.valueToString?.(e.value)??e.value]})).join("/")),this.#r}toJSON(){return this.toString()}toOptions(){let e,t,r,n,s="";for(const{code:o,name:i,value:a}of this.#t)42===o&&(s="%"+(a??"")),yi.includes(o)&&(t="tcp",n=443,r=`${a??""}${s}`,e=55===o?6:4),6!==o&&273!==o||(t="tcp"===i?"tcp":"udp",n=parseInt(a??"")),4!==o&&o!==ei||(t="tcp",r=`${a??""}${s}`,e=o===ei?6:4);if(null==e||null==t||null==r||null==n)throw Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:r,transport:t,port:n}}getComponents(){return[...this.#t]}protos(){return this.#t.map((({code:e,value:t})=>{const r=di.getProtocol(e);return{code:e,size:r.size??0,name:r.name,resolvable:!!r.resolvable,path:!!r.path}}))}protoCodes(){return this.#t.map((({code:e})=>e))}protoNames(){return this.#t.map((({name:e})=>e))}tuples(){return this.#t.map((({code:e,value:t})=>{if(null==t)return[e];const r=di.getProtocol(e),n=[e];return null!=t&&n.push(r.valueToBytes?.(t)??tt(t)),n}))}stringTuples(){return this.#t.map((({code:e,value:t})=>null==t?[e]:[e,t]))}encapsulate(e){const t=new vi(e);return new vi([...this.#t,...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),r=this.toString(),n=r.lastIndexOf(t);if(n<0)throw new jo(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new vi(r.slice(0,n),{validate:!1})}decapsulateCode(e){let t;for(let r=this.#t.length-1;r>-1;r--)if(this.#t[r].code===e){t=r;break}return new vi(this.#t.slice(0,t),{validate:!1})}getPeerId(){try{let e=[];this.#t.forEach((({code:t,value:r})=>{421===t&&e.push([t,r]),290===t&&(e=[])}));const t=e.pop();if(null!=t?.[1]){const e=t[1];return"Q"===e[0]||"1"===e[0]?mn(he.decode("z"+e),"base58btc"):mn(He.parse(e).multihash.bytes,"base58btc")}return null}catch(e){return null}}getPath(){for(const e of this.#t){if(di.getProtocol(e.code).path)return e.value??null}return null}equals(e){return Jn(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find((e=>e.resolvable));if(null==t)return[this];const r=Ti.get(t.name);if(null==r)throw new bi("no available resolver for "+t.name);return(await r(this,e)).map((e=>Ri(e)))}nodeAddress(){const e=this.toOptions();if("tcp"!==e.transport&&"udp"!==e.transport)throw Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(){return 2===this.#t.length&&((4===this.#t[0].code||this.#t[0].code===ei)&&(6===this.#t[1].code||273===this.#t[1].code))}[gi](){return`Multiaddr(${this.toString()})`}}const Ei=4,Si=16,Ai=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function Ci(e,t){t.length===Si&&e.length===Ei&&function(e,t,r){let n=0;for(const s of e)if(!(n<t)){if(n>r)break;if(255!==s)return!1;n++}return!0}(t,0,11)&&(t=t.slice(12)),t.length===Ei&&e.length===Si&&function(e,t,r,n){let s=0;for(const o of e)if(!(s<r)){if(s>n)break;if(o!==t[s])return!1;s++}return!0}(e,Ai,0,11)&&(e=e.slice(12));const r=e.length;if(r!=t.length)throw Error("Failed to mask ip");const n=new Uint8Array(r);for(let s=0;s<r;s++)n[s]=e[s]&t[s];return n}function Ii(e,t){if(t!==8*Ei&&t!==8*Si)throw Error("Invalid CIDR mask");if(e<0||e>t)throw Error("Invalid CIDR mask");const r=t/8,n=new Uint8Array(r);for(let t=0;t<r;t++)e>=8?(n[t]=255,e-=8):(n[t]=255-(255>>e),e=0);return n}class xi{constructor(e,t){if(null==t)({network:this.network,mask:this.mask}=function(e){const[t,r]=e.split("/");if(!t||!r)throw Error("Failed to parse given CIDR: "+e);let n=Ei,s=Xo(t);if(null==s&&(n=Si,s=Zo(t),null==s))throw Error("Failed to parse given CIDR: "+e);const o=parseInt(r,10);if(Number.isNaN(o)||(o+"").length!==r.length||o<0||o>8*n)throw Error("Failed to parse given CIDR: "+e);const i=Ii(o,8*n);return{network:Ci(s,i),mask:i}}(e));else{const r=Yo(e);if(null==r)throw Error("Failed to parse network");const n=parseInt(t+="",10);if(Number.isNaN(n)||(n+"").length!==t.length||n<0||n>8*r.length){const e=Yo(t);if(null==e)throw Error("Failed to parse mask");this.mask=e}else this.mask=Ii(n,8*r.length);this.network=Ci(r,this.mask)}}contains(e){return function(e,t){if("string"==typeof t&&(t=Yo(t)),null==t)throw Error("Invalid ip");if(t.length!==e.network.length)return!1;for(let r=0;r<t.length;r++)if((e.network[r]&e.mask[r])!=(t[r]&e.mask[r]))return!1;return!0}({network:this.network,mask:this.mask},e)}toString(){const e=function(e){let t=0;for(let[r,n]of e.entries()){if(255!==n){for(;128&n;)t++,n<<=1;if(128&n)return-1;for(let t=r+1;t<e.length;t++)if(0!=e[t])return-1;break}t+=8}return t}(this.mask),t=-1!==e?e+"":function(e){let t="0x";for(const r of e)t+=(r>>4).toString(16)+(15&r).toString(16);return t}(this.mask);return function(e){switch(e.length){case Ei:return e.join(".");case Si:{const t=[];for(let r=0;r<e.length;r++)r%2==0&&t.push(e[r].toString(16).padStart(2,"0")+e[r+1].toString(16).padStart(2,"0"));return t.join(":")}default:throw Error("Invalid ip length")}}(this.network)+"/"+t}}function ki(e,t){const r=di.getProtocol(e);return r.bytesToValue?.(t)??mn(t,"base16")}function Pi(e,t){const r=di.getProtocol(e);return r.valueToBytes?.(t)??tt(t,"base16")}const Ti=new Map;function _i(e){return!!e?.[mi]}function Ri(e){return new vi(e)}const Li=new Kn("keep-alive");class Di{relay;libp2p;options;pingKeepAliveTimers=new Map;relayKeepAliveTimers=new Map;constructor({options:e,relay:t,libp2p:r}){this.options=e,this.relay=t,this.libp2p=r}start(e){this.stop(e);const{pingKeepAlive:t,relayKeepAlive:r}=this.options,n=e.toString();if(0!==t){const r=setInterval((()=>{(async()=>{let r;try{try{r=await this.libp2p.services.ping.ping(e),Li.info(`Ping succeeded (${n})`,r)}catch(e){return void Li.error(`Ping failed for peer (${n}).\n                Next ping will be attempted in ${t} seconds.\n              `)}try{await this.libp2p.peerStore.merge(e,{metadata:{ping:vn(r.toString())}})}catch(e){Li.error("Failed to update ping",e)}}catch(e){Li.error(`Ping failed (${n})`,e)}})()}),1e3*t);this.pingKeepAliveTimers.set(n,r)}const s=this.relay;if(s&&0!==r){const t=this.scheduleRelayPings(s,r,e.toString());this.relayKeepAliveTimers.set(e,t)}}stop(e){const t=e.toString();this.pingKeepAliveTimers.has(t)&&(clearInterval(this.pingKeepAliveTimers.get(t)),this.pingKeepAliveTimers.delete(t)),this.relayKeepAliveTimers.has(e)&&(this.relayKeepAliveTimers.get(e)?.map(clearInterval),this.relayKeepAliveTimers.delete(e))}stopAll(){for(const e of[...Object.values(this.pingKeepAliveTimers),...Object.values(this.relayKeepAliveTimers)])clearInterval(e);this.pingKeepAliveTimers.clear(),this.relayKeepAliveTimers.clear()}connectionsExist(){return this.pingKeepAliveTimers.size>0||this.relayKeepAliveTimers.size>0}scheduleRelayPings(e,t,r){const n=[];for(const s of e.pubsubTopics){if(!e.getMeshPeers(s).includes(r))continue;const o=Wn({pubsubTopicShardInfo:An(s),contentTopic:"/relay-ping/1/ping/null",ephemeral:!0}),i=setInterval((()=>{Li.info("Sending Waku Relay ping message"),e.send(o,{payload:new Uint8Array([1])}).catch((e=>Li.error("Failed to send relay ping",e)))}),1e3*t);n.push(i)}return n}}const Ni=e=>{if(!e)return-1;try{const t=e.metadata.get("ping");return t?Number(wn(t)):-1}catch(e){return-1}},Mi=new Kn("connection-manager");class Oi extends qo{pubsubTopics;keepAliveManager;options;libp2p;dialAttemptsForPeer=new Map;dialErrorsForPeer=new Map;currentActiveParallelDialCount=0;pendingPeerDialQueue=[];isP2PNetworkConnected=!1;isConnected(){return!(globalThis?.navigator&&!globalThis?.navigator?.onLine)&&this.isP2PNetworkConnected}stop(){this.keepAliveManager.stopAll(),this.libp2p.removeEventListener("peer:connect",this.onEventHandlers["peer:connect"]),this.libp2p.removeEventListener("peer:disconnect",this.onEventHandlers["peer:disconnect"]),this.libp2p.removeEventListener("peer:discovery",this.onEventHandlers["peer:discovery"]),this.stopNetworkStatusListener()}async dropConnection(e){try{this.keepAliveManager.stop(e),await this.libp2p.hangUp(e),Mi.info("Dropped connection with peer "+e.toString())}catch(t){Mi.error(`Error dropping connection with peer ${e.toString()} - ${t}`)}}async getPeersByDiscovery(){const e=await this.libp2p.peerStore.all(),t=this.libp2p.getConnections().map((e=>e.remotePeer)),r=[],n=[],s=[],o=[],i=[],a=[];for(const t of e){const e=await this.getTagNamesForPeer(t.id);e.includes(ln.BOOTSTRAP)?r.push(t):e.includes(ln.PEER_EXCHANGE)?n.push(t):e.includes(ln.LOCAL)&&s.push(t)}for(const e of t){const t=await this.libp2p.peerStore.get(e),r=await this.getTagNamesForPeer(e);r.includes(ln.BOOTSTRAP)?o.push(t):r.includes(ln.PEER_EXCHANGE)?i.push(t):r.includes(ln.LOCAL)&&a.push(t)}return{DISCOVERED:{[ln.BOOTSTRAP]:r,[ln.PEER_EXCHANGE]:n,[ln.LOCAL]:s},CONNECTED:{[ln.BOOTSTRAP]:o,[ln.PEER_EXCHANGE]:i,[ln.LOCAL]:a}}}constructor(e){super(),this.libp2p=e.libp2p,this.pubsubTopics=e.pubsubTopics,this.options={maxDialAttemptsForPeer:3,maxBootstrapPeersAllowed:1,maxParallelDials:3,pingKeepAlive:300,relayKeepAlive:300,...e.config},this.keepAliveManager=new Di({relay:e.relay,libp2p:e.libp2p,options:{pingKeepAlive:this.options.pingKeepAlive,relayKeepAlive:this.options.relayKeepAlive}}),this.startEventListeners().then((()=>Mi.info("Connection Manager is now running"))).catch((e=>Mi.error("Unexpected error while running service",e))),this.dialPeerStorePeers().catch((e=>Mi.error("Unexpected error while dialing peer store peers",e)))}async getConnectedPeers(e){const t=this.libp2p.getPeers();if(0===t.length)return[];return(await Promise.all(t.map((async e=>{try{return await this.libp2p.peerStore.get(e)}catch(e){return null}})))).filter((e=>!!e)).filter((t=>!e||t.protocols.includes(e))).sort(((e,t)=>Ni(e)-Ni(t)))}async dialPeerStorePeers(){const e=await this.libp2p.peerStore.all(),t=[];for(const r of e)this.libp2p.getConnections().find((e=>e.remotePeer===r.id))||t.push(this.attemptDial(r.id));try{await Promise.all(t)}catch(e){Mi.error("Unexpected error while dialing peer store peers",e)}}async startEventListeners(){this.startPeerDiscoveryListener(),this.startPeerConnectionListener(),this.startPeerDisconnectionListener(),this.startNetworkStatusListener()}async dialPeer(e){let t,r;const n=this.getDialablePeerInfo(e),s=lo(n)?n.toString():n.getPeerId();this.currentActiveParallelDialCount+=1;let o=0;for(;o<this.options.maxDialAttemptsForPeer;)try{Mi.info(`Dialing peer ${n} on attempt ${o+1}`),t=await this.libp2p.dial(n),r=t.remotePeer;const e=await this.getTagNamesForPeer(r);this.libp2p.getConnections(r).forEach((t=>{t.tags=Array.from(new Set([...t.tags,...e]))})),this.dialAttemptsForPeer.set(r.toString(),-1),this.keepAliveManager.start(r);break}catch(e){e instanceof AggregateError?Mi.error(`Error dialing peer ${s} - ${e.errors}`):Mi.error(`Error dialing peer ${s} - ${e.message}`),this.dialErrorsForPeer.set(s,e),o++,this.dialAttemptsForPeer.set(s,o)}if(this.currentActiveParallelDialCount--,this.processDialQueue(),o===this.options.maxDialAttemptsForPeer)try{const e=this.dialErrorsForPeer.get(s);if(e){let t;e instanceof AggregateError?e.errors?0===e.errors.length?Mi.warn("Errors array is empty for AggregateError"):t=JSON.stringify(e.errors[0]):Mi.warn("No errors array found for AggregateError"):t=e.message,Mi.info(`Deleting undialable peer ${s} from peer store. Reason: ${t}`)}this.dialErrorsForPeer.delete(s),r&&await this.libp2p.peerStore.delete(r),await this.attemptDnsDiscovery()}catch(e){throw Error(`Error deleting undialable peer ${s} from peer store - ${e}`)}if(!t)throw Error("Failed to dial peer "+n);return t}async rawDialPeerWithProtocols(e,t){const r=this.getDialablePeerInfo(e);return await this.libp2p.dialProtocol(r,t)}getDialablePeerInfo(e){if(lo(e))return e;{const t=Ri(e);if(!t.getPeerId())throw Error("Failed to dial multiaddr: missing peer ID");return t}}async attemptDnsDiscovery(){if(this.libp2p.getConnections().length>0)return;if((await this.libp2p.peerStore.all()).length>0)return;Mi.info("Attempting to trigger DNS discovery.");const e=Object.values(this.libp2p.components.components).find((e=>!(!e||!e.toString)&&e.toString().includes(dn)));e&&await e.findPeers()}processDialQueue(){if(this.pendingPeerDialQueue.length>0&&this.currentActiveParallelDialCount<this.options.maxParallelDials){const e=this.pendingPeerDialQueue.shift();if(!e)return;this.attemptDial(e).catch((e=>{Mi.error(e)}))}}startPeerDiscoveryListener(){this.libp2p.addEventListener("peer:discovery",this.onEventHandlers["peer:discovery"])}startPeerConnectionListener(){this.libp2p.addEventListener("peer:connect",this.onEventHandlers["peer:connect"])}startPeerDisconnectionListener(){this.libp2p.addEventListener("peer:disconnect",this.onEventHandlers["peer:disconnect"])}async attemptDial(e){await this.shouldDialPeer(e)&&(this.currentActiveParallelDialCount>=this.options.maxParallelDials?this.pendingPeerDialQueue.push(e):await this.dialPeer(e))}onEventHandlers={"peer:discovery":e=>{(async()=>{const{id:t}=e.detail;await this.dispatchDiscoveryEvent(t);try{await this.attemptDial(t)}catch(e){Mi.error(`Error dialing peer ${t.toString()} : ${e}`)}})()},"peer:connect":e=>{(async()=>{Mi.info("Connected to peer "+e.detail.toString());const t=e.detail;this.keepAliveManager.start(t);if((await this.getTagNamesForPeer(t)).includes(ln.BOOTSTRAP)){this.libp2p.getConnections().filter((e=>e.tags.includes(ln.BOOTSTRAP))).length>this.options.maxBootstrapPeersAllowed?await this.dropConnection(t):this.dispatchEvent(new CustomEvent(un.PEER_CONNECT_BOOTSTRAP,{detail:t}))}else this.dispatchEvent(new CustomEvent(un.PEER_CONNECT_PEER_EXCHANGE,{detail:t}));this.setP2PNetworkConnected()})()},"peer:disconnect":e=>{(async()=>{this.keepAliveManager.stop(e.detail),this.setP2PNetworkDisconnected()})()},"browser:network":()=>{this.dispatchWakuConnectionEvent()}};async shouldDialPeer(e){if(this.libp2p.getConnections(e).length>0)return Mi.warn(`Already connected to peer ${e.toString()}. Not dialing.`),!1;if(!await this.isPeerTopicConfigured(e)){const t=await this.getPeerShardInfo(e,this.libp2p.peerStore);return Mi.warn(`Discovered peer ${e.toString()} with ShardInfo ${t} is not part of any of the configured pubsub topics (${this.pubsubTopics}).\n            Not dialing.`),!1}if(!await this.isPeerDialableBasedOnBootstrapStatus(e))return Mi.warn(`Peer ${e.toString()} is not dialable based on bootstrap status. Not dialing.`),!1;return!this.dialAttemptsForPeer.has(e.toString())||(Mi.warn(`Peer ${e.toString()} has already been attempted dial before, or already has a dial attempt in progress, skipping dial`),!1)}async isPeerDialableBasedOnBootstrapStatus(e){if(!(await this.getTagNamesForPeer(e)).some((e=>e===ln.BOOTSTRAP)))return!0;const t=this.libp2p.getConnections().filter((e=>e.tags.find((e=>e===ln.BOOTSTRAP)))).length;return t<this.options.maxBootstrapPeersAllowed}async dispatchDiscoveryEvent(e){const t=(await this.getTagNamesForPeer(e)).includes(ln.BOOTSTRAP);this.dispatchEvent(new CustomEvent(t?un.PEER_DISCOVERY_BOOTSTRAP:un.PEER_DISCOVERY_PEER_EXCHANGE,{detail:e}))}async getTagNamesForPeer(e){try{const t=await this.libp2p.peerStore.get(e);return Array.from(t.tags.keys())}catch(t){return Mi.error(`Failed to get peer ${e}, error: ${t}`),[]}}async isPeerTopicConfigured(e){const t=await this.getPeerShardInfo(e,this.libp2p.peerStore);if(!t)return!0;return Sn(t).some((e=>this.pubsubTopics.includes(e)))}async getPeerShardInfo(e,t){const r=(await t.get(e)).metadata.get("shardInfo");if(r)return Tn(r)}startNetworkStatusListener(){try{globalThis.addEventListener("online",this.onEventHandlers["browser:network"]),globalThis.addEventListener("offline",this.onEventHandlers["browser:network"])}catch(e){Mi.error("Failed to start network listener: "+e)}}stopNetworkStatusListener(){try{globalThis.removeEventListener("online",this.onEventHandlers["browser:network"]),globalThis.removeEventListener("offline",this.onEventHandlers["browser:network"])}catch(e){Mi.error("Failed to stop network listener: "+e)}}setP2PNetworkConnected(){this.isP2PNetworkConnected||(this.isP2PNetworkConnected=!0,this.dispatchWakuConnectionEvent())}setP2PNetworkDisconnected(){this.isP2PNetworkConnected&&0===this.libp2p.getConnections().length&&(this.isP2PNetworkConnected=!1,this.dispatchWakuConnectionEvent())}dispatchWakuConnectionEvent(){this.dispatchEvent(new CustomEvent(hn.CONNECTION_STATUS,{detail:this.isConnected()}))}}const Fi=new Kn("metadata"),Ui="/vac/waku/metadata/1.0.0";class Bi extends Ms{pubsubTopics;libp2pComponents;handshakesConfirmed=new Map;constructor(e,t){super(Ui,t.components,e),this.pubsubTopics=e,this.libp2pComponents=t,t.registrar.handle(Ui,(e=>{this.onRequest(e)}))}async query(e){const t=Vt.encode(Cn(this.pubsubTopics));if(!await this.libp2pComponents.peerStore.get(e))return{shardInfo:null,error:cn.NO_PEER_AVAILABLE};let r;try{r=await this.getStream(e)}catch(s){return Fi.error("Failed to get stream",s),{shardInfo:null,error:cn.NO_STREAM_AVAILABLE}}const n=await Is([t],is,r,ps,(async e=>await Yn(e))),{error:s,shardInfo:o}=this.decodeMetadataResponse(n);return s?{shardInfo:null,error:s}:(await this.savePeerShardInfo(e,o),{shardInfo:o,error:null})}async confirmOrAttemptHandshake(e){const t=this.handshakesConfirmed.get(e.toString());return t?{shardInfo:t,error:null}:await this.query(e)}async onRequest(e){try{const{stream:t,connection:r}=e,n=Ht.encode(Cn(this.pubsubTopics)),s=await Is([n],is,t,ps,(async e=>await Yn(e))),{error:o,shardInfo:i}=this.decodeMetadataResponse(s);if(o)return;await this.savePeerShardInfo(r.remotePeer,i)}catch(e){Fi.error("Error handling metadata request",e)}}decodeMetadataResponse(e){const t=new ns;e.forEach((e=>{t.append(e)}));const r=Ht.decode(t);return r?{shardInfo:r,error:null}:(Fi.error("Error decoding metadata response"),{shardInfo:null,error:cn.DECODE_FAILED})}async savePeerShardInfo(e,t){await this.libp2pComponents.peerStore.merge(e,{metadata:{shardInfo:_n(t)}}),this.handshakesConfirmed.set(e.toString(),t)}}function qi(e){return t=>new Bi(e,t)}function $i(e,t){const r=vn(e),n=vn(t.contentTopic),s=function(e){if(!e)return;let t;t="bigint"==typeof e?e:1000000n*BigInt(e.valueOf());return function(e){const t=new ArrayBuffer(8),r=new DataView(t);return"number"==typeof e?r.setFloat64(0,e,!1):r.setBigInt64(0,e,!1),new Uint8Array(t)}(t)}(t.timestamp),o=En([r,t.payload,n,t.meta,s].filter(Jt));return on(o)}class zi{peerIds=[];isStarted=!1;pubsubTopic;config;libp2p;filter;peerManager;connectionManager;activeSubscriptions;keepAliveIntervalId;pingFailedAttempts=new Map;receivedMessagesFormPeer=new Set;receivedMessages=new Set;verifiedPeers=new Set;constructor(e){this.config=e.config,this.connectionManager=e.connectionManager,this.filter=e.filter,this.peerManager=e.peerManager,this.libp2p=e.libp2p,this.activeSubscriptions=e.activeSubscriptions,this.pubsubTopic=e.pubsubTopic,this.onConnectionChange=this.onConnectionChange.bind(this),this.onPeerConnected=this.onPeerConnected.bind(this),this.onPeerDisconnected=this.onPeerDisconnected.bind(this)}get reservedContentTopic(){return`/js-waku-subscription-ping/1/${this.libp2p.peerId.toString()}/utf8`}start(){this.isStarted||(this.isStarted=!0,this.startKeepAlive(),this.startConnectionListener(),this.startPeerConnectionListener())}stop(){this.isStarted&&(this.isStarted=!1,this.stopKeepAlive(),this.stopConnectionListener(),this.stopPeerConnectionListener())}async getPeers(){return this.isStarted||(this.peerIds=this.peerManager.getPeers()),this.peerIds}notifyMessageReceived(e,t){const r=this.buildMessageHash(t);return this.verifiedPeers.add(e),this.receivedMessagesFormPeer.add(`${e}-${r}`),!!this.receivedMessages.has(r)||(this.receivedMessages.add(r),!1)}buildMessageHash(e){return function(e,t){const r=$i(e,t);return bn(r)}(this.pubsubTopic,e)}startConnectionListener(){this.connectionManager.addEventListener(hn.CONNECTION_STATUS,this.onConnectionChange)}stopConnectionListener(){this.connectionManager.removeEventListener(hn.CONNECTION_STATUS,this.onConnectionChange)}async onConnectionChange({detail:e}){e?(await Promise.all(this.peerIds.map((e=>this.ping(e,!0)))),this.startKeepAlive()):this.stopKeepAlive()}startKeepAlive(){this.keepAliveIntervalId||(this.keepAliveIntervalId=setInterval((()=>{this.peerIds.map((e=>this.ping(e)))}),this.config.keepAliveIntervalMs))}stopKeepAlive(){this.keepAliveIntervalId&&(clearInterval(this.keepAliveIntervalId),this.keepAliveIntervalId=void 0)}startPeerConnectionListener(){this.libp2p.addEventListener("peer:connect",this.onPeerConnected),this.libp2p.addEventListener("peer:disconnect",this.onPeerDisconnected)}stopPeerConnectionListener(){this.libp2p.removeEventListener("peer:connect",this.onPeerConnected),this.libp2p.removeEventListener("peer:disconnect",this.onPeerDisconnected)}async onPeerConnected(e){this.peerIds.length>0||(this.peerIds=this.peerManager.getPeers(),await Promise.all(this.peerIds.map((e=>this.subscribe(e)))))}async onPeerDisconnected(e){!this.peerIds.find((t=>t.equals(e.detail)))||(this.peerIds=this.peerManager.getPeers(),await Promise.all(this.peerIds.map((e=>this.subscribe(e)))))}async subscribe(e){let t=e;for(let e=0;e<3;e++){if(!t)return;if((await this.filter.subscribe(this.pubsubTopic,t,Array.from(this.activeSubscriptions.keys()))).success)return;t=this.peerManager.requestRenew(t)}}async ping(e,t=!1){const r=e.toString(),n=await this.filter.ping(e);if(n.failure&&t){const t=this.peerManager.requestRenew(e);return void await this.subscribe(t)}if(n.failure){const e=this.pingFailedAttempts.get(r)||0;this.pingFailedAttempts.set(r,e+1)}n.success&&this.pingFailedAttempts.set(r,0);if((this.pingFailedAttempts.get(r)||0)>=this.config.pingsBeforePeerRenewed){const t=this.peerManager.requestRenew(e);await this.subscribe(t)}}}const Ki=new Kn("sdk:filter:subscription");class Vi{pubsubTopic;protocol;config;monitor;subscriptionCallbacks=new Map;constructor(e,t,r,n,s,o,i){this.pubsubTopic=e,this.protocol=t,this.config=o,this.pubsubTopic=e,this.monitor=new zi({pubsubTopic:e,config:o,libp2p:s,connectionManager:r,filter:t,peerManager:n,lightPush:i,activeSubscriptions:this.subscriptionCallbacks})}async subscribe(e,t){const r=Array.isArray(e)?e:[e];for(const e of r)if(e.pubsubTopic!==this.pubsubTopic)return{failures:[{error:cn.TOPIC_DECODER_MISMATCH}],successes:[]};this.config.enableLightPushFilterCheck&&r.push(Zn(this.monitor.reservedContentTopic,this.pubsubTopic));const n=er(r),s=Array.from(n.keys()),o=(await this.monitor.getPeers()).map((async e=>this.protocol.subscribe(this.pubsubTopic,e,s))),i=await Promise.allSettled(o),a=this.handleResult(i,"subscribe");return n.forEach(((e,r)=>{const n={decoders:e,callback:t};r!==this.monitor.reservedContentTopic&&this.subscriptionCallbacks.set(r,n)})),this.monitor.start(),a}async unsubscribe(e){const t=(await this.monitor.getPeers()).map((async t=>{const r=await this.protocol.unsubscribe(this.pubsubTopic,t,e);return e.forEach((e=>{this.subscriptionCallbacks.delete(e)})),r})),r=await Promise.allSettled(t),n=this.handleResult(r,"unsubscribe");return 0===this.subscriptionCallbacks.size&&this.monitor.stop(),n}async ping(){const e=(await this.monitor.getPeers()).map((e=>this.protocol.ping(e))),t=await Promise.allSettled(e);return this.handleResult(t,"ping")}async unsubscribeAll(){const e=(await this.monitor.getPeers()).map((async e=>this.protocol.unsubscribeAll(this.pubsubTopic,e))),t=await Promise.allSettled(e);this.subscriptionCallbacks.clear();const r=this.handleResult(t,"unsubscribeAll");return this.monitor.stop(),r}async processIncomingMessage(e,t){if(this.monitor.notifyMessageReceived(t,e))return void Ki.info("Message already received, skipping");const{contentTopic:r}=e,n=this.subscriptionCallbacks.get(r);n?(Ki.info("Processing message with content topic ",r," on pubsub topic ",this.pubsubTopic),await async function(e,t,r){const{decoders:n,callback:s}=e,{contentTopic:o}=r;if(!o)return void Ki.warn("Message has no content topic, skipping");try{const e=n.map((e=>e.fromProtoObj(t,r).then((e=>e||Promise.reject("Decoding failed"))))),o=await Promise.any(e);await s(o)}catch(e){Ki.error("Error decoding message",e)}}(n,this.pubsubTopic,e)):Ki.error("No subscription callback available for ",r)}handleResult(e,t){const r={failures:[],successes:[]};for(const n of e)if("rejected"===n.status)Ki.error(`Failed to resolve ${t} promise successfully: `,n.reason),r.failures.push({error:cn.GENERIC_FAIL});else{const e=n.value;e.failure?r.failures.push(e.failure):r.successes.push(e.success)}return r}}const Hi=new Kn("sdk:filter");class ji{protocol;config;connectionManager;libp2p;peerManager;lightPush;activeSubscriptions=new Map;constructor(e){var t;this.config=(t=e.options,{keepAliveIntervalMs:t?.keepAliveIntervalMs||6e4,pingsBeforePeerRenewed:t?.pingsBeforePeerRenewed||3,enableLightPushFilterCheck:t?.enableLightPushFilterCheck||!1}),this.lightPush=e.lightPush,this.peerManager=e.peerManager,this.libp2p=e.libp2p,this.connectionManager=e.connectionManager,this.protocol=new Gs((async(e,t,r)=>{const n=this.getActiveSubscription(e);n?await n.processIncomingMessage(t,r):Hi.error("No subscription locally registered for topic "+e)}),e.connectionManager.pubsubTopics,e.libp2p),this.activeSubscriptions=new Map}async subscribe(e,t){const r=this.getUniquePubsubTopics(e);if(1!==r.length)return{subscription:null,error:cn.INVALID_DECODER_TOPICS,results:null};const n=r[0],{subscription:s,error:o}=await this.createSubscription(n);if(o)return{subscription:null,error:o,results:null};const{failures:i,successes:a}=await s.subscribe(e,t);return{subscription:s,error:null,results:{failures:i,successes:a}}}async createSubscription(e){const t="string"==typeof e?e:Sn(e)?.[0];In(t,this.protocol.pubsubTopics);const r=this.peerManager.getPeers();if(0===r.length)return{error:cn.NO_PEER_AVAILABLE,subscription:null};Hi.info(`Creating filter subscription with ${r.length} peers: `,r.map((e=>e.toString())));return{error:null,subscription:this.getActiveSubscription(t)??this.setActiveSubscription(t,new Vi(t,this.protocol,this.connectionManager,this.peerManager,this.libp2p,this.config,this.lightPush))}}async subscribeWithUnsubscribe(e,t){const r=this.getUniquePubsubTopics(e);if(0===r.length)throw Error("Failed to subscribe: no pubsubTopic found on decoders provided.");if(r.length>1)throw Error("Failed to subscribe: all decoders should have the same pubsub topic. Use createSubscription to be more agile.");const{subscription:n,error:s}=await this.createSubscription(r[0]);if(s)throw Error("Failed to create subscription: "+s);await n.subscribe(e,t);const o=Array.from(er(Array.isArray(e)?e:[e]).keys());return async()=>{await n.unsubscribe(o)}}toSubscriptionIterator(e){return async function(e,t,r){const n=[];let s;s=await e.subscribeWithUnsubscribe(t,(e=>{n.push(e)}));const o=Number.isInteger(r?.timeoutMs),i=Date.now();return{iterator:async function*(){for(;;){if(o&&Date.now()-i>=0)return;await tr(60);const e=n.shift();if(!s&&0===n.length)return e;!e&&s||(yield e)}}(),async stop(){s&&(await s(),s=void 0)}}}(this,e)}getActiveSubscription(e){return this.activeSubscriptions.get(e)}setActiveSubscription(e,t){return this.activeSubscriptions.set(e,t),t}getUniquePubsubTopics(e){if(!Array.isArray(e))return[e.pubsubTopic];if(0===e.length)return[];const t=new Set(e.map((e=>e.pubsubTopic)));return[...t]}}const Gi=new Kn("health-indicator");class Wi extends qo{libp2p;value=gn.Unhealthy;constructor(e){super(),this.libp2p=e.libp2p,this.onPeerIdentify=this.onPeerIdentify.bind(this),this.onPeerDisconnected=this.onPeerDisconnected.bind(this)}start(){Gi.info("start: adding listeners to libp2p"),this.libp2p.addEventListener("peer:identify",this.onPeerIdentify),this.libp2p.addEventListener("peer:disconnect",this.onPeerDisconnected)}stop(){Gi.info("stop: removing listeners to libp2p"),this.libp2p.removeEventListener("peer:identify",this.onPeerIdentify),this.libp2p.removeEventListener("peer:disconnect",this.onPeerDisconnected)}toString(){return this.value}toValue(){return this.value}async onPeerDisconnected(e){Gi.info("onPeerDisconnected: received libp2p event");this.libp2p.getConnections().length>0&&Gi.info("onPeerDisconnected: has connections, ignoring"),this.value=gn.Unhealthy,Gi.info("onPeerDisconnected: node identified as "+this.value),this.dispatchHealthEvent()}async onPeerIdentify(e){Gi.info("onPeerIdentify: received libp2p event");const t=this.libp2p.getConnections(),r=await Promise.all(t.map((async e=>{try{return await this.libp2p.peerStore.get(e.remotePeer)}catch(e){return null}}))),n=r.filter((e=>e?.protocols.includes(Hs))).length,s=r.filter((e=>e?.protocols.includes(Zs))).length;0===n||0===s?this.value=gn.Unhealthy:n>=2&&s>=2?this.value=gn.SufficientlyHealthy:1===n&&1===s?this.value=gn.MinimallyHealthy:Gi.error(`onPeerChange: unexpected state, cannot identify health status of the node: Filter:${n}; LightPush:${s}`),Gi.info("onPeerChange: node identified as "+this.value),this.dispatchHealthEvent()}dispatchHealthEvent(){this.dispatchEvent(new CustomEvent(fn.StatusChange,{detail:this.value}))}}const Xi=e=>new Promise(((t,r)=>setTimeout((()=>r(Error("Task timeout"))),e))),Zi=new Kn("sdk:retry-manager");class Yi{intervalID=null;retryIntervalMs;inProgress=0;queue=[];peerManager;constructor(e){this.peerManager=e.peerManager,this.retryIntervalMs=e.retryIntervalMs}start(){this.intervalID=setInterval((()=>{this.processQueue()}),this.retryIntervalMs)}stop(){this.intervalID&&(clearInterval(this.intervalID),this.intervalID=null)}push(e,t){this.queue.push({maxAttempts:t,callback:e})}processQueue(){if(0!==this.queue.length)for(;this.queue.length&&this.inProgress<5;){const e=this.queue.shift();e&&this.scheduleTask(e)}else Zi.info("processQueue: queue is empty")}scheduleTask(e){setTimeout((async()=>this.taskExecutor(e)),100)}async taskExecutor(e){const t=this.peerManager.getPeers()[0];var r;if(t)try{this.inProgress+=1;const r=await Promise.race([Xi(1e4),e.callback(t)]);if(r?.failure)throw Error(r.failure.error);if(Zi.info("scheduleTask: executed successfully"),0===e.maxAttempts)return void Zi.warn("scheduleTask: discarded a task due to limit of max attempts");this.queue.push({...e,maxAttempts:e.maxAttempts-1})}catch(n){const s=n;if(Zi.error("scheduleTask: task execution failed with error:",s),((r=s.message)===cn.REMOTE_PEER_REJECTED||r===cn.NO_RESPONSE||r===cn.RLN_PROOF_GENERATION||r===cn.NO_PEER_AVAILABLE)&&this.peerManager.requestRenew(t),0===e.maxAttempts)return void Zi.warn("scheduleTask: discarded a task due to limit of max attempts");this.queue.push({...e,maxAttempts:e.maxAttempts-1})}finally{this.inProgress-=1}else Zi.warn("scheduleTask: no peers, skipping")}}const Qi=new Kn("sdk:light-push"),Ji={autoRetry:!0,retryIntervalMs:1e3,maxAttempts:3,numPeersToUse:1};class ea{config;retryManager;peerManager;protocol;constructor(e){this.config={...Ji,...e.options||{}},this.peerManager=e.peerManager,this.protocol=new Ys(e.connectionManager.pubsubTopics,e.libp2p),this.retryManager=new Yi({peerManager:e.peerManager,retryIntervalMs:this.config.retryIntervalMs})}start(){this.retryManager.start()}stop(){this.retryManager.stop()}async send(e,t,r={}){r={...this.config,...r};const{pubsubTopic:n}=e;if(Qi.info("send: attempting to send a message to pubsubTopic:",n),!this.protocol.pubsubTopics.includes(n))return{successes:[],failures:[{error:cn.TOPIC_NOT_CONFIGURED}]};const s=this.peerManager.getPeers().slice(0,this.config.numPeersToUse);if(0===s.length)return{successes:[],failures:[{error:cn.NO_PEER_AVAILABLE}]};const o=await Promise.all(s.map((r=>this.protocol.send(e,t,r).catch((()=>({success:null,failure:{error:cn.GENERIC_FAIL}})))))),i={successes:o.filter((e=>e.success)).map((e=>e.success)),failures:o.filter((e=>e.failure)).map((e=>e.failure))};if(r.autoRetry&&0===i.successes.length){const n=r=>this.protocol.send(e,t,r);this.retryManager.push(n.bind(this),r.maxAttempts||3)}return i}}const ta=new Kn("peer-manager"),ra="peer-manager-lock";class na{numPeersToUse;libp2p;constructor(e){this.onConnected=this.onConnected.bind(this),this.onDisconnected=this.onDisconnected.bind(this),this.numPeersToUse=e?.config?.numPeersToUse||2,this.libp2p=e.libp2p}start(){this.startConnectionListener()}stop(){this.stopConnectionListener()}getPeers(){return this.getLockedConnections().map((e=>e.remotePeer))}requestRenew(e){const t=this.getLockedConnections(),r=this.numPeersToUse-t.length;if(0===r)return;const n=this.getUnlockedConnections().filter((t=>!t.remotePeer.equals(e))).slice(0,r).map((e=>this.lockConnection(e))).map((e=>e.remotePeer))[0];if(n)return ta.info(`requestRenew: Renewed peer ${e.toString()} to ${n.toString()}`),n;ta.warn(`requestRenew: Couldn't renew peer ${e.toString()} - no peers.`)}startConnectionListener(){this.libp2p.addEventListener("peer:connect",this.onConnected),this.libp2p.addEventListener("peer:disconnect",this.onDisconnected)}stopConnectionListener(){this.libp2p.removeEventListener("peer:connect",this.onConnected),this.libp2p.removeEventListener("peer:disconnect",this.onDisconnected)}onConnected(e){const t=e.detail;this.lockPeerIfNeeded(t)}onDisconnected(e){const t=e.detail;this.requestRenew(t)}lockPeerIfNeeded(e){const t=this.getLockedConnections();0!==this.numPeersToUse-t.length&&this.getUnlockedConnections().filter((t=>t.remotePeer.equals(e))).map((e=>this.lockConnection(e)))}getLockedConnections(){return this.libp2p.getConnections().filter((e=>"open"===e.status&&this.isConnectionLocked(e)))}getUnlockedConnections(){return this.libp2p.getConnections().filter((e=>"open"===e.status&&!this.isConnectionLocked(e)))}lockConnection(e){return ta.info("requestRenew: Locking connection for peerId="+e.remotePeer.toString()),e.tags.push(ra),e}isConnectionLocked(e){return e.tags.includes(ra)}}const sa=new Kn("waku:store:sdk");class oa{options;peerManager;connectionManager;protocol;constructor(e){this.options=e.options||{},this.peerManager=e.peerManager,this.connectionManager=e.connectionManager,this.protocol=new so(e.connectionManager.pubsubTopics,e.libp2p)}async*queryGenerator(e,t){const{pubsubTopic:r,contentTopics:n,decodersAsMap:s}=this.validateDecodersAndPubsubTopic(e),o={pubsubTopic:r,contentTopics:n,includeData:!0,paginationForward:!0,...t},i=await this.getPeerToUse();if(!i)throw sa.error("No peers available to query"),Error("No peers available to query");sa.info("Querying store with options: "+JSON.stringify(t));const a=this.protocol.queryPerPage(o,s,i);for await(const e of a)yield e}async queryWithOrderedCallback(e,t,r){sa.info("Querying store with ordered callback");for await(const n of this.queryGenerator(e,r))if(await this.processMessages(n,t))break}async queryWithPromiseCallback(e,t,r){sa.info("Querying store with promise callback");let n=!1;for await(const s of this.queryGenerator(e,r)){const e=s.map((async e=>{n||(n=!!await t(e))}));if(await Promise.all(e),n)break}}async processMessages(e,t){let r=!1;const n=(await Promise.all(e)).filter(Jt);return await Promise.all(n.map((async e=>{e&&!r&&(r=!!await t(e))}))),r}createCursor(e){return $i(e.pubsubTopic,e)}validateDecodersAndPubsubTopic(e){if(0===e.length)throw sa.error("No decoders provided"),Error("No decoders provided");const t=Array.from(new Set(e.map((e=>e.pubsubTopic))));if(t.length>1)throw sa.error("API does not support querying multiple pubsub topics at once"),Error("API does not support querying multiple pubsub topics at once");const r=t[0];In(r,this.protocol.pubsubTopics);const n=new Map;e.forEach((e=>{if(n.has(e.contentTopic))throw sa.error("API does not support different decoder per content topic"),Error("API does not support different decoder per content topic");n.set(e.contentTopic,e)}));const s=e.filter((e=>e.pubsubTopic===r)).map((e=>e.contentTopic));if(0===s.length)throw sa.error("No decoders found for topic "+r),Error("No decoders found for topic "+r);return{pubsubTopic:r,contentTopics:s,decodersAsMap:n}}async getPeerToUse(){let e;if(this.options?.peer){const t=(await this.connectionManager.getConnectedPeers()).find((e=>e.id.toString()===this.options?.peer));e=t?.id,e||sa.warn(`Passed node to use for Store not found: ${this.options.peer}. Attempting to use random peers.`)}const t=this.peerManager.getPeers();if(t.length>0)return t[Math.floor(Math.random()*t.length)];sa.error("No peers available to use.")}}const ia=(e,t)=>{const r=e.shardInfo?.clusterId||t.clusterId,n=e.shardInfo&&"shardsUnderCluster"in e.shardInfo?e.shardInfo.shardsUnderCluster:8;return{clusterId:r,shard:e.shardInfo&&"shard"in e.shardInfo?e.shardInfo.shard:xn(e.contentTopic,n)}},aa=(e,t)=>t.clusterId===e.clusterId&&!("shards"in t&&!t.shards.includes(e.shard)),ca=new Kn("wait-for-remote-peer");async function la(e,t,r){t=t?.length?t:function(e){const t=[];e.relay&&t.push(an.Relay);e.filter&&t.push(an.Filter);e.store&&t.push(an.Store);e.lightPush&&t.push(an.LightPush);return t}(e);const n=e.libp2p.getConnections();if(!e.isStarted())throw Error("Waku node is not started");for(const r of t)switch(r){case an.Relay:if(!e.relay)throw Error("Cannot wait for Relay peer: protocol not mounted");break;case an.LightPush:if(!e.lightPush)throw Error("Cannot wait for LightPush peer: protocol not mounted");break;case an.Store:if(!e.store)throw Error("Cannot wait for Store peer: protocol not mounted");break;case an.Filter:if(!e.filter)throw Error("Cannot wait for Filter peer: protocol not mounted")}const s=[ua(e,t)];n.length>0&&!t.includes(an.Relay)&&s.push(async function(e,t){const r=e.libp2p.getPeers(),n=e.libp2p.services.metadata,s=function(e){const t=new Map,r={[an.Filter]:Hs,[an.LightPush]:Zs,[an.Store]:no};for(const n of e)r[n]&&t.set(r[n],!1);return t}(t);if(!r.length||!n)return void ca.info(`Skipping waitForMetadata due to missing connections:${r.length} or metadataService:${!!n}`);for(const t of r)try{const r=await e.libp2p.peerStore.get(t);if(r.protocols.some((e=>s.has(e)))){if(!(await n.confirmOrAttemptHandshake(t)).error){r.protocols.forEach((e=>{s.has(e)&&s.set(e,!0)}));if(Array.from(s.values()).every((e=>e)))return}}}catch(e){"ERR_CONNECTION_BEING_CLOSED"===e.code&&ca.error("Connection closed. Some peers can be on different shard."),ca.error("Error while iterating through peers: "+e);continue}}(e,t)),r?await async function(e,t,r){await Promise.race([e,da(t,r)])}(Promise.any(s),r,"Timed out waiting for a remote peer."):await Promise.any(s)}async function ua(e,t){const r=[];return e.relay&&t.includes(an.Relay)&&r.push(e.relay.waitForPeers()),e.store&&t.includes(an.Store)&&r.push(ha(no,e.libp2p)),e.lightPush&&t.includes(an.LightPush)&&r.push(ha(Zs,e.libp2p)),e.filter&&t.includes(an.Filter)&&r.push(ha(Hs,e.libp2p)),Promise.all(r)}async function ha(e,t){ca.info(`Waiting for ${e} peer.`),await new Promise((r=>{const n=async s=>{if(s.detail?.protocols?.includes(e)){const e=t.services.metadata;if(!e)return t.removeEventListener("peer:identify",n),void r();try{await e.confirmOrAttemptHandshake(s.detail.peerId),t.removeEventListener("peer:identify",n),r()}catch(e){"ERR_CONNECTION_BEING_CLOSED"===e.code&&ca.error("Connection closed. Some peers can be on different shard."),ca.error("Error waiting for metadata: "+e)}}};t.addEventListener("peer:identify",n)}))}const da=(e,t)=>new Promise(((r,n)=>setTimeout((()=>n(Error(t))),e)));const pa=new Kn("waku");class fa{pubsubTopics;libp2p;relay;store;filter;lightPush;connectionManager;health;networkConfig;_nodeStateLock=!1;_nodeStarted=!1;peerManager;constructor(e,t,r,n,s){this.pubsubTopics=e,this.relay=s,this.libp2p=r,this.networkConfig=t.networkConfig||pn,n={filter:!1,lightpush:!1,store:!1,...n};const o=this.libp2p.peerId.toString();this.connectionManager=new Oi({libp2p:r,relay:this.relay,pubsubTopics:this.pubsubTopics,config:t?.connectionManager}),this.peerManager=new na({libp2p:r,config:{numPeersToUse:t.numPeersToUse}}),this.health=new Wi({libp2p:r}),n.store&&(t.store?.peer&&this.connectionManager.rawDialPeerWithProtocols(t.store.peer,[no]).catch((e=>{pa.error("Failed to dial store peer",e)})),this.store=new oa({libp2p:r,connectionManager:this.connectionManager,peerManager:this.peerManager,options:{peer:t.store?.peer}})),n.lightpush&&(this.lightPush=new ea({libp2p:r,peerManager:this.peerManager,connectionManager:this.connectionManager,options:t?.lightPush})),n.filter&&(this.filter=new ji({libp2p:r,connectionManager:this.connectionManager,peerManager:this.peerManager,lightPush:this.lightPush,options:t.filter})),pa.info("Waku node created",o,`relay: ${!!this.relay}, store: ${!!this.store}, light push: ${!!this.lightPush}, filter: ${!!this.filter}`)}get peerId(){return this.libp2p.peerId}get protocols(){return this.libp2p.getProtocols()}async dial(e,t){const r=t??[];void 0===t&&(this.relay&&r.push(an.Relay),this.store&&r.push(an.Store),this.filter&&r.push(an.Filter),this.lightPush&&r.push(an.LightPush));const n=[];r.includes(an.Relay)&&(this.relay?this.relay.gossipSub.multicodecs.forEach((e=>n.push(e))):pa.error("Relay codec not included in dial codec: protocol not mounted locally")),r.includes(an.Store)&&(this.store?n.push(this.store.protocol.multicodec):pa.error("Store codec not included in dial codec: protocol not mounted locally")),r.includes(an.LightPush)&&(this.lightPush?n.push(this.lightPush.protocol.multicodec):pa.error("Light Push codec not included in dial codec: protocol not mounted locally")),r.includes(an.Filter)&&(this.filter?n.push(this.filter.protocol.multicodec):pa.error("Filter codec not included in dial codec: protocol not mounted locally"));const s=(e=>lo(e)?e:Ri(e))(e);return pa.info(`Dialing to ${s.toString()} with protocols ${r}`),await this.connectionManager.rawDialPeerWithProtocols(e,n)}async start(){this._nodeStateLock||this.isStarted()||(this._nodeStateLock=!0,await this.libp2p.start(),this.peerManager.start(),this.health.start(),this.lightPush?.start(),this._nodeStateLock=!1,this._nodeStarted=!0)}async stop(){!this._nodeStateLock&&this.isStarted()&&(this._nodeStateLock=!0,this.lightPush?.stop(),this.health.stop(),this.peerManager.stop(),this.connectionManager.stop(),await this.libp2p.stop(),this._nodeStateLock=!1,this._nodeStarted=!1)}async getConnectedPeers(){return this.connectionManager.getConnectedPeers()}async waitForPeers(e,t){return la(this,e,t)}isStarted(){return this._nodeStarted&&"started"===this.libp2p.status}isConnected(){return this.connectionManager.isConnected()}createDecoder(e){const t=ia(e,this.networkConfig);if(pa.info(`Creating Decoder with input:${JSON.stringify(e.shardInfo)}, determined:${JSON.stringify(t)}, expected:${JSON.stringify(this.networkConfig)}.`),!aa(t,this.networkConfig))throw Error("Cannot create decoder: incompatible shard configuration.");return Zn(e.contentTopic,t)}createEncoder(e){const t=ia(e,this.networkConfig);if(pa.info(`Creating Encoder with input:${JSON.stringify(e.shardInfo)}, determined:${JSON.stringify(t)}, expected:${JSON.stringify(this.networkConfig)}.`),!aa(t,this.networkConfig))throw Error("Cannot create encoder: incompatible shard configuration.");return Wn({contentTopic:e.contentTopic,ephemeral:e.ephemeral,pubsubTopicShardInfo:t})}}const ga=parseInt("11111",2),ma=parseInt("10000000",2),ya=parseInt("01111111",2),ba={0:Ea,1:Ea,2(e,t){const r=va(e,t),n=t.offset,s=t.offset+r,o=[];for(let t=n;t<s;t++)t===n&&0===e[t]||o.push(e[t]);return t.offset+=r,Uint8Array.from(o)},3(e,t){const r=va(e,t),n=e[t.offset];t.offset++;const s=e.subarray(t.offset,t.offset+r-1);if(t.offset+=r,0!==n)throw Error("Unused bits in bit string is unimplemented");return s},4(e,t){const r=va(e,t),n=e.subarray(t.offset,t.offset+r);return t.offset+=r,n},5(e,t){return t.offset++,null},6(e,t){const r=va(e,t),n=t.offset+r,s=e[t.offset];t.offset++;let o=0,i=0;s<40?(o=0,i=s):s<80?(o=1,i=s-40):(o=2,i=s-80);let a=`${o}.${i}`,c=[];for(;t.offset<n;){const r=e[t.offset];if(t.offset++,c.push(127&r),r<128){c.reverse();let e=0;for(let t=0;t<c.length;t++)e+=c[t]<<7*t;a+="."+e,c=[]}}return a},16:Ea,22:Ea,48:Ea};function wa(e,t={offset:0}){const r=e[t.offset]&ga;if(t.offset++,null!=ba[r])return ba[r](e,t);throw Error("No decoder for tag "+r)}function va(e,t){let r=0;if((e[t.offset]&ma)===ma){const n=e[t.offset]&ya;let s="0x";t.offset++;for(let r=0;r<n;r++,t.offset++)s+=e[t.offset].toString(16).padStart(2,"0");r=parseInt(s,16)}else r=e[t.offset],t.offset++;return r}function Ea(e,t){va(e,t);const r=[];for(;!(t.offset>=e.byteLength);){const n=wa(e,t);if(null===n)break;r.push(n)}return r}function Sa(e){if(e.byteLength<128)return Uint8Array.from([e.byteLength]);const t=function(e){let t=e.toString(16);t.length%2==1&&(t="0"+t);const r=new ns;for(let e=0;e<t.length;e+=2)r.append(Uint8Array.from([parseInt(`${t[e]}${t[e+1]}`,16)]));return r}(e.byteLength);return new ns(Uint8Array.from([t.byteLength|ma]),t)}function Aa(e){const t=new ns;return!(128&~e.subarray()[0])&&t.append(Uint8Array.from([0])),t.append(e),new ns(Uint8Array.from([2]),Sa(t),t)}function Ca(e){const t=Uint8Array.from([0]),r=new ns(t,e);return new ns(Uint8Array.from([3]),Sa(r),r)}function Ia(e,t=48){const r=new ns;for(const t of e)r.append(t);return new ns(Uint8Array.from([t]),Sa(r),r)}const xa=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),ka=Uint8Array.from([6,5,43,129,4,0,34]),Pa=Uint8Array.from([6,5,43,129,4,0,35]),Ta={ext:!0,kty:"EC",crv:"P-256"},_a={ext:!0,kty:"EC",crv:"P-384"},Ra={ext:!0,kty:"EC",crv:"P-521"};function La(e){return Da(wa(e))}function Da(e){const t=e[1][1][0];let r,n;if(65===t.byteLength)return r=mn(t.subarray(1,33),"base64url"),n=mn(t.subarray(33),"base64url"),new Ma({...Ta,key_ops:["verify"],x:r,y:n});if(97===t.byteLength)return r=mn(t.subarray(1,49),"base64url"),n=mn(t.subarray(49),"base64url"),new Ma({..._a,key_ops:["verify"],x:r,y:n});if(133===t.byteLength)return r=mn(t.subarray(1,67),"base64url"),n=mn(t.subarray(67),"base64url"),new Ma({...Ra,key_ops:["verify"],x:r,y:n});throw new yo(`coordinates were wrong length, got ${t.byteLength}, expected 65, 97 or 133`)}function Na(e){if("P-256"===e)return xa;if("P-384"===e)return ka;if("P-521"===e)return Pa;throw new yo("Invalid curve "+e)}class Ma{type="ECDSA";jwk;_raw;constructor(e){this.jwk=e}get raw(){var e;return null==this._raw&&(this._raw=(e=this.jwk,Ia([Aa(Uint8Array.from([1])),Ia([Na(e.crv)],160),Ia([Ca(new ns(Uint8Array.from([4]),tt(e.x??"","base64url"),tt(e.y??"","base64url")))],161)]).subarray())),this._raw}toMultihash(){return Be.digest(iu(this))}toCID(){return He.createV1(114,this.toMultihash())}toString(){return he.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&Jn(this.raw,e.raw)}async verify(e,t,r){return async function(e,t,r,n){const s=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:e.crv??"P-256"},!1,["verify"]);n?.signal?.throwIfAborted();const o=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},s,t,r.subarray());return n?.signal?.throwIfAborted(),o}(this.jwk,t,e,r)}}const Oa=BigInt(0),Fa=BigInt(1);function Ua(e,t=""){if("boolean"!=typeof e){throw Error((t&&`"${t}"`)+"expected boolean, got type="+typeof e)}return e}function Ba(e,t,r=""){const n=sr(e),s=e?.length,o=void 0!==t;if(!n||o&&s!==t){throw Error((r&&`"${r}" `)+"expected Uint8Array"+(o?" of length "+t:"")+", got "+(n?"length="+s:"type="+typeof e))}return e}function qa(e){const t=e.toString(16);return 1&t.length?"0"+t:t}function $a(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);return""===e?Oa:BigInt("0x"+e)}function za(e){return $a(fr(e))}function Ka(e){return ir(e),$a(fr(Uint8Array.from(e).reverse()))}function Va(e,t){return Sr(e.toString(16).padStart(2*t,"0"))}function Ha(e,t){return Va(e,t).reverse()}function ja(e,t,r){let n;if("string"==typeof t)try{n=Sr(t)}catch(t){throw Error(e+" must be hex string or Uint8Array, cause: "+t)}else{if(!sr(t))throw Error(e+" must be hex string or Uint8Array");n=Uint8Array.from(t)}const s=n.length;if("number"==typeof r&&s!==r)throw Error(e+" of length "+r+" expected, got "+s);return n}function Ga(e){return Uint8Array.from(e)}const Wa=e=>"bigint"==typeof e&&Oa<=e;function Xa(e,t,r,n){if(!function(e,t,r){return Wa(e)&&Wa(t)&&Wa(r)&&t<=e&&e<r}(t,r,n))throw Error("expected valid "+e+": "+r+" <= n < "+n+", got "+t)}function Za(e){let t;for(t=0;e>Oa;e>>=Fa,t+=1);return t}const Ya=e=>(Fa<<BigInt(e))-Fa;function Qa(e,t,r={}){if(!e||"object"!=typeof e)throw Error("expected valid options object");function n(t,r,n){const s=e[t];if(n&&void 0===s)return;const o=typeof s;if(o!==r||null===s)throw Error(`param "${t}" is invalid: expected ${r}, got ${o}`)}Object.entries(t).forEach((([e,t])=>n(e,t,!1))),Object.entries(r).forEach((([e,t])=>n(e,t,!0)))}function Ja(e){const t=new WeakMap;return(r,...n)=>{const s=t.get(r);if(void 0!==s)return s;const o=e(r,...n);return t.set(r,o),o}}const ec=BigInt(0),tc=BigInt(1),rc=BigInt(2),nc=BigInt(3),sc=BigInt(4),oc=BigInt(5),ic=BigInt(7),ac=BigInt(8),cc=BigInt(9),lc=BigInt(16);function uc(e,t){const r=e%t;return r>=ec?r:t+r}function hc(e,t,r){let n=e;for(;t-- >ec;)n*=n,n%=r;return n}function dc(e,t){if(e===ec)throw Error("invert: expected non-zero number");if(t<=ec)throw Error("invert: expected positive modulus, got "+t);let r=uc(e,t),n=t,s=ec,o=tc;for(;r!==ec;){const e=n%r,t=s-o*(n/r);n=r,r=e,s=o,o=t}if(n!==tc)throw Error("invert: does not exist");return uc(s,t)}function pc(e,t,r){if(!e.eql(e.sqr(t),r))throw Error("Cannot find square root")}function fc(e,t){const r=(e.ORDER+tc)/sc,n=e.pow(t,r);return pc(e,n,t),n}function gc(e,t){const r=(e.ORDER-oc)/ac,n=e.mul(t,rc),s=e.pow(n,r),o=e.mul(t,s),i=e.mul(e.mul(o,rc),s),a=e.mul(o,e.sub(i,e.ONE));return pc(e,a,t),a}function mc(e){if(e<nc)throw Error("sqrt is not defined for small field");let t=e-tc,r=0;for(;t%rc===ec;)t/=rc,r++;let n=rc;const s=Sc(e);for(;1===vc(s,n);)if(n++>1e3)throw Error("Cannot find square root: probably non-prime P");if(1===r)return fc;let o=s.pow(n,t);const i=(t+tc)/rc;return function(e,n){if(e.is0(n))return n;if(1!==vc(e,n))throw Error("Cannot find square root");let s=r,a=e.mul(e.ONE,o),c=e.pow(n,t),l=e.pow(n,i);for(;!e.eql(c,e.ONE);){if(e.is0(c))return e.ZERO;let t=1,r=e.sqr(c);for(;!e.eql(r,e.ONE);)if(t++,r=e.sqr(r),t===s)throw Error("Cannot find square root");const n=tc<<BigInt(s-t-1),o=e.pow(a,n);s=t,a=e.sqr(o),c=e.mul(c,a),l=e.mul(l,o)}return l}}function yc(e){return e%sc===nc?fc:e%ac===oc?gc:e%lc===cc?function(e){const t=Sc(e),r=mc(e),n=r(t,t.neg(t.ONE)),s=r(t,n),o=r(t,t.neg(n)),i=(e+ic)/lc;return(e,t)=>{let r=e.pow(t,i),a=e.mul(r,n);const c=e.mul(r,s),l=e.mul(r,o),u=e.eql(e.sqr(a),t),h=e.eql(e.sqr(c),t);r=e.cmov(r,a,u),a=e.cmov(l,c,h);const d=e.eql(e.sqr(a),t),p=e.cmov(r,a,d);return pc(e,p,t),p}}(e):mc(e)}const bc=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function wc(e,t,r=!1){const n=Array(t.length).fill(r?e.ZERO:void 0),s=t.reduce(((t,r,s)=>e.is0(r)?t:(n[s]=t,e.mul(t,r))),e.ONE),o=e.inv(s);return t.reduceRight(((t,r,s)=>e.is0(r)?t:(n[s]=e.mul(t,n[s]),e.mul(t,r))),o),n}function vc(e,t){const r=(e.ORDER-tc)/rc,n=e.pow(t,r),s=e.eql(n,e.ONE),o=e.eql(n,e.ZERO),i=e.eql(n,e.neg(e.ONE));if(!s&&!o&&!i)throw Error("invalid Legendre symbol result");return s?1:o?0:-1}function Ec(e,t){void 0!==t&&or(t);const r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Sc(e,t,r=!1,n={}){if(e<=ec)throw Error("invalid field: expected ORDER > 0, got "+e);let s,o,i,a=!1;if("object"==typeof t&&null!=t){if(n.sqrt||r)throw Error("cannot specify opts in two arguments");const e=t;e.BITS&&(s=e.BITS),e.sqrt&&(o=e.sqrt),"boolean"==typeof e.isLE&&(r=e.isLE),"boolean"==typeof e.modFromBytes&&(a=e.modFromBytes),i=e.allowedLengths}else"number"==typeof t&&(s=t),n.sqrt&&(o=n.sqrt);const{nBitLength:c,nByteLength:l}=Ec(e,s);if(l>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let u;const h=Object.freeze({ORDER:e,isLE:r,BITS:c,BYTES:l,MASK:Ya(c),ZERO:ec,ONE:tc,allowedLengths:i,create(t){return uc(t,e)},isValid(t){if("bigint"!=typeof t)throw Error("invalid field element: expected bigint, got "+typeof t);return ec<=t&&t<e},is0(e){return e===ec},isValidNot0(e){return!h.is0(e)&&h.isValid(e)},isOdd(e){return(e&tc)===tc},neg(t){return uc(-t,e)},eql(e,t){return e===t},sqr(t){return uc(t*t,e)},add(t,r){return uc(t+r,e)},sub(t,r){return uc(t-r,e)},mul(t,r){return uc(t*r,e)},pow(e,t){return function(e,t,r){if(r<ec)throw Error("invalid exponent, negatives unsupported");if(r===ec)return e.ONE;if(r===tc)return t;let n=e.ONE,s=t;for(;r>ec;)r&tc&&(n=e.mul(n,s)),s=e.sqr(s),r>>=tc;return n}(h,e,t)},div(t,r){return uc(t*dc(r,e),e)},sqrN(e){return e*e},addN(e,t){return e+t},subN(e,t){return e-t},mulN(e,t){return e*t},inv(t){return dc(t,e)},sqrt:o||(t=>(u||(u=yc(e)),u(h,t))),toBytes(e){return r?Ha(e,l):Va(e,l)},fromBytes(t,n=!0){if(i){if(!i.includes(t.length)||t.length>l)throw Error("Field.fromBytes: expected "+i+" bytes, got "+t.length);const e=new Uint8Array(l);e.set(t,r?0:e.length-t.length),t=e}if(t.length!==l)throw Error("Field.fromBytes: expected "+l+" bytes, got "+t.length);let s=r?Ka(t):za(t);if(a&&(s=uc(s,e)),!n&&!h.isValid(s))throw Error("invalid field element: outside of range 0..ORDER");return s},invertBatch(e){return wc(h,e)},cmov(e,t,r){return r?t:e}});return Object.freeze(h)}function Ac(e){if("bigint"!=typeof e)throw Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function Cc(e){const t=Ac(e);return t+Math.ceil(t/2)}const Ic=BigInt(0),xc=BigInt(1);function kc(e,t){const r=t.negate();return e?r:t}function Pc(e,t){const r=wc(e.Fp,t.map((e=>e.Z)));return t.map(((t,n)=>e.fromAffine(t.toAffine(r[n]))))}function Tc(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw Error("invalid window size, expected [1.."+t+"], got W="+e)}function _c(e,t){Tc(e,t);const r=2**e;return{windows:Math.ceil(t/e)+1,windowSize:2**(e-1),mask:Ya(e),maxNumber:r,shiftBy:BigInt(e)}}function Rc(e,t,r){const{windowSize:n,mask:s,maxNumber:o,shiftBy:i}=r;let a=Number(e&s),c=e>>i;a>n&&(a-=o,c+=xc);const l=t*n;return{nextN:c,offset:l+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:t%2!=0,offsetF:l}}const Lc=new WeakMap,Dc=new WeakMap;function Nc(e){return Dc.get(e)||1}function Mc(e){if(e!==Ic)throw Error("invalid wNAF")}class Oc{constructor(e,t){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,r=this.ZERO){let n=e;for(;t>Ic;)t&xc&&(r=r.add(n)),n=n.double(),t>>=xc;return r}precomputeWindow(e,t){const{windows:r,windowSize:n}=_c(t,this.bits),s=[];let o=e,i=o;for(let e=0;e<r;e++){i=o,s.push(i);for(let e=1;e<n;e++)i=i.add(o),s.push(i);o=i.double()}return s}wNAF(e,t,r){if(!this.Fn.isValid(r))throw Error("invalid scalar");let n=this.ZERO,s=this.BASE;const o=_c(e,this.bits);for(let e=0;e<o.windows;e++){const{nextN:i,offset:a,isZero:c,isNeg:l,isNegF:u,offsetF:h}=Rc(r,e,o);r=i,c?s=s.add(kc(u,t[h])):n=n.add(kc(l,t[a]))}return Mc(r),{p:n,f:s}}wNAFUnsafe(e,t,r,n=this.ZERO){const s=_c(e,this.bits);for(let e=0;e<s.windows&&r!==Ic;e++){const{nextN:o,offset:i,isZero:a,isNeg:c}=Rc(r,e,s);if(r=o,!a){const e=t[i];n=n.add(c?e.negate():e)}}return Mc(r),n}getPrecomputes(e,t,r){let n=Lc.get(t);return n||(n=this.precomputeWindow(t,e),1!==e&&("function"==typeof r&&(n=r(n)),Lc.set(t,n))),n}cached(e,t,r){const n=Nc(e);return this.wNAF(n,this.getPrecomputes(n,e,r),t)}unsafe(e,t,r,n){const s=Nc(e);return 1===s?this._unsafeLadder(e,t,n):this.wNAFUnsafe(s,this.getPrecomputes(s,e,r),t,n)}createCache(e,t){Tc(t,this.bits),Dc.set(e,t),Lc.delete(e)}hasCache(e){return 1!==Nc(e)}}function Fc(e,t,r,n){!function(e,t){if(!Array.isArray(e))throw Error("array expected");e.forEach(((e,r)=>{if(!(e instanceof t))throw Error("invalid point at index "+r)}))}(r,e),function(e,t){if(!Array.isArray(e))throw Error("array of scalars expected");e.forEach(((e,r)=>{if(!t.isValid(e))throw Error("invalid scalar at index "+r)}))}(n,t);const s=r.length,o=n.length;if(s!==o)throw Error("arrays of points and scalars must have equal length");const i=e.ZERO,a=Za(BigInt(s));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const l=Ya(c),u=Array(Number(l)+1).fill(i);let h=i;for(let e=Math.floor((t.BITS-1)/c)*c;e>=0;e-=c){u.fill(i);for(let t=0;t<o;t++){const s=n[t],o=Number(s>>BigInt(e)&l);u[o]=u[o].add(r[t])}let t=i;for(let e=u.length-1,r=i;e>0;e--)r=r.add(u[e]),t=t.add(r);if(h=h.add(t),0!==e)for(let e=0;e<c;e++)h=h.double()}return h}function Uc(e,t,r){if(t){if(t.ORDER!==e)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return function(e){const t=bc.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"});Qa(e,t)}(t),t}return Sc(e,{isLE:r})}function Bc(e,t,r={},n){if(void 0===n&&(n="edwards"===e),!t||"object"!=typeof t)throw Error(`expected valid ${e} CURVE object`);for(const e of["p","n","h"]){const r=t[e];if(!("bigint"==typeof r&&r>Ic))throw Error(`CURVE.${e} must be positive bigint`)}const s=Uc(t.p,r.Fp,n),o=Uc(t.n,r.Fn,n),i=["Gx","Gy","a","weierstrass"===e?"b":"d"];for(const e of i)if(!s.isValid(t[e]))throw Error(`CURVE.${e} must be valid field element of CURVE.Fp`);return{CURVE:t=Object.freeze(Object.assign({},t)),Fp:s,Fn:o}}const qc=BigInt(0),$c=BigInt(1),zc=BigInt(2),Kc=BigInt(8);function Vc(e,t,r={}){if("function"!=typeof t)throw Error('"hash" function param is required');Qa(r,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:n}=r,{BASE:s,Fp:o,Fn:i}=e,a=r.randomBytes||kr,c=r.adjustScalarBytes||(e=>e),l=r.domain||((e,t,r)=>{if(Ua(r,"phflag"),t.length||r)throw Error("Contexts/pre-hash are not supported");return e});function u(e){return i.create(Ka(e))}function h(e){const{head:r,prefix:n,scalar:o}=function(e){const r=m.secretKey;e=ja("private key",e,r);const n=ja("hashed private key",t(e),2*r),s=c(n.slice(0,r));return{head:s,prefix:n.slice(r,2*r),scalar:u(s)}}(e),i=s.multiply(o),a=i.toBytes();return{head:r,prefix:n,scalar:o,point:i,pointBytes:a}}function d(e){return h(e).pointBytes}function p(e=Uint8Array.of(),...r){const s=Cr(...r);return u(t(l(s,ja("context",e),!!n)))}const f={zip215:!0};const g=o.BYTES,m={secretKey:g,publicKey:g,signature:2*g,seed:g};function y(e=a(m.seed)){return Ba(e,m.seed,"seed")}const b={getExtendedPublicKey:h,randomSecretKey:y,isValidSecretKey(e){return sr(e)&&e.length===i.BYTES},isValidPublicKey(t,r){try{return!!e.fromBytes(t,r)}catch(e){return!1}},toMontgomery(t){const{y:r}=e.fromBytes(t),n=m.publicKey,s=32===n;if(!s&&57!==n)throw Error("only defined for 25519 and 448");const i=s?o.div($c+r,$c-r):o.div(r-$c,r+$c);return o.toBytes(i)},toMontgomerySecret(e){const r=m.secretKey;Ba(e,r);const n=t(e.subarray(0,r));return c(n).subarray(0,r)},randomPrivateKey:y,precompute:(t=8,r=e.BASE)=>r.precompute(t,!1)};return Object.freeze({keygen(e){const t=b.randomSecretKey(e);return{secretKey:t,publicKey:d(t)}},getPublicKey:d,sign(e,t,r={}){e=ja("message",e),n&&(e=n(e));const{prefix:o,scalar:a,pointBytes:c}=h(t),l=p(r.context,o,e),u=s.multiply(l).toBytes(),d=p(r.context,u,c,e),f=i.create(l+d*a);if(!i.isValid(f))throw Error("sign failed: invalid s");return Ba(Cr(u,i.toBytes(f)),m.signature,"result")},verify(t,r,o,i=f){const{context:a,zip215:c}=i,l=m.signature;t=ja("signature",t,l),r=ja("message",r),o=ja("publicKey",o,m.publicKey),void 0!==c&&Ua(c,"zip215"),n&&(r=n(r));const u=l/2,h=t.subarray(0,u),d=Ka(t.subarray(u,l));let g,y,b;try{g=e.fromBytes(o,c),y=e.fromBytes(h,c),b=s.multiplyUnsafe(d)}catch(e){return!1}if(!c&&g.isSmallOrder())return!1;const w=p(a,y.toBytes(),g.toBytes(),r);return y.add(g.multiplyUnsafe(w)).subtract(b).clearCofactor().is0()},utils:b,Point:e,lengths:m})}function Hc(e){const{CURVE:t,curveOpts:r,hash:n,eddsaOpts:s}=function(e){const t={a:e.a,d:e.d,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},r={Fp:e.Fp,Fn:Sc(t.n,e.nBitLength,!0),uvRatio:e.uvRatio},n={randomBytes:e.randomBytes,adjustScalarBytes:e.adjustScalarBytes,domain:e.domain,prehash:e.prehash,mapToCurve:e.mapToCurve};return{CURVE:t,curveOpts:r,hash:e.hash,eddsaOpts:n}}(e),o=function(e,t={}){const r=Bc("edwards",e,t,t.FpFnLE),{Fp:n,Fn:s}=r;let o=r.CURVE;const{h:i}=o;Qa(t,{},{uvRatio:"function"});const a=zc<<BigInt(8*s.BYTES)-$c,c=e=>n.create(e),l=t.uvRatio||((e,t)=>{try{return{isValid:!0,value:n.sqrt(n.div(e,t))}}catch(e){return{isValid:!1,value:qc}}});if(!((e,t,r,n)=>{const s=e.sqr(r),o=e.sqr(n),i=e.add(e.mul(t.a,s),o),a=e.add(e.ONE,e.mul(t.d,e.mul(s,o)));return e.eql(i,a)})(n,o,o.Gx,o.Gy))throw Error("bad curve params: generator point");function u(e,t,r=!1){return Xa("coordinate "+e,t,r?$c:qc,a),t}function h(e){if(!(e instanceof f))throw Error("ExtendedPoint expected")}const d=Ja(((e,t)=>{const{X:r,Y:s,Z:o}=e,i=e.is0();null==t&&(t=i?Kc:n.inv(o));const a=c(r*t),l=c(s*t),u=n.mul(o,t);if(i)return{x:qc,y:$c};if(u!==$c)throw Error("invZ was invalid");return{x:a,y:l}})),p=Ja((e=>{const{a:t,d:r}=o;if(e.is0())throw Error("bad point: ZERO");const{X:n,Y:s,Z:i,T:a}=e,l=c(n*n),u=c(s*s),h=c(i*i),d=c(h*h),p=c(l*t);if(c(h*c(p+u))!==c(d+c(r*c(l*u))))throw Error("bad point: equation left != right (1)");if(c(n*s)!==c(i*a))throw Error("bad point: equation left != right (2)");return!0}));class f{constructor(e,t,r,n){this.X=u("x",e),this.Y=u("y",t),this.Z=u("z",r,!0),this.T=u("t",n),Object.freeze(this)}static CURVE(){return o}static fromAffine(e){if(e instanceof f)throw Error("extended point not allowed");const{x:t,y:r}=e||{};return u("x",t),u("y",r),new f(t,r,$c,c(t*r))}static fromBytes(e,t=!1){const r=n.BYTES,{a:s,d:i}=o;e=Ga(Ba(e,r,"point")),Ua(t,"zip215");const u=Ga(e),h=e[r-1];u[r-1]=-129&h;const d=Ka(u),p=t?a:n.ORDER;Xa("point.y",d,qc,p);const g=c(d*d),m=c(g-$c),y=c(i*g-s);let{isValid:b,value:w}=l(m,y);if(!b)throw Error("bad point: invalid y coordinate");const v=(w&$c)===$c,E=!!(128&h);if(!t&&w===qc&&E)throw Error("bad point: x=0 and x_0=1");return E!==v&&(w=c(-w)),f.fromAffine({x:w,y:d})}static fromHex(e,t=!1){return f.fromBytes(ja("point",e),t)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(e=8,t=!0){return g.createCache(this,e),t||this.multiply(zc),this}assertValidity(){p(this)}equals(e){h(e);const{X:t,Y:r,Z:n}=this,{X:s,Y:o,Z:i}=e,a=c(t*i),l=c(s*n),u=c(r*i),d=c(o*n);return a===l&&u===d}is0(){return this.equals(f.ZERO)}negate(){return new f(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:e}=o,{X:t,Y:r,Z:n}=this,s=c(t*t),i=c(r*r),a=c(zc*c(n*n)),l=c(e*s),u=t+r,h=c(c(u*u)-s-i),d=l+i,p=d-a,g=l-i,m=c(h*p),y=c(d*g),b=c(h*g),w=c(p*d);return new f(m,y,w,b)}add(e){h(e);const{a:t,d:r}=o,{X:n,Y:s,Z:i,T:a}=this,{X:l,Y:u,Z:d,T:p}=e,g=c(n*l),m=c(s*u),y=c(a*r*p),b=c(i*d),w=c((n+s)*(l+u)-g-m),v=b-y,E=b+y,S=c(m-t*g),A=c(w*v),C=c(E*S),I=c(w*S),x=c(v*E);return new f(A,C,x,I)}subtract(e){return this.add(e.negate())}multiply(e){if(!s.isValidNot0(e))throw Error("invalid scalar: expected 1 <= sc < curve.n");const{p:t,f:r}=g.cached(this,e,(e=>Pc(f,e)));return Pc(f,[t,r])[0]}multiplyUnsafe(e,t=f.ZERO){if(!s.isValid(e))throw Error("invalid scalar: expected 0 <= sc < curve.n");return e===qc?f.ZERO:this.is0()||e===$c?this:g.unsafe(this,e,(e=>Pc(f,e)),t)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}isTorsionFree(){return g.unsafe(this,o.n).is0()}toAffine(e){return d(this,e)}clearCofactor(){return i===$c?this:this.multiplyUnsafe(i)}toBytes(){const{x:e,y:t}=this.toAffine(),r=n.toBytes(t);return r[r.length-1]|=e&$c?128:0,r}toHex(){return fr(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(e){return Pc(f,e)}static msm(e,t){return Fc(f,s,e,t)}_setWindowSize(e){this.precompute(e)}toRawBytes(){return this.toBytes()}}f.BASE=new f(o.Gx,o.Gy,$c,c(o.Gx*o.Gy)),f.ZERO=new f(qc,$c,$c,qc),f.Fp=n,f.Fn=s;const g=new Oc(f,s.BITS);return f.BASE.precompute(8),f}(t,r);return function(e,t){const r=t.Point;return Object.assign({},t,{ExtendedPoint:r,CURVE:e,nBitLength:r.Fn.BITS,nByteLength:r.Fn.BYTES})}(e,Vc(o,n,s))}const jc=BigInt(0),Gc=BigInt(1),Wc=BigInt(2);function Xc(e){const t=(Qa(r=e,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r}));var r;const{P:n,type:s,adjustScalarBytes:o,powPminus2:i,randomBytes:a}=t,c="x25519"===s;if(!c&&"x448"!==s)throw Error("invalid type");const l=a||kr,u=c?255:448,h=c?32:56,d=c?BigInt(9):BigInt(5),p=c?BigInt(121665):BigInt(39081),f=c?Wc**BigInt(254):Wc**BigInt(447),g=c?BigInt(8)*Wc**BigInt(251)-Gc:BigInt(4)*Wc**BigInt(445)-Gc,m=f+g+Gc,y=e=>uc(e,n),b=w(d);function w(e){return Ha(y(e),h)}function v(e,t){const r=function(e,t){Xa("u",e,jc,n),Xa("scalar",t,f,m);const r=t,s=e;let o=Gc,a=jc,c=e,l=Gc,h=jc;for(let e=BigInt(u-1);e>=jc;e--){const t=r>>e&Gc;h^=t,({x_2:o,x_3:c}=S(h,o,c)),({x_2:a,x_3:l}=S(h,a,l)),h=t;const n=o+a,i=y(n*n),u=o-a,d=y(u*u),f=i-d,g=c+l,m=y((c-l)*n),b=y(g*u),w=m+b,v=m-b;c=y(w*w),l=y(s*y(v*v)),o=y(i*d),a=y(f*(i+y(p*f)))}({x_2:o,x_3:c}=S(h,o,c)),({x_2:a,x_3:l}=S(h,a,l));const d=i(a);return y(o*d)}(function(e){const t=ja("u coordinate",e,h);return c&&(t[31]&=127),y(Ka(t))}(t),function(e){return Ka(o(ja("scalar",e,h)))}(e));if(r===jc)throw Error("invalid private or public key received");return w(r)}function E(e){return v(e,b)}function S(e,t,r){const n=y(e*(t-r));return{x_2:t=y(t-n),x_3:r=y(r+n)}}const A={secretKey:h,publicKey:h,seed:h},C=(e=l(h))=>(ir(e,A.seed),e);const I={randomSecretKey:C,randomPrivateKey:C};return{keygen(e){const t=C(e);return{secretKey:t,publicKey:E(t)}},getSharedSecret(e,t){return v(e,t)},getPublicKey(e){return E(e)},scalarMult:v,scalarMultBase:E,utils:I,GuBytes:b.slice(),lengths:A}}const Zc=BigInt(1),Yc=BigInt(2),Qc=BigInt(3),Jc=BigInt(5),el=BigInt(8),tl=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),rl=(()=>({p:tl,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:el,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")}))();function nl(e){const t=BigInt(10),r=BigInt(20),n=BigInt(40),s=BigInt(80),o=tl,i=e*e%o*e%o,a=hc(i,Yc,o)*i%o,c=hc(a,Zc,o)*e%o,l=hc(c,Jc,o)*c%o,u=hc(l,t,o)*l%o,h=hc(u,r,o)*u%o,d=hc(h,n,o)*h%o,p=hc(d,s,o)*d%o,f=hc(p,s,o)*d%o,g=hc(f,t,o)*l%o;return{pow_p_5_8:hc(g,Yc,o)*e%o,b2:i}}function sl(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const ol=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function il(e,t){const r=tl,n=uc(t*t*t,r),s=uc(n*n*t,r);let o=uc(e*n*nl(e*s).pow_p_5_8,r);const i=uc(t*o*o,r),a=o,c=uc(o*ol,r),l=i===e,u=i===uc(-e,r),h=i===uc(-e*ol,r);return l&&(o=a),(u||h)&&(o=c),(uc(o,r)&tc)===tc&&(o=uc(-o,r)),{isValid:l||u,value:o}}const al=(()=>Sc(rl.p,{isLE:!0}))(),cl=(()=>({...rl,Fp:al,hash:sn,adjustScalarBytes:sl,uvRatio:il}))(),ll=(()=>Hc(cl))(),ul=(()=>{const e=al.ORDER;return Xc({P:e,type:"x25519",powPminus2(t){const{pow_p_5_8:r,b2:n}=nl(t);return uc(hc(r,Qc,e)*n,e)},adjustScalarBytes:sl})})();class hl extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class dl extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}var pl={get(e=globalThis){const t=e.crypto;if(null==t?.subtle)throw new dl("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}};let fl;const gl=(async()=>{try{return await pl.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function ml(){const e=ll.utils.randomPrivateKey(),t=ll.getPublicKey(e),r=function(e,t){const r=new Uint8Array(64);for(let n=0;n<32;n++)r[n]=e[n],r[32+n]=t[n];return r}(e,t);return{privateKey:r,publicKey:t}}async function yl(e,t){return null==fl&&(fl=await gl),fl?async function(e,t){let r;r=64===e.length?e.subarray(0,32):e;const n={crv:"Ed25519",kty:"OKP",x:mn(e.subarray(32),"base64url"),d:mn(r,"base64url"),ext:!0,key_ops:["sign"]},s=await pl.get().subtle.importKey("jwk",n,{name:"Ed25519"},!0,["sign"]),o=await pl.get().subtle.sign({name:"Ed25519"},s,t instanceof Uint8Array?t:t.subarray());return new Uint8Array(o,0,o.byteLength)}(e,t):function(e,t){const r=e.subarray(0,32);return ll.sign(t instanceof Uint8Array?t:t.subarray(),r)}(e,t)}async function bl(e,t,r){return null==fl&&(fl=await gl),fl?async function(e,t,r){if(e.buffer instanceof ArrayBuffer){const n=await pl.get().subtle.importKey("raw",e.buffer,{name:"Ed25519"},!1,["verify"]);return await pl.get().subtle.verify({name:"Ed25519"},n,t,r instanceof Uint8Array?r:r.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}(e,t,r):function(e,t,r){return ll.verify(t,r instanceof Uint8Array?r:r.subarray(),e)}(e,t,r)}function wl(e){return null!=e&&("function"==typeof e.then&&"function"==typeof e.catch&&"function"==typeof e.finally)}class vl{type="Ed25519";raw;constructor(e){this.raw=Al(e,32)}toMultihash(){return Be.digest(iu(this))}toCID(){return He.createV1(114,this.toMultihash())}toString(){return he.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&Jn(this.raw,e.raw)}verify(e,t,r){r?.signal?.throwIfAborted();const n=bl(this.raw,t,e);return wl(n)?n.then((e=>(r?.signal?.throwIfAborted(),e))):n}}class El{type="Ed25519";raw;publicKey;constructor(e,t){this.raw=Al(e,64),this.publicKey=new vl(t)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&Jn(this.raw,e.raw)}sign(e,t){t?.signal?.throwIfAborted();const r=yl(this.raw,e);return wl(r)?r.then((e=>(t?.signal?.throwIfAborted(),e))):(t?.signal?.throwIfAborted(),r)}}function Sl(e){return e=Al(e,32),new vl(e)}function Al(e,t){if((e=Uint8Array.from(e??[])).length!==t)throw new yo(`Key must be a Uint8Array of length ${t}, got ${e.length}`);return e}var Cl,Il,xl,kl;function Pl(e){if(isNaN(e)||e<=0)throw new yo("random bytes length must be a Number bigger than 0");return kr(e)}(e=>{e.RSA="RSA",e.Ed25519="Ed25519",e.secp256k1="secp256k1",e.ECDSA="ECDSA"})(Cl||(Cl={})),(e=>{e[e.RSA=0]="RSA",e[e.Ed25519=1]="Ed25519",e[e.secp256k1=2]="secp256k1",e[e.ECDSA=3]="ECDSA"})(Il||(Il={})),(e=>{e.codec=()=>Xt(Il)})(Cl||(Cl={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),Cl.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.Type=Cl.codec().decode(e);break;case 2:r.Data=e.bytes();break;default:e.skipType(7&t)}}return r}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(xl||(xl={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),Cl.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.Type=Cl.codec().decode(e);break;case 2:r.Data=e.bytes();break;default:e.skipType(7&t)}}return r}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(kl||(kl={}));class Tl{type="RSA";jwk;_raw;_multihash;constructor(e,t){this.jwk=e,this._multihash=t}get raw(){return null==this._raw&&(this._raw=function(e){if(null==e.n||null==e.e)throw new yo("JWK was missing components");return Ia([_l,Ca(Ia([Aa(tt(e.n,"base64url")),Aa(tt(e.e,"base64url"))]))]).subarray()}(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return He.createV1(114,this._multihash)}toString(){return he.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&Jn(this.raw,e.raw)}verify(e,t,r){return async function(e,t,r,n){const s=await pl.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);n?.signal?.throwIfAborted();const o=await pl.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},s,t,r instanceof Uint8Array?r:r.subarray());return n?.signal?.throwIfAborted(),o}(this.jwk,t,e,r)}}const _l=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function Rl(e,t,r){const n=function(e){const t=wa(e[1],{offset:0});return{kty:"RSA",n:mn(t[0],"base64url"),e:mn(t[1],"base64url")}}(e);if(null==r){r=Me(18,on(xl.encode({Type:Cl.RSA,Data:t})))}return new Tl(n,r)}class Ll extends Ir{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,ar(e);const r=Ar(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(r.length>n?e.create().update(r).digest():r);for(let e=0;e<s.length;e++)s[e]^=54;this.iHash.update(s),this.oHash=e.create();for(let e=0;e<s.length;e++)s[e]^=106;this.oHash.update(s),lr(s)}update(e){return cr(this),this.iHash.update(e),this}digestInto(e){cr(this),ir(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:n,destroyed:s,blockLen:o,outputLen:i}=this;return e.finished=n,e.destroyed=s,e.blockLen=o,e.outputLen=i,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Dl=(e,t,r)=>new Ll(e,t).update(r).digest();Dl.create=(e,t)=>new Ll(e,t);const Nl=(e,t)=>(e+(e>=0?t:-t)/ql)/t;function Ml(e){if(!["compact","recovered","der"].includes(e))throw Error('Signature format must be "compact", "recovered", or "der"');return e}function Ol(e,t){const r={};for(let n of Object.keys(t))r[n]=void 0===e[n]?t[n]:e[n];return Ua(r.lowS,"lowS"),Ua(r.prehash,"prehash"),void 0!==r.format&&Ml(r.format),r}const Fl={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode(e,t){const{Err:r}=Fl;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(1&t.length)throw new r("tlv.encode: unpadded data");const n=t.length/2,s=qa(n);if(s.length/2&128)throw new r("tlv.encode: long form length too big");const o=n>127?qa(s.length/2|128):"";return qa(e)+o+s+t},decode(e,t){const{Err:r}=Fl;let n=0;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(t.length<2||t[n++]!==e)throw new r("tlv.decode: wrong tlv");const s=t[n++];let o=0;if(!!(128&s)){const e=127&s;if(!e)throw new r("tlv.decode(long): indefinite length not supported");if(e>4)throw new r("tlv.decode(long): byte length is too big");const i=t.subarray(n,n+e);if(i.length!==e)throw new r("tlv.decode: length bytes not complete");if(0===i[0])throw new r("tlv.decode(long): zero leftmost byte");for(const e of i)o=o<<8|e;if(n+=e,o<128)throw new r("tlv.decode(long): not minimal encoding")}else o=s;const i=t.subarray(n,n+o);if(i.length!==o)throw new r("tlv.decode: wrong value length");return{v:i,l:t.subarray(n+o)}}},_int:{encode(e){const{Err:t}=Fl;if(e<Ul)throw new t("integer: negative integers are not allowed");let r=qa(e);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new t("unexpected DER parsing assertion: unpadded hex");return r},decode(e){const{Err:t}=Fl;if(128&e[0])throw new t("invalid signature integer: negative");if(0===e[0]&&!(128&e[1]))throw new t("invalid signature integer: unnecessary leading zero");return za(e)}},toSig(e){const{Err:t,_int:r,_tlv:n}=Fl,s=ja("signature",e),{v:o,l:i}=n.decode(48,s);if(i.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,o),{v:l,l:u}=n.decode(2,c);if(u.length)throw new t("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(l)}},hexFromSig(e){const{_tlv:t,_int:r}=Fl,n=t.encode(2,r.encode(e.r))+t.encode(2,r.encode(e.s));return t.encode(48,n)}},Ul=BigInt(0),Bl=BigInt(1),ql=BigInt(2),$l=BigInt(3),zl=BigInt(4);function Kl(e,t){const{BYTES:r}=e;let n;if("bigint"==typeof t)n=t;else{let s=ja("private key",t);try{n=e.fromBytes(s)}catch(e){throw Error(`invalid private key: expected ui8a of size ${r}, got ${typeof t}`)}}if(!e.isValidNot0(n))throw Error("invalid private key: out of range [1..N-1]");return n}function Vl(e,t={}){const r=Bc("weierstrass",e,t),{Fp:n,Fn:s}=r;let o=r.CURVE;const{h:i,n:a}=o;Qa(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:c}=t;if(c&&(!n.is0(o.a)||"bigint"!=typeof c.beta||!Array.isArray(c.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');const l=jl(n,s);function u(){if(!n.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}const h=t.toBytes||function(e,t,r){const{x:s,y:o}=t.toAffine(),i=n.toBytes(s);if(Ua(r,"isCompressed"),r){u();return Cr(Hl(!n.isOdd(o)),i)}return Cr(Uint8Array.of(4),i,n.toBytes(o))},d=t.fromBytes||function(e){Ba(e,void 0,"Point");const{publicKey:t,publicKeyUncompressed:r}=l,s=e.length,o=e[0],i=e.subarray(1);if(s!==t||2!==o&&3!==o){if(s===r&&4===o){const e=n.BYTES,t=n.fromBytes(i.subarray(0,e)),r=n.fromBytes(i.subarray(e,2*e));if(!f(t,r))throw Error("bad point: is not on curve");return{x:t,y:r}}throw Error(`bad point: got length ${s}, expected compressed=${t} or uncompressed=${r}`)}{const e=n.fromBytes(i);if(!n.isValid(e))throw Error("bad point: is not on curve, wrong x");const t=p(e);let r;try{r=n.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw Error("bad point: is not on curve, sqrt error"+t)}u();return!(1&~o)!==n.isOdd(r)&&(r=n.neg(r)),{x:e,y:r}}};function p(e){const t=n.sqr(e),r=n.mul(t,e);return n.add(n.add(r,n.mul(e,o.a)),o.b)}function f(e,t){const r=n.sqr(t),s=p(e);return n.eql(r,s)}if(!f(o.Gx,o.Gy))throw Error("bad curve params: generator point");const g=n.mul(n.pow(o.a,$l),zl),m=n.mul(n.sqr(o.b),BigInt(27));if(n.is0(n.add(g,m)))throw Error("bad curve params: a or b");function y(e,t,r=!1){if(!n.isValid(t)||r&&n.is0(t))throw Error("bad point coordinate "+e);return t}function b(e){if(!(e instanceof A))throw Error("ProjectivePoint expected")}function w(e){if(!c||!c.basises)throw Error("no endo");return function(e,t,r){const[[n,s],[o,i]]=t,a=Nl(i*e,r),c=Nl(-s*e,r);let l=e-a*n-c*o,u=-a*s-c*i;const h=l<Ul,d=u<Ul;h&&(l=-l),d&&(u=-u);const p=Ya(Math.ceil(Za(r)/2))+Bl;if(l<Ul||l>=p||u<Ul||u>=p)throw Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:h,k1:l,k2neg:d,k2:u}}(e,c.basises,s.ORDER)}const v=Ja(((e,t)=>{const{X:r,Y:s,Z:o}=e;if(n.eql(o,n.ONE))return{x:r,y:s};const i=e.is0();null==t&&(t=i?n.ONE:n.inv(o));const a=n.mul(r,t),c=n.mul(s,t),l=n.mul(o,t);if(i)return{x:n.ZERO,y:n.ZERO};if(!n.eql(l,n.ONE))throw Error("invZ was invalid");return{x:a,y:c}})),E=Ja((e=>{if(e.is0()){if(t.allowInfinityPoint&&!n.is0(e.Y))return;throw Error("bad point: ZERO")}const{x:r,y:s}=e.toAffine();if(!n.isValid(r)||!n.isValid(s))throw Error("bad point: x or y not field elements");if(!f(r,s))throw Error("bad point: equation left != right");if(!e.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0}));function S(e,t,r,s,o){return r=new A(n.mul(r.X,e),r.Y,r.Z),t=kc(s,t),r=kc(o,r),t.add(r)}class A{constructor(e,t,r){this.X=y("x",e),this.Y=y("y",t,!0),this.Z=y("z",r),Object.freeze(this)}static CURVE(){return o}static fromAffine(e){const{x:t,y:r}=e||{};if(!e||!n.isValid(t)||!n.isValid(r))throw Error("invalid affine point");if(e instanceof A)throw Error("projective point not allowed");return n.is0(t)&&n.is0(r)?A.ZERO:new A(t,r,n.ONE)}static fromBytes(e){const t=A.fromAffine(d(Ba(e,void 0,"point")));return t.assertValidity(),t}static fromHex(e){return A.fromBytes(ja("pointHex",e))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(e=8,t=!0){return I.createCache(this,e),t||this.multiply($l),this}assertValidity(){E(this)}hasEvenY(){const{y:e}=this.toAffine();if(!n.isOdd)throw Error("Field doesn't support isOdd");return!n.isOdd(e)}equals(e){b(e);const{X:t,Y:r,Z:s}=this,{X:o,Y:i,Z:a}=e,c=n.eql(n.mul(t,a),n.mul(o,s)),l=n.eql(n.mul(r,a),n.mul(i,s));return c&&l}negate(){return new A(this.X,n.neg(this.Y),this.Z)}double(){const{a:e,b:t}=o,r=n.mul(t,$l),{X:s,Y:i,Z:a}=this;let c=n.ZERO,l=n.ZERO,u=n.ZERO,h=n.mul(s,s),d=n.mul(i,i),p=n.mul(a,a),f=n.mul(s,i);return f=n.add(f,f),u=n.mul(s,a),u=n.add(u,u),c=n.mul(e,u),l=n.mul(r,p),l=n.add(c,l),c=n.sub(d,l),l=n.add(d,l),l=n.mul(c,l),c=n.mul(f,c),u=n.mul(r,u),p=n.mul(e,p),f=n.sub(h,p),f=n.mul(e,f),f=n.add(f,u),u=n.add(h,h),h=n.add(u,h),h=n.add(h,p),h=n.mul(h,f),l=n.add(l,h),p=n.mul(i,a),p=n.add(p,p),h=n.mul(p,f),c=n.sub(c,h),u=n.mul(p,d),u=n.add(u,u),u=n.add(u,u),new A(c,l,u)}add(e){b(e);const{X:t,Y:r,Z:s}=this,{X:i,Y:a,Z:c}=e;let l=n.ZERO,u=n.ZERO,h=n.ZERO;const d=o.a,p=n.mul(o.b,$l);let f=n.mul(t,i),g=n.mul(r,a),m=n.mul(s,c),y=n.add(t,r),w=n.add(i,a);y=n.mul(y,w),w=n.add(f,g),y=n.sub(y,w),w=n.add(t,s);let v=n.add(i,c);return w=n.mul(w,v),v=n.add(f,m),w=n.sub(w,v),v=n.add(r,s),l=n.add(a,c),v=n.mul(v,l),l=n.add(g,m),v=n.sub(v,l),h=n.mul(d,w),l=n.mul(p,m),h=n.add(l,h),l=n.sub(g,h),h=n.add(g,h),u=n.mul(l,h),g=n.add(f,f),g=n.add(g,f),m=n.mul(d,m),w=n.mul(p,w),g=n.add(g,m),m=n.sub(f,m),m=n.mul(d,m),w=n.add(w,m),f=n.mul(g,w),u=n.add(u,f),f=n.mul(v,w),l=n.mul(y,l),l=n.sub(l,f),f=n.mul(y,g),h=n.mul(v,h),h=n.add(h,f),new A(l,u,h)}subtract(e){return this.add(e.negate())}is0(){return this.equals(A.ZERO)}multiply(e){const{endo:r}=t;if(!s.isValidNot0(e))throw Error("invalid scalar: out of range");let n,o;const i=e=>I.cached(this,e,(e=>Pc(A,e)));if(r){const{k1neg:t,k1:s,k2neg:a,k2:c}=w(e),{p:l,f:u}=i(s),{p:h,f:d}=i(c);o=u.add(d),n=S(r.beta,l,h,t,a)}else{const{p:t,f:r}=i(e);n=t,o=r}return Pc(A,[n,o])[0]}multiplyUnsafe(e){const{endo:r}=t,n=this;if(!s.isValid(e))throw Error("invalid scalar: out of range");if(e===Ul||n.is0())return A.ZERO;if(e===Bl)return n;if(I.hasCache(this))return this.multiply(e);if(r){const{k1neg:t,k1:s,k2neg:o,k2:i}=w(e),{p1:a,p2:c}=function(e,t,r,n){let s=t,o=e.ZERO,i=e.ZERO;for(;r>Ic||n>Ic;)r&xc&&(o=o.add(s)),n&xc&&(i=i.add(s)),s=s.double(),r>>=xc,n>>=xc;return{p1:o,p2:i}}(A,n,s,i);return S(r.beta,a,c,t,o)}return I.unsafe(n,e)}multiplyAndAddUnsafe(e,t,r){const n=this.multiplyUnsafe(t).add(e.multiplyUnsafe(r));return n.is0()?void 0:n}toAffine(e){return v(this,e)}isTorsionFree(){const{isTorsionFree:e}=t;return i===Bl||(e?e(A,this):I.unsafe(this,a).is0())}clearCofactor(){const{clearCofactor:e}=t;return i===Bl?this:e?e(A,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(e=!0){return Ua(e,"isCompressed"),this.assertValidity(),h(A,this,e)}toHex(e=!0){return fr(this.toBytes(e))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(e=!0){return this.toBytes(e)}_setWindowSize(e){this.precompute(e)}static normalizeZ(e){return Pc(A,e)}static msm(e,t){return Fc(A,s,e,t)}static fromPrivateKey(e){return A.BASE.multiply(Kl(s,e))}}A.BASE=new A(o.Gx,o.Gy,n.ONE),A.ZERO=new A(n.ZERO,n.ONE,n.ZERO),A.Fp=n,A.Fn=s;const C=s.BITS,I=new Oc(A,t.endo?Math.ceil(C/2):C);return A.BASE.precompute(8),A}function Hl(e){return Uint8Array.of(e?2:3)}function jl(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function Gl(e,t={}){const{Fn:r}=e,n=t.randomBytes||kr,s=Object.assign(jl(e.Fp,r),{seed:Cc(r.ORDER)});function o(e){try{return!!Kl(r,e)}catch(e){return!1}}function i(e=n(s.seed)){return function(e,t,r=!1){const n=e.length,s=Ac(t),o=Cc(t);if(n<16||n<o||n>1024)throw Error("expected "+o+"-1024 bytes of input, got "+n);const i=uc(r?Ka(e):za(e),t-tc)+tc;return r?Ha(i,s):Va(i,s)}(Ba(e,s.seed,"seed"),r.ORDER)}function a(t,n=!0){return e.BASE.multiply(Kl(r,t)).toBytes(n)}function c(t){if("bigint"==typeof t)return!1;if(t instanceof e)return!0;const{secretKey:n,publicKey:o,publicKeyUncompressed:i}=s;if(r.allowedLengths||n===o)return;const a=ja("key",t).length;return a===o||a===i}const l={isValidSecretKey:o,isValidPublicKey(t,r){const{publicKey:n,publicKeyUncompressed:o}=s;try{const s=t.length;return(!0!==r||s===n)&&((!1!==r||s===o)&&!!e.fromBytes(t))}catch(e){return!1}},randomSecretKey:i,isValidPrivateKey:o,randomPrivateKey:i,normPrivateKeyToScalar(e){return Kl(r,e)},precompute:(t=8,r=e.BASE)=>r.precompute(t,!1)};return Object.freeze({getPublicKey:a,getSharedSecret(t,n,s=!0){if(!0===c(t))throw Error("first arg must be private key");if(!1===c(n))throw Error("second arg must be public key");const o=Kl(r,t);return e.fromHex(n).multiply(o).toBytes(s)},keygen(e){const t=i(e);return{secretKey:t,publicKey:a(t)}},Point:e,utils:l,lengths:s})}function Wl(e,t,r={}){ar(t),Qa(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const n=r.randomBytes||kr,s=r.hmac||((e,...r)=>Dl(t,e,Cr(...r))),{Fp:o,Fn:i}=e,{ORDER:a,BITS:c}=i,{keygen:l,getPublicKey:u,getSharedSecret:h,utils:d,lengths:p}=Gl(e,r),f={prehash:!1,lowS:"boolean"==typeof r.lowS&&r.lowS,format:void 0,extraEntropy:!1},g="compact";function m(e){return e>a>>Bl}function y(e,t){if(!i.isValidNot0(t))throw Error(`invalid signature ${e}: out of range 1..Point.Fn.ORDER`);return t}class b{constructor(e,t,r){this.r=y("r",e),this.s=y("s",t),null!=r&&(this.recovery=r),Object.freeze(this)}static fromBytes(e,t=g){let r;if(function(e,t){Ml(t);const r=p.signature;Ba(e,"compact"===t?r:"recovered"===t?r+1:void 0,t+" signature")}(e,t),"der"===t){const{r:t,s:r}=Fl.toSig(Ba(e));return new b(t,r)}"recovered"===t&&(r=e[0],t="compact",e=e.subarray(1));const n=i.BYTES,s=e.subarray(0,n),o=e.subarray(n,2*n);return new b(i.fromBytes(s),i.fromBytes(o),r)}static fromHex(e,t){return this.fromBytes(Sr(e),t)}addRecoveryBit(e){return new b(this.r,this.s,e)}recoverPublicKey(t){const r=o.ORDER,{r:n,s,recovery:c}=this;if(null==c||![0,1,2,3].includes(c))throw Error("recovery id invalid");if(a*ql<r&&c>1)throw Error("recovery id is ambiguous for h>1 curve");const l=2===c||3===c?n+a:n;if(!o.isValid(l))throw Error("recovery id 2 or 3 invalid");const u=o.toBytes(l),h=e.fromBytes(Cr(Hl(!(1&c)),u)),d=i.inv(l),p=v(ja("msgHash",t)),f=i.create(-p*d),g=i.create(s*d),m=e.BASE.multiplyUnsafe(f).add(h.multiplyUnsafe(g));if(m.is0())throw Error("point at infinify");return m.assertValidity(),m}hasHighS(){return m(this.s)}toBytes(e=g){if(Ml(e),"der"===e)return Sr(Fl.hexFromSig(this));const t=i.toBytes(this.r),r=i.toBytes(this.s);if("recovered"===e){if(null==this.recovery)throw Error("recovery bit must be present");return Cr(Uint8Array.of(this.recovery),t,r)}return Cr(t,r)}toHex(e){return fr(this.toBytes(e))}assertValidity(){}static fromCompact(e){return b.fromBytes(ja("sig",e),"compact")}static fromDER(e){return b.fromBytes(ja("sig",e),"der")}normalizeS(){return this.hasHighS()?new b(this.r,i.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return fr(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return fr(this.toBytes("compact"))}}const w=r.bits2int||function(e){if(e.length>8192)throw Error("input is too large");const t=za(e),r=8*e.length-c;return r>0?t>>BigInt(r):t},v=r.bits2int_modN||function(e){return i.create(w(e))},E=Ya(c);function S(e){return Xa("num < 2^"+c,e,Ul,E),i.toBytes(e)}function A(e,r){return Ba(e,void 0,"message"),r?Ba(t(e),void 0,"prehashed message"):e}return Object.freeze({keygen:l,getPublicKey:u,getSharedSecret:h,utils:d,lengths:p,Point:e,sign(r,o,a={}){r=ja("message",r);const{seed:c,k2sig:l}=function(t,r,s){if(["recovered","canonical"].some((e=>e in s)))throw Error("sign() legacy options not supported");const{lowS:o,prehash:a,extraEntropy:c}=Ol(s,f);t=A(t,a);const l=v(t),u=Kl(i,r),h=[S(u),S(l)];if(null!=c&&!1!==c){const e=!0===c?n(p.secretKey):c;h.push(ja("extraEntropy",e))}const d=Cr(...h),g=l;return{seed:d,k2sig(t){const r=w(t);if(!i.isValidNot0(r))return;const n=i.inv(r),s=e.BASE.multiply(r).toAffine(),a=i.create(s.x);if(a===Ul)return;const c=i.create(n*i.create(g+a*u));if(c===Ul)return;let l=(s.x===a?0:2)|Number(s.y&Bl),h=c;return o&&m(c)&&(h=i.neg(c),l^=1),new b(a,h,l)}}}(r,o,a),u=function(e,t,r){if("number"!=typeof e||e<2)throw Error("hashLen must be a number");if("number"!=typeof t||t<2)throw Error("qByteLen must be a number");if("function"!=typeof r)throw Error("hmacFn must be a function");const n=e=>new Uint8Array(e),s=e=>Uint8Array.of(e);let o=n(e),i=n(e),a=0;const c=()=>{o.fill(1),i.fill(0),a=0},l=(...e)=>r(i,o,...e),u=(e=n(0))=>{i=l(s(0),e),o=l(),0!==e.length&&(i=l(s(1),e),o=l())},h=()=>{if(a++>=1e3)throw Error("drbg: tried 1000 values");let e=0;const r=[];for(;e<t;){o=l();const t=o.slice();r.push(t),e+=o.length}return Cr(...r)};return(e,t)=>{let r;for(c(),u(e);!(r=t(h()));)u();return c(),r}}(t.outputLen,i.BYTES,s);return u(c,l)},verify(t,r,n,s={}){const{lowS:o,prehash:a,format:c}=Ol(s,f);if(n=ja("publicKey",n),r=A(ja("message",r),a),"strict"in s)throw Error("options.strict was renamed to lowS");const l=void 0===c?function(e){let t;const r="string"==typeof e||sr(e),n=!r&&null!==e&&"object"==typeof e&&"bigint"==typeof e.r&&"bigint"==typeof e.s;if(!r&&!n)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(n)t=new b(e.r,e.s);else if(r){try{t=b.fromBytes(ja("sig",e),"der")}catch(e){if(!(e instanceof Fl.Err))throw e}if(!t)try{t=b.fromBytes(ja("sig",e),"compact")}catch(e){return!1}}return t||!1}(t):b.fromBytes(ja("sig",t),c);if(!1===l)return!1;try{const t=e.fromBytes(n);if(o&&l.hasHighS())return!1;const{r:s,s:a}=l,c=v(r),u=i.inv(a),h=i.create(c*u),d=i.create(s*u),p=e.BASE.multiplyUnsafe(h).add(t.multiplyUnsafe(d));if(p.is0())return!1;return i.create(p.x)===s}catch(e){return!1}},recoverPublicKey(e,t,r={}){const{prehash:n}=Ol(r,f);return t=A(t,n),b.fromBytes(e,"recovered").recoverPublicKey(t).toBytes()},Signature:b,hash:t})}function Xl(e){const{CURVE:t,curveOpts:r}=function(e){const t={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},r=e.Fp;let n=e.allowedPrivateKeyLengths?Array.from(new Set(e.allowedPrivateKeyLengths.map((e=>Math.ceil(e/2))))):void 0;return{CURVE:t,curveOpts:{Fp:r,Fn:Sc(t.n,{BITS:e.nBitLength,allowedLengths:n,modFromBytes:e.wrapPrivateKey}),allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes}}}(e),n={hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:t,curveOpts:r,hash:e.hash,ecdsaOpts:n}}function Zl(e){const{CURVE:t,curveOpts:r,hash:n,ecdsaOpts:s}=Xl(e);return function(e,t){const r=t.Point;return Object.assign({},t,{ProjectivePoint:r,CURVE:Object.assign({},e,Ec(r.Fn.ORDER,r.Fn.BITS))})}(e,Wl(Vl(t,r),n,s))}const Yl={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Ql={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Jl=BigInt(2);const eu=Sc(Yl.p,{sqrt(e){const t=Yl.p,r=BigInt(3),n=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),l=e*e*e%t,u=l*l*e%t,h=hc(u,r,t)*u%t,d=hc(h,r,t)*u%t,p=hc(d,Jl,t)*l%t,f=hc(p,s,t)*p%t,g=hc(f,o,t)*f%t,m=hc(g,a,t)*g%t,y=hc(m,c,t)*m%t,b=hc(y,a,t)*g%t,w=hc(b,r,t)*u%t,v=hc(w,i,t)*f%t,E=hc(v,n,t)*l%t,S=hc(E,Jl,t);if(!eu.eql(eu.sqr(S),e))throw Error("Cannot find square root");return S}}),tu=function(e,t){const r=t=>Zl({...e,hash:t});return{...r(t),create:r}}({...Yl,Fp:eu,lowS:!0,endo:Ql},nn);class ru{type="secp256k1";raw;_key;constructor(e){this._key=function(e){try{return tu.ProjectivePoint.fromHex(e),e}catch(e){throw new bo(e+"")}}(e),this.raw=function(e){const t=tu.ProjectivePoint.fromHex(e).toRawBytes(!0);return t}(this._key)}toMultihash(){return Be.digest(iu(this))}toCID(){return He.createV1(114,this.toMultihash())}toString(){return he.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&Jn(this.raw,e.raw)}verify(e,t,r){return function(e,t,r,n){const s=$e.digest(r instanceof Uint8Array?r:r.subarray());if(wl(s))return s.then((({digest:r})=>(n?.signal?.throwIfAborted(),tu.verify(t,r,e)))).catch((e=>{if("AbortError"===e.name)throw e;throw new hl(e+"")}));try{return n?.signal?.throwIfAborted(),tu.verify(t,s.digest,e)}catch(e){throw new hl(e+"")}}(this._key,t,e,r)}}function nu(e){return new ru(e)}async function su(){return async function(){const{privateKey:e,publicKey:t}=ml();return new El(e,t)}()}function ou(e,t){const{Type:r,Data:n}=xl.decode(e),s=n??new Uint8Array;switch(r){case Cl.RSA:return function(e,t){if(e.byteLength>=1062)throw new bo("Key size is too large");return Rl(wa(e,{offset:0}),e,t)}(s,t);case Cl.Ed25519:return Sl(s);case Cl.secp256k1:return nu(s);case Cl.ECDSA:return La(s);default:throw new Bo}}function iu(e){return xl.encode({Type:Cl[e.type],Data:e.raw})}const au=Symbol.for("nodejs.util.inspect.custom");class cu{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[co]=!0;toString(){return null==this.string&&(this.string=he.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return He.createV1(114,this.multihash)}toJSON(){return this.toString()}equals(e){if(null==e)return!1;if(e instanceof Uint8Array)return Jn(this.multihash.bytes,e);if("string"==typeof e)return this.toString()===e;if(null!=e?.toMultihash()?.bytes)return Jn(this.multihash.bytes,e.toMultihash().bytes);throw Error("not valid Id")}[au](){return`PeerId(${this.toString()})`}}class lu extends cu{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}}class uu extends cu{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}}class hu extends cu{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}}class du{type="url";multihash;publicKey;url;constructor(e){this.url=e.toString(),this.multihash=Be.digest(tt(this.url))}[au](){return`PeerId(${this.url})`}[co]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return He.createV1(2336,this.toMultihash())}toJSON(){return this.toString()}equals(e){return null!=e&&(e instanceof Uint8Array&&(e=mn(e)),e.toString()===this.toString())}}function pu(e){let t;if("1"!==e.charAt(0)&&"Q"!==e.charAt(0)){if(e.startsWith("k51qzi5uqu5")||e.startsWith("kzwfwjn5ji4")||e.startsWith("k2k4r8")||e.startsWith("bafz"))return mu(He.parse(e));throw new yo('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return t=Oe(he.decode("z"+e)),gu(t)}function fu(e){if("Ed25519"===e.type)return new uu({multihash:e.toCID().multihash,publicKey:e});if("secp256k1"===e.type)return new hu({multihash:e.toCID().multihash,publicKey:e});if("RSA"===e.type)return new lu({multihash:e.toCID().multihash,publicKey:e});throw new Bo}function gu(e){if(function(e){return e.code===$e.code}(e))return new lu({multihash:e});if(function(e){return e.code===Be.code}(e))try{const t=function(e){const{Type:t,Data:r}=xl.decode(e.digest),n=r??new Uint8Array;switch(t){case Cl.Ed25519:return Sl(n);case Cl.secp256k1:return nu(n);case Cl.ECDSA:return La(n);default:throw new Bo}}(e);if("Ed25519"===t.type)return new uu({multihash:e,publicKey:t});if("secp256k1"===t.type)return new hu({multihash:e,publicKey:t})}catch(t){const r=mn(e.digest);return new du(new URL(r))}throw new To("Supplied PeerID Multihash is invalid")}function mu(e){if(null==e?.multihash||null==e.version||1===e.version&&114!==e.code&&2336!==e.code)throw new Po("Supplied PeerID CID is invalid");if(2336===e.code){const t=mn(e.multihash.digest);return new du(new URL(t))}return gu(e.multihash)}let yu=class{readNext;haveNext;ended;nextResult;constructor(){this.ended=!1,this.readNext=fs(),this.haveNext=fs()}[Symbol.asyncIterator](){return this}async next(){if(null==this.nextResult&&await this.haveNext.promise,null==this.nextResult)throw Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=fs(),e}async throw(e){this.ended=!0,null!=e&&(this.haveNext.promise.catch((()=>{})),this.haveNext.reject(e));return{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){null!=e?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(null!=e&&this.ended)throw Error("Cannot push value onto an ended pushable");for(;null!=this.nextResult;)await this.readNext.promise;null!=e?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=fs(),await vs(this.readNext.promise,t?.signal,t)}};let bu=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"},wu=class extends Error{code;constructor(e,t){super(e),this.code=t}},vu=class extends wu{type;constructor(e){super(e,"ABORT_ERR"),this.type="aborted",this.name="AbortError"}};function Eu(e,t){const r=new yu;e.sink(r).catch((async e=>{await r.end(e)})),e.sink=async e=>{for await(const t of e)await r.push(t);await r.end()};let n=e.source;null!=e.source[Symbol.iterator]?n=e.source[Symbol.iterator]():null!=e.source[Symbol.asyncIterator]&&(n=e.source[Symbol.asyncIterator]());const s=new ns,o={async read(e,t){let r;t?.signal?.throwIfAborted();const o=new Promise(((e,n)=>{r=()=>{n(new vu("Read aborted"))},t?.signal?.addEventListener("abort",r)}));try{if(null==e){const{done:e,value:t}=await Promise.race([n.next(),o]);return!0===e?new ns:t}for(;s.byteLength<e;){const{value:e,done:t}=await Promise.race([n.next(),o]);if(!0===t)throw new bu("unexpected end of input");s.append(e)}const t=s.sublist(0,e);return s.consume(e),t}finally{null!=r&&t?.signal?.removeEventListener("abort",r)}},async write(e,t){t?.signal?.throwIfAborted(),e instanceof Uint8Array?await r.push(e,t):await r.push(e.subarray(),t)},unwrap(){if(s.byteLength>0){const r=e.source;e.source=async function*(){!1===t?.yieldBytes?yield s:yield*s,yield*r}()}return e}};return o}let Su=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},Au=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},Cu=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"};function Iu(e,t={}){const r=Eu(e,t);null!=t.maxDataLength&&null==t.maxLengthLength&&(t.maxLengthLength=c(t.maxDataLength));const n=t?.lengthDecoder??d,s=t?.lengthEncoder??h;return{async read(e){let s=-1;const o=new ns;for(;;){o.append(await r.read(1,e));try{s=n(o)}catch(e){if(e instanceof RangeError)continue;throw e}if(s<0)throw new Su("Invalid message length");if(null!=t?.maxLengthLength&&o.byteLength>t.maxLengthLength)throw new Cu("message length length too long");if(s>-1)break}if(null!=t?.maxDataLength&&s>t.maxDataLength)throw new Au("message length too long");return r.read(s,e)},async write(e,t){await r.write(new ns(s(e.byteLength),e),t)},async writeV(e,t){const n=new ns(...e.flatMap((e=>[s(e.byteLength),e])));await r.write(n,t)},unwrap(){return r.unwrap()}}}function xu(){const e=fs();let t=!1;return{async sink(r){if(t)throw Error("already piped");t=!0,e.resolve(r)},source:async function*(){const t=await e.promise;yield*t}()}}const ku=65535,Pu=!!globalThis.process?.env?.DUMP_SESSION_KEYS;function Tu(e){if(!Number.isSafeInteger(e)||e<0)throw Error("positive integer expected, not "+e)}function _u(e){if("boolean"!=typeof e)throw Error("boolean expected, not "+e)}function Ru(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}function Lu(e,...t){if(!Ru(e))throw Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function Du(e,t=!0){if(e.destroyed)throw Error("Hash instance has been destroyed");if(t&&e.finished)throw Error("Hash#digest() has already been called")}const Nu=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4));if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw Error("Non little-endian hardware is not supported");function Mu(e){if("string"==typeof e)e=function(e){if("string"!=typeof e)throw Error("string expected, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e);else{if(!Ru(e))throw Error("Uint8Array expected, got "+typeof e);e=Uu(e)}return e}const Ou=(e,t)=>(Object.assign(t,e),t);function Fu(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const s=BigInt(32),o=BigInt(4294967295),i=Number(r>>s&o),a=Number(r&o);e.setUint32(t+4,i,n),e.setUint32(t+0,a,n)}function Uu(e){return Uint8Array.from(e)}function Bu(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}const qu=e=>Uint8Array.from(e.split("").map((e=>e.charCodeAt(0)))),$u=qu("expand 16-byte k"),zu=qu("expand 32-byte k"),Ku=Nu($u),Vu=Nu(zu);function Hu(e,t){return e<<t|e>>>32-t}function ju(e){return e.byteOffset%4==0}Vu.slice();const Gu=2**32-1,Wu=new Uint32Array;function Xu(e,t){const{allowShortKeys:r,extendNonceFn:n,counterLength:s,counterRight:o,rounds:i}=function(e,t){if(null==t||"object"!=typeof t)throw Error("options must be defined");return Object.assign(e,t)}({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if("function"!=typeof e)throw Error("core must be a function");return Tu(s),Tu(i),_u(o),_u(r),(t,a,c,l,u=0)=>{Lu(t),Lu(a),Lu(c);const h=c.length;if(void 0===l&&(l=new Uint8Array(h)),Lu(l),Tu(u),u<0||u>=Gu)throw Error("arx: counter overflow");if(l.length<h)throw Error(`arx: output (${l.length}) is shorter than data (${h})`);const d=[];let p,f,g=t.length;if(32===g)d.push(p=Uu(t)),f=Vu;else{if(16!==g||!r)throw Error("arx: invalid 32-byte key, got length="+g);p=new Uint8Array(32),p.set(t),p.set(t,16),f=Ku,d.push(p)}ju(a)||d.push(a=Uu(a));const m=Nu(p);if(n){if(24!==a.length)throw Error("arx: extended nonce must be 24 bytes");n(f,m,Nu(a.subarray(0,16)),m),a=a.subarray(16)}const y=16-s;if(y!==a.length)throw Error(`arx: nonce must be ${y} or 16 bytes`);if(12!==y){const e=new Uint8Array(12);e.set(a,o?0:12-a.length),a=e,d.push(a)}const b=Nu(a);return function(e,t,r,n,s,o,i,a){const c=s.length,l=new Uint8Array(64),u=Nu(l),h=ju(s)&&ju(o),d=h?Nu(s):Wu,p=h?Nu(o):Wu;for(let f=0;f<c;i++){if(e(t,r,n,u,i,a),i>=Gu)throw Error("arx: counter overflow");const g=Math.min(64,c-f);if(h&&64===g){const e=f/4;if(f%4!=0)throw Error("arx: invalid block position");for(let t,r=0;r<16;r++)t=e+r,p[t]=d[t]^u[r];f+=64}else{for(let e,t=0;t<g;t++)e=f+t,o[e]=s[e]^l[t];f+=g}}}(e,f,m,b,c,l,u,i),Bu(...d),l}}const Zu=(e,t)=>255&e[t++]|(255&e[t++])<<8;class Yu{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,Lu(e=Mu(e),32);const t=Zu(e,0),r=Zu(e,2),n=Zu(e,4),s=Zu(e,6),o=Zu(e,8),i=Zu(e,10),a=Zu(e,12),c=Zu(e,14);this.r[0]=8191&t,this.r[1]=8191&(t>>>13|r<<3),this.r[2]=7939&(r>>>10|n<<6),this.r[3]=8191&(n>>>7|s<<9),this.r[4]=255&(s>>>4|o<<12),this.r[5]=o>>>1&8190,this.r[6]=8191&(o>>>14|i<<2),this.r[7]=8065&(i>>>11|a<<5),this.r[8]=8191&(a>>>8|c<<8),this.r[9]=c>>>5&127;for(let t=0;t<8;t++)this.pad[t]=Zu(e,16+2*t)}process(e,t,r=!1){const n=r?0:2048,{h:s,r:o}=this,i=o[0],a=o[1],c=o[2],l=o[3],u=o[4],h=o[5],d=o[6],p=o[7],f=o[8],g=o[9],m=Zu(e,t+0),y=Zu(e,t+2),b=Zu(e,t+4),w=Zu(e,t+6),v=Zu(e,t+8),E=Zu(e,t+10),S=Zu(e,t+12),A=Zu(e,t+14);let C=s[0]+(8191&m),I=s[1]+(8191&(m>>>13|y<<3)),x=s[2]+(8191&(y>>>10|b<<6)),k=s[3]+(8191&(b>>>7|w<<9)),P=s[4]+(8191&(w>>>4|v<<12)),T=s[5]+(v>>>1&8191),_=s[6]+(8191&(v>>>14|E<<2)),R=s[7]+(8191&(E>>>11|S<<5)),L=s[8]+(8191&(S>>>8|A<<8)),D=s[9]+(A>>>5|n),N=0,M=N+C*i+I*(5*g)+x*(5*f)+k*(5*p)+P*(5*d);N=M>>>13,M&=8191,M+=T*(5*h)+_*(5*u)+R*(5*l)+L*(5*c)+D*(5*a),N+=M>>>13,M&=8191;let O=N+C*a+I*i+x*(5*g)+k*(5*f)+P*(5*p);N=O>>>13,O&=8191,O+=T*(5*d)+_*(5*h)+R*(5*u)+L*(5*l)+D*(5*c),N+=O>>>13,O&=8191;let F=N+C*c+I*a+x*i+k*(5*g)+P*(5*f);N=F>>>13,F&=8191,F+=T*(5*p)+_*(5*d)+R*(5*h)+L*(5*u)+D*(5*l),N+=F>>>13,F&=8191;let U=N+C*l+I*c+x*a+k*i+P*(5*g);N=U>>>13,U&=8191,U+=T*(5*f)+_*(5*p)+R*(5*d)+L*(5*h)+D*(5*u),N+=U>>>13,U&=8191;let B=N+C*u+I*l+x*c+k*a+P*i;N=B>>>13,B&=8191,B+=T*(5*g)+_*(5*f)+R*(5*p)+L*(5*d)+D*(5*h),N+=B>>>13,B&=8191;let q=N+C*h+I*u+x*l+k*c+P*a;N=q>>>13,q&=8191,q+=T*i+_*(5*g)+R*(5*f)+L*(5*p)+D*(5*d),N+=q>>>13,q&=8191;let $=N+C*d+I*h+x*u+k*l+P*c;N=$>>>13,$&=8191,$+=T*a+_*i+R*(5*g)+L*(5*f)+D*(5*p),N+=$>>>13,$&=8191;let z=N+C*p+I*d+x*h+k*u+P*l;N=z>>>13,z&=8191,z+=T*c+_*a+R*i+L*(5*g)+D*(5*f),N+=z>>>13,z&=8191;let K=N+C*f+I*p+x*d+k*h+P*u;N=K>>>13,K&=8191,K+=T*l+_*c+R*a+L*i+D*(5*g),N+=K>>>13,K&=8191;let V=N+C*g+I*f+x*p+k*d+P*h;N=V>>>13,V&=8191,V+=T*u+_*l+R*c+L*a+D*i,N+=V>>>13,V&=8191,N=(N<<2)+N|0,N=N+M|0,M=8191&N,N>>>=13,O+=N,s[0]=M,s[1]=O,s[2]=F,s[3]=U,s[4]=B,s[5]=q,s[6]=$,s[7]=z,s[8]=K,s[9]=V}finalize(){const{h:e,pad:t}=this,r=new Uint16Array(10);let n=e[1]>>>13;e[1]&=8191;for(let t=2;t<10;t++)e[t]+=n,n=e[t]>>>13,e[t]&=8191;e[0]+=5*n,n=e[0]>>>13,e[0]&=8191,e[1]+=n,n=e[1]>>>13,e[1]&=8191,e[2]+=n,r[0]=e[0]+5,n=r[0]>>>13,r[0]&=8191;for(let t=1;t<10;t++)r[t]=e[t]+n,n=r[t]>>>13,r[t]&=8191;r[9]-=8192;let s=(1^n)-1;for(let e=0;e<10;e++)r[e]&=s;s=~s;for(let t=0;t<10;t++)e[t]=e[t]&s|r[t];e[0]=65535&(e[0]|e[1]<<13),e[1]=65535&(e[1]>>>3|e[2]<<10),e[2]=65535&(e[2]>>>6|e[3]<<7),e[3]=65535&(e[3]>>>9|e[4]<<4),e[4]=65535&(e[4]>>>12|e[5]<<1|e[6]<<14),e[5]=65535&(e[6]>>>2|e[7]<<11),e[6]=65535&(e[7]>>>5|e[8]<<8),e[7]=65535&(e[8]>>>8|e[9]<<5);let o=e[0]+t[0];e[0]=65535&o;for(let r=1;r<8;r++)o=(e[r]+t[r]|0)+(o>>>16)|0,e[r]=65535&o;Bu(r)}update(e){Du(this);const{buffer:t,blockLen:r}=this,n=(e=Mu(e)).length;for(let s=0;s<n;){const o=Math.min(r-this.pos,n-s);if(o!==r)t.set(e.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===r&&(this.process(t,0,!1),this.pos=0);else for(;r<=n-s;s+=r)this.process(e,s)}return this}destroy(){Bu(this.h,this.r,this.buffer,this.pad)}digestInto(e){Du(this),function(e,t){Lu(e);const r=t.outputLen;if(e.length<r)throw Error("digestInto() expects output buffer of length at least "+r)}(e,this),this.finished=!0;const{buffer:t,h:r}=this;let{pos:n}=this;if(n){for(t[n++]=1;n<16;n++)t[n]=0;this.process(t,0,!0)}this.finalize();let s=0;for(let t=0;t<8;t++)e[s++]=r[t]>>>0,e[s++]=r[t]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}}const Qu=function(e){const t=(t,r)=>e(r).update(Mu(t)).digest(),r=e(new Uint8Array(32));return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=t=>e(t),t}((e=>new Yu(e)));function Ju(e,t,r,n,s,o=20){let i=e[0],a=e[1],c=e[2],l=e[3],u=t[0],h=t[1],d=t[2],p=t[3],f=t[4],g=t[5],m=t[6],y=t[7],b=s,w=r[0],v=r[1],E=r[2],S=i,A=a,C=c,I=l,x=u,k=h,P=d,T=p,_=f,R=g,L=m,D=y,N=b,M=w,O=v,F=E;for(let e=0;e<o;e+=2)S=S+x|0,N=Hu(N^S,16),_=_+N|0,x=Hu(x^_,12),S=S+x|0,N=Hu(N^S,8),_=_+N|0,x=Hu(x^_,7),A=A+k|0,M=Hu(M^A,16),R=R+M|0,k=Hu(k^R,12),A=A+k|0,M=Hu(M^A,8),R=R+M|0,k=Hu(k^R,7),C=C+P|0,O=Hu(O^C,16),L=L+O|0,P=Hu(P^L,12),C=C+P|0,O=Hu(O^C,8),L=L+O|0,P=Hu(P^L,7),I=I+T|0,F=Hu(F^I,16),D=D+F|0,T=Hu(T^D,12),I=I+T|0,F=Hu(F^I,8),D=D+F|0,T=Hu(T^D,7),S=S+k|0,F=Hu(F^S,16),L=L+F|0,k=Hu(k^L,12),S=S+k|0,F=Hu(F^S,8),L=L+F|0,k=Hu(k^L,7),A=A+P|0,N=Hu(N^A,16),D=D+N|0,P=Hu(P^D,12),A=A+P|0,N=Hu(N^A,8),D=D+N|0,P=Hu(P^D,7),C=C+T|0,M=Hu(M^C,16),_=_+M|0,T=Hu(T^_,12),C=C+T|0,M=Hu(M^C,8),_=_+M|0,T=Hu(T^_,7),I=I+x|0,O=Hu(O^I,16),R=R+O|0,x=Hu(x^R,12),I=I+x|0,O=Hu(O^I,8),R=R+O|0,x=Hu(x^R,7);let U=0;n[U++]=i+S|0,n[U++]=a+A|0,n[U++]=c+C|0,n[U++]=l+I|0,n[U++]=u+x|0,n[U++]=h+k|0,n[U++]=d+P|0,n[U++]=p+T|0,n[U++]=f+_|0,n[U++]=g+R|0,n[U++]=m+L|0,n[U++]=y+D|0,n[U++]=b+N|0,n[U++]=w+M|0,n[U++]=v+O|0,n[U++]=E+F|0}const eh=Xu(Ju,{counterRight:!1,counterLength:4,allowShortKeys:!1}),th=new Uint8Array(16),rh=(e,t)=>{e.update(t);const r=t.length%16;r&&e.update(th.subarray(r))},nh=new Uint8Array(32);function sh(e,t,r,n,s){const o=e(t,r,nh),i=Qu.create(o);s&&rh(i,s),rh(i,n);const a=new Uint8Array(16),c=(l=a,new DataView(l.buffer,l.byteOffset,l.byteLength));var l;Fu(c,0,BigInt(s?s.length:0),!0),Fu(c,8,BigInt(n.length),!0),i.update(a);const u=i.digest();return Bu(o,a),u}const oh=Ou({blockSize:64,nonceLength:12,tagLength:16},(ih=eh,(e,t,r)=>{const n=16;return Lu(e,32),Lu(t),{encrypt(s,o){const i=s.length,a=i+n;o?Lu(o,a):o=new Uint8Array(a),ih(e,t,s,o,1);const c=sh(ih,e,t,o.subarray(0,-16),r);return o.set(c,i),Bu(c),o},decrypt(s,o){const i=s.length,a=i-n;if(i<n)throw Error("encrypted data must be at least 16 bytes");o?Lu(o,a):o=new Uint8Array(a);const c=s.subarray(0,-16),l=s.subarray(-16),u=sh(ih,e,t,c,r);if(!((e,t)=>{if(e.length!==t.length)return!1;let r=0;for(let n=0;n<e.length;n++)r|=e[n]^t[n];return 0===r})(l,u))throw Error("invalid tag");return ih(e,t,c,o,1),Bu(u),o}}}));var ih;const ah=Uint8Array.from([0]),ch=Uint8Array.of();const lh={hashSHA256:e=>on(e.subarray()),getHKDF(e,t){const r=function(e,t,r){return ar(e),void 0===r&&(r=new Uint8Array(e.outputLen)),Dl(e,Ar(r),Ar(t))}(on,t,e),n=function(e,t,r,n=32){ar(e),or(n);const s=e.outputLen;if(n>255*s)throw Error("Length should be <= 255*HashLen");const o=Math.ceil(n/s);void 0===r&&(r=ch);const i=new Uint8Array(o*s),a=Dl.create(e,t),c=a._cloneInto(),l=new Uint8Array(a.outputLen);for(let e=0;e<o;e++)ah[0]=e+1,c.update(0===e?ch:l).update(r).update(ah).digestInto(l),i.set(l,s*e),a._cloneInto(c);return a.destroy(),c.destroy(),lr(l,ah),i.slice(0,n)}(on,r,void 0,96),s=n;return[s.subarray(0,32),s.subarray(32,64),s.subarray(64,96)]},generateX25519KeyPair(){const e=ul.utils.randomPrivateKey();return{publicKey:ul.getPublicKey(e),privateKey:e}},generateX25519KeyPairFromSeed:e=>({publicKey:ul.getPublicKey(e),privateKey:e}),generateX25519SharedKey:(e,t)=>ul.getSharedSecret(e.subarray(),t.subarray()),chaCha20Poly1305Encrypt:(e,t,r,n)=>oh(n,t,r).encrypt(e.subarray()),chaCha20Poly1305Decrypt:(e,t,r,n,s)=>oh(n,t,r).decrypt(e.subarray(),s)},uh=lh;const hh=e=>{const r=t(2);return r[0]=e>>8,r[1]=e,r};hh.bytes=2;const dh=e=>{if(e.length<2)throw RangeError("Could not decode int16BE");if(e instanceof Uint8Array){let t=0;return t+=e[0]<<8,t+=e[1],t}return e.getUint16(0)};function ph(e,t){t.enabled&&Pu&&(e?(t("LOCAL_STATIC_PUBLIC_KEY "+mn(e.publicKey,"hex")),t("LOCAL_STATIC_PRIVATE_KEY "+mn(e.privateKey,"hex"))):t("Missing local static keys."))}function fh(e,t){t.enabled&&Pu&&(e?(t("LOCAL_PUBLIC_EPHEMERAL_KEY "+mn(e.publicKey,"hex")),t("LOCAL_PRIVATE_EPHEMERAL_KEY "+mn(e.privateKey,"hex"))):t("Missing local ephemeral keys."))}function gh(e,t){t.enabled&&Pu&&t(e?"REMOTE_EPHEMERAL_PUBLIC_KEY "+mn(e.subarray(),"hex"):"Missing remote ephemeral keys.")}function mh(e,t,r){r.enabled&&Pu&&(r(`CIPHER_STATE_1 ${e.n.getUint64()} ${e.k&&mn(e.k,"hex")}`),r(`CIPHER_STATE_2 ${t.n.getUint64()} ${t.k&&mn(t.k,"hex")}`))}dh.bytes=2;class yh extends Error{code;constructor(e="Invalid crypto exchange"){super(e),this.code=yh.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"}class bh{n;bytes;view;constructor(t=0){this.n=t,this.bytes=e(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,t,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>4294967295)throw Error("Cipherstate has reached maximum n, a new handshake must be performed")}}const wh=e(0);class vh{k;n;crypto;constructor(e,t,r=0){this.crypto=e,this.k=t,this.n=new bh(r)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const r=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),r}decryptWithAd(e,t,r){if(!this.hasKey())return t;this.n.assertValue();const n=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,r);return this.n.increment(),n}}class Eh{cs;ck;h;crypto;constructor(t,r){this.crypto=t;const n=tt(r,"utf-8");this.h=function(t,r){if(r.length<=32){const t=e(32);return t.set(r),t}return t.hash(r)}(t,n),this.ck=this.h,this.cs=new vh(t)}mixKey(e){const[t,r]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new vh(this.crypto,r)}mixHash(e){this.h=this.crypto.hash(new ns(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,wh);return[new vh(this.crypto,e),new vh(this.crypto,t)]}}class Sh{ss;s;e;rs;re;initiator;crypto;constructor(e){const{crypto:t,protocolName:r,prologue:n,initiator:s,s:o,e:i,rs:a,re:c}=e;this.crypto=t,this.ss=new Eh(t,r),this.ss.mixHash(n),this.initiator=s,this.s=o,this.e=i,this.rs=a,this.re=c}writeE(){if(this.e)throw Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw Error("ephemeral keypair is not set");if(!this.re)throw Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw Error("ephemeral keypair is not set");if(!this.rs)throw Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw Error("static keypair is not set");if(!this.re)throw Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw Error("static keypair is not set");if(!this.re)throw Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw Error("ephemeral keypair is not set");if(!this.rs)throw Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw Error("remote static public key is already set");const r=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+r)throw Error("message is not long enough");const n=e.sublist(t,t+r);return this.rs=this.ss.decryptAndHash(n),r}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class Ah extends Sh{writeMessageA(e){return new ns(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const r=this.writeS();return this.writeES(),new ns(t,r,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new ns(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(e){throw new yh("handshake stage 0 validation fail: "+e.message)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(e){throw new yh("handshake stage 1 validation fail: "+e.message)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(e){throw new yh("handshake stage 2 validation fail: "+e.message)}}}var Ch,Ih;async function xh(e,t,r){const n=await e.sign(Ph(t));return Ih.encode({identityKey:iu(e.publicKey),identitySig:n,extensions:r})}async function kh(e,t,r){try{const n=Ih.decode(e),s=ou(n.identityKey);if(!1===r?.equals(s))throw Error(`Payload identity key ${s} does not match expected remote identity key ${r}`);if(!t)throw Error("Remote static does not exist");const o=Ph(t);if(!await s.verify(o,n.identitySig))throw Error("Invalid payload signature");return n}catch(e){throw new mo(e.message)}}function Ph(e){const t=tt("noise-libp2p-static-key:");return e instanceof Uint8Array?Qn([t,e],t.length+e.length):(e.prepend(t),e)}async function Th(e,t){const{log:r,connection:n,crypto:s,privateKey:o,prologue:i,s:a,remoteIdentityKey:c,extensions:l}=e,u=await xh(o,a.publicKey,l),h=new Ah({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:i,s:a});ph(h.s,r),r.trace("Stage 0 - Initiator starting to send first message."),await n.write(h.writeMessageA(wh),t),r.trace("Stage 0 - Initiator finished sending first message."),fh(h.e,r),r.trace("Stage 1 - Initiator waiting to receive first message from responder...");const d=h.readMessageB(await n.read(t));var p,f;r.trace("Stage 1 - Initiator received the message."),gh(h.re,r),p=h.rs,(f=r).enabled&&Pu&&f(p?"REMOTE_STATIC_PUBLIC_KEY "+mn(p.subarray(),"hex"):"Missing remote static public key."),r.trace("Initiator going to check remote's signature...");const g=await kh(d,h.rs,c);r.trace("All good with the signature!"),r.trace("Stage 2 - Initiator sending third handshake message."),await n.write(h.writeMessageC(u),t),r.trace("Stage 2 - Initiator sent message with signed payload.");const[m,y]=h.ss.split();return mh(m,y,r),{payload:g,encrypt(e){return m.encryptWithAd(wh,e)},decrypt(e,t){return y.decryptWithAd(wh,e,t)}}}(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.webtransportCerthashes)for(const r of e.webtransportCerthashes)t.uint32(10),t.bytes(r);!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={webtransportCerthashes:[]},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();if(t>>>3==1)r.webtransportCerthashes.push(e.bytes());else e.skipType(7&t)}return r}))),t),e.encode=t=>gt(t,e.codec()),e.decode=t=>P(t,e.codec())})(Ch||(Ch={})),(t=>{let r;t.codec=()=>(null==r&&(r=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.identityKey&&e.identityKey.byteLength>0&&(t.uint32(10),t.bytes(e.identityKey)),null!=e.identitySig&&e.identitySig.byteLength>0&&(t.uint32(18),t.bytes(e.identitySig)),null!=e.extensions&&(t.uint32(34),Ch.codec().encode(e.extensions,t)),!1!==r.lengthDelimited&&t.ldelim()}),((t,r)=>{const n={identityKey:e(0),identitySig:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.identityKey=t.bytes();break;case 2:n.identitySig=t.bytes();break;case 4:n.extensions=Ch.codec().decode(t,t.uint32());break;default:t.skipType(7&e)}}return n}))),r),t.encode=e=>gt(e,t.codec()),t.decode=e=>P(e,t.codec())})(Ih||(Ih={}));class _h{protocol="/noise";crypto;prologue;staticKey;extensions;metrics;components;constructor(t,r={}){const{staticNoiseKey:n,extensions:s,crypto:o,prologueBytes:i}=r,{metrics:a}=t;this.components=t;const c=o??uh;this.crypto=function(e){return{generateKeypair:e.generateX25519KeyPair,dh:(t,r)=>e.generateX25519SharedKey(t.privateKey,r).subarray(0,32),encrypt:e.chaCha20Poly1305Encrypt,decrypt:e.chaCha20Poly1305Decrypt,hash:e.hashSHA256,hkdf:e.getHKDF}}(c),this.extensions=s,this.metrics=a?function(e){return{xxHandshakeSuccesses:e.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:e.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:e.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:e.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:e.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}(a):void 0,this.staticKey=n?c.generateX25519KeyPairFromSeed(n):c.generateX25519KeyPair(),this.prologue=i??e(0)}[Symbol.toStringTag]="@chainsafe/libp2p-noise";[zo]=["@libp2p/connection-encryption","@chainsafe/libp2p-noise"];async secureOutbound(e,t){const r=Iu(e,{lengthEncoder:hh,lengthDecoder:dh,maxDataLength:ku}),n=await this.performHandshakeInitiator(r,this.components.privateKey,t?.remotePeer?.publicKey,t),s=await this.createSecureConnection(r,n);e.source=s.source,e.sink=s.sink;const o=ou(n.payload.identityKey);return{conn:e,remoteExtensions:n.payload.extensions,remotePeer:fu(o)}}async secureInbound(e,t){const r=Iu(e,{lengthEncoder:hh,lengthDecoder:dh,maxDataLength:ku}),n=await this.performHandshakeResponder(r,this.components.privateKey,t?.remotePeer?.publicKey,t),s=await this.createSecureConnection(r,n);e.source=s.source,e.sink=s.sink;const o=ou(n.payload.identityKey);return{conn:e,remoteExtensions:n.payload.extensions,remotePeer:fu(o)}}async performHandshakeInitiator(e,t,r,n){let s;try{s=await Th({connection:e,privateKey:t,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:this.extensions},n),this.metrics?.xxHandshakeSuccesses.increment()}catch(e){throw this.metrics?.xxHandshakeErrors.increment(),e}return s}async performHandshakeResponder(e,t,r,n){let s;try{s=await async function(e,t){const{log:r,connection:n,crypto:s,privateKey:o,prologue:i,s:a,remoteIdentityKey:c,extensions:l}=e,u=await xh(o,a.publicKey,l),h=new Ah({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:i,s:a});ph(h.s,r),r.trace("Stage 0 - Responder waiting to receive first message."),h.readMessageA(await n.read(t)),r.trace("Stage 0 - Responder received first message."),gh(h.re,r),r.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await n.write(h.writeMessageB(u),t),r.trace("Stage 1 - Responder sent the second handshake message with signed payload."),fh(h.e,r),r.trace("Stage 2 - Responder waiting for third handshake message...");const d=h.readMessageC(await n.read(t));r.trace("Stage 2 - Responder received the message, finished handshake.");const p=await kh(d,h.rs,c),[f,g]=h.ss.split();return mh(f,g,r),{payload:p,encrypt:e=>g.encryptWithAd(wh,e),decrypt:(e,t)=>f.decryptWithAd(wh,e,t)}}({connection:e,privateKey:t,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:this.extensions},n),this.metrics?.xxHandshakeSuccesses.increment()}catch(e){throw this.metrics?.xxHandshakeErrors.increment(),e}return s}async createSecureConnection(e,t){const[r,n]=function(){const e=xu(),t=xu();return[{source:e.source,sink:t.sink},{source:t.source,sink:e.sink}]}(),s=e.unwrap();return await Is(r,function(e,t){return async function*(r){for await(const n of r)for(let r=0;r<n.length;r+=65519){let s,o=r+65519;o>n.length&&(o=n.length),s=n instanceof Uint8Array?e.encrypt(n.subarray(r,o)):e.encrypt(n.sublist(r,o)),t?.encryptedPackets.increment(),yield new ns(hh(s.byteLength),s)}}}(t,this.metrics),s,(e=>ps(e,{lengthDecoder:dh})),function(e,t){return async function*(r){for await(const n of r)for(let r=0;r<n.length;r+=ku){let s=r+ku;if(s>n.length&&(s=n.length),s-16<r)throw Error("Invalid chunk");const o=n.sublist(r,s),i=n.subarray(r,s-16);try{const r=e.decrypt(o,i);t?.decryptedPackets.increment(),yield r}catch(e){throw t?.decryptErrors.increment(),e}}}}(t,this.metrics),r),n}}function Rh(e={}){return t=>new _h(t,e)}const Lh=ld("dns4"),Dh=ld("dns6"),Nh=ld("dnsaddr"),Mh=cd(ld("dns"),Nh,Lh,Dh),Oh=cd(ld("ip4"),ld("ip6")),Fh=cd(ad(Oh,ld("tcp")),ad(Mh,ld("tcp"))),Uh=ad(Oh,ld("udp")),Bh=ad(Uh,ld("utp")),qh=ad(Uh,ld("quic")),$h=ad(Uh,ld("quic-v1")),zh=cd(ad(Fh,ld("ws")),ad(Mh,ld("ws"))),Kh=cd(ad(zh,ld("p2p")),zh),Vh=cd(ad(Fh,ld("wss")),ad(Mh,ld("wss")),ad(Fh,ld("tls"),ld("ws")),ad(Mh,ld("tls"),ld("ws"))),Hh=cd(ad(Vh,ld("p2p")),Vh),jh=cd(ad(Fh,ld("http")),ad(Oh,ld("http")),ad(Mh,ld("http"))),Gh=cd(ad(Fh,ld("https")),ad(Oh,ld("https")),ad(Mh,ld("https"))),Wh=ad(Uh,ld("webrtc-direct"),ld("certhash")),Xh=cd(ad(Wh,ld("p2p")),Wh),Zh=ad($h,ld("webtransport"),ld("certhash"),ld("certhash")),Yh=cd(ad(Zh,ld("p2p")),Zh),Qh=cd(ad(Kh,ld("p2p-webrtc-star"),ld("p2p")),ad(Hh,ld("p2p-webrtc-star"),ld("p2p")),ad(Kh,ld("p2p-webrtc-star")),ad(Hh,ld("p2p-webrtc-star")));cd(ad(Kh,ld("p2p-websocket-star"),ld("p2p")),ad(Hh,ld("p2p-websocket-star"),ld("p2p")),ad(Kh,ld("p2p-websocket-star")),ad(Hh,ld("p2p-websocket-star")));const Jh=cd(ad(jh,ld("p2p-webrtc-direct"),ld("p2p")),ad(Gh,ld("p2p-webrtc-direct"),ld("p2p")),ad(jh,ld("p2p-webrtc-direct")),ad(Gh,ld("p2p-webrtc-direct"))),ed=cd(zh,Vh,jh,Gh,Qh,Jh,Fh,Bh,qh,Mh,Xh,Yh);cd(ad(ed,ld("p2p-stardust"),ld("p2p")),ad(ed,ld("p2p-stardust")));const td=cd(ad(ed,ld("p2p")),Qh,Jh,Xh,Yh,ld("p2p")),rd=cd(ad(td,ld("p2p-circuit"),td),ad(td,ld("p2p-circuit")),ad(ld("p2p-circuit"),td),ad(ed,ld("p2p-circuit")),ad(ld("p2p-circuit"),ed),ld("p2p-circuit")),nd=()=>cd(ad(rd,nd),rd),sd=nd(),od=cd(ad(sd,td,sd),ad(td,sd),ad(sd,td),sd,td);function id(e){return function(t){let r;try{r=Ri(t)}catch(e){return!1}const n=e(r.protoNames());return null!==n&&(!0===n||!1===n?n:0===n.length)}}function ad(...e){function t(t){if(t.length<e.length)return null;let r=t;return e.some((e=>(r="function"==typeof e?e().partialMatch(t):e.partialMatch(t),Array.isArray(r)&&(t=r),null===r))),r}return{toString(){return"{ "+e.join(" ")+" }"},input:e,matches:id(t),partialMatch:t}}function cd(...e){function t(t){let r=null;return e.some((e=>{const n="function"==typeof e?e().partialMatch(t):e.partialMatch(t);return null!=n&&(r=n,!0)})),r}return{toString(){return"{ "+e.join(" ")+" }"},input:e,matches:id(t),partialMatch:t}}function ld(e){const t=e;return{toString(){return t},matches(e){let r;try{r=Ri(e)}catch(e){return!1}const n=r.protoNames();return 1===n.length&&n[0]===t},partialMatch(e){return 0===e.length?null:e[0]===t?e.slice(1):null}}}cd(ad(sd,ld("webrtc"),ld("p2p")),ad(sd,ld("webrtc")),ad(ed,ld("webrtc"),ld("p2p")),ad(ed,ld("webrtc")),ld("webrtc"));class ud extends qo{static tag="bootstrap";log;timer;list;timeout;components;_init;constructor(e,t={list:[]}){if(null==t.list||0===t.list.length)throw Error("Bootstrap requires a list of peer addresses");super(),this.components=e,this.log=e.logger.forComponent("libp2p:bootstrap"),this.timeout=t.timeout??1e3,this.list=[];for(const e of t.list){if(!od.matches(e)){this.log.error("Invalid multiaddr");continue}const t=Ri(e),r=t.getPeerId();if(null==r){this.log.error("Invalid bootstrap multiaddr without peer id");continue}const n={id:pu(r),multiaddrs:[t]};this.list.push(n)}this._init=t}[ao]=this;[Symbol.toStringTag]="@libp2p/bootstrap";[zo]=["@libp2p/peer-discovery"];isStarted(){return!!this.timer}start(){this.isStarted()||(this.log("Starting bootstrap node discovery, discovering peers after %s ms",this.timeout),this.timer=setTimeout((()=>{this._discoverBootstrapPeers().catch((e=>{this.log.error(e)}))}),this.timeout))}async _discoverBootstrapPeers(){if(null!=this.timer)for(const e of this.list){if(await this.components.peerStore.merge(e.id,{tags:{[this._init.tagName??"bootstrap"]:{value:this._init.tagValue??50,ttl:this._init.tagTTL}},multiaddrs:e.multiaddrs}),null==this.timer)return;this.safeDispatchEvent("peer",{detail:e}),this.components.connectionManager.openConnection(e.id).catch((t=>{this.log.error("could not dial bootstrap peer %p",e.id,t)}))}}stop(){null!=this.timer&&clearTimeout(this.timer),this.timer=void 0}}var hd;(t=>{let r;t.codec=()=>(null==r&&(r=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.publicKey&&e.publicKey.byteLength>0&&(t.uint32(10),t.bytes(e.publicKey)),null!=e.payloadType&&e.payloadType.byteLength>0&&(t.uint32(18),t.bytes(e.payloadType)),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(26),t.bytes(e.payload)),null!=e.signature&&e.signature.byteLength>0&&(t.uint32(42),t.bytes(e.signature)),!1!==r.lengthDelimited&&t.ldelim()}),((t,r)=>{const n={publicKey:e(0),payloadType:e(0),payload:e(0),signature:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.publicKey=t.bytes();break;case 2:n.payloadType=t.bytes();break;case 3:n.payload=t.bytes();break;case 5:n.signature=t.bytes();break;default:t.skipType(7&e)}}return n}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(hd||(hd={}));class dd extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}class pd{static createFromProtobuf=e=>{const t=hd.decode(e),r=ou(t.publicKey);return new pd({publicKey:r,payloadType:t.payloadType,payload:t.payload,signature:t.signature})};static seal=async(e,t,r)=>{if(null==t)throw Error("Missing private key");const n=e.domain,s=e.codec,o=e.marshal(),i=fd(n,s,o),a=await t.sign(i.subarray(),r);return new pd({publicKey:t.publicKey,payloadType:s,payload:o,signature:a})};static openAndCertify=async(e,t,r)=>{const n=pd.createFromProtobuf(e);if(!await n.validate(t,r))throw new dd("Envelope signature is not valid for the given domain");return n};publicKey;payloadType;payload;signature;marshaled;constructor(e){const{publicKey:t,payloadType:r,payload:n,signature:s}=e;this.publicKey=t,this.payloadType=r,this.payload=n,this.signature=s}marshal(){return null==this.marshaled&&(this.marshaled=hd.encode({publicKey:iu(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return null!=e&&Jn(this.marshal(),e.marshal())}async validate(e,t){const r=fd(e,this.payloadType,this.payload);return this.publicKey.verify(r.subarray(),this.signature,t)}}const fd=(e,t,r)=>{const n=tt(e),s=h(n.byteLength),o=h(t.length),i=h(r.length);return new ns(s,n,o,t,i,r)};const gd=Uint8Array.from([3,1]);var md;(t=>{let r;(t=>{let r;t.codec=()=>(null==r&&(r=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.multiaddr&&e.multiaddr.byteLength>0&&(t.uint32(10),t.bytes(e.multiaddr)),!1!==r.lengthDelimited&&t.ldelim()}),((t,r)=>{const n={multiaddr:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();if(e>>>3==1)n.multiaddr=t.bytes();else t.skipType(7&e)}return n}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(t.AddressInfo||(t.AddressInfo={})),t.codec=()=>(null==r&&(r=Zt(((e,r,n={})=>{if(!1!==n.lengthDelimited&&r.fork(),null!=e.peerId&&e.peerId.byteLength>0&&(r.uint32(10),r.bytes(e.peerId)),null!=e.seq&&0n!==e.seq&&(r.uint32(16),r.uint64(e.seq)),null!=e.addresses)for(const n of e.addresses)r.uint32(26),t.AddressInfo.codec().encode(n,r);!1!==n.lengthDelimited&&r.ldelim()}),((r,n,s={})=>{const o={peerId:e(0),seq:0n,addresses:[]},i=null==n?r.len:r.pos+n;for(;r.pos<i;){const e=r.uint32();switch(e>>>3){case 1:o.peerId=r.bytes();break;case 2:o.seq=r.uint64();break;case 3:if(null!=s.limits?.addresses&&o.addresses.length===s.limits.addresses)throw new Yt('Decode error - map field "addresses" had too many elements');o.addresses.push(t.AddressInfo.codec().decode(r,r.uint32(),{limits:s.limits?.addresses$}));break;default:r.skipType(7&e)}}return o}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(md||(md={}));class yd{static createFromProtobuf=e=>{const t=md.decode(e),r=gu(Oe(t.peerId)),n=(t.addresses??[]).map((e=>Ri(e.multiaddr))),s=t.seq;return new yd({peerId:r,multiaddrs:n,seqNumber:s})};static DOMAIN="libp2p-peer-record";static CODEC=gd;peerId;multiaddrs;seqNumber;domain=yd.DOMAIN;codec=yd.CODEC;marshaled;constructor(e){const{peerId:t,multiaddrs:r,seqNumber:n}=e;this.peerId=t,this.multiaddrs=r??[],this.seqNumber=n??BigInt(Date.now())}marshal(){return null==this.marshaled&&(this.marshaled=md.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map((e=>({multiaddr:e.bytes})))})),this.marshaled}equals(e){return e instanceof yd&&(!!this.peerId.equals(e.peerId)&&(this.seqNumber===e.seqNumber&&!!function(e,t){const r=(e,t)=>e.toString().localeCompare(t.toString());return e.length===t.length&&(t.sort(r),e.sort(r).every(((e,r)=>t[r].equals(e))))}(this.multiaddrs,e.multiaddrs)))}}function bd(e,t){let r;const n=()=>{clearTimeout(r),r=setTimeout((()=>{r=void 0,e()}),t)};return n.start=()=>{},n.stop=()=>{clearTimeout(r)},n}function wd(e){if(null!=e[Symbol.asyncIterator])return(async()=>{for await(const t of e);})();for(const t of e);}const vd=globalThis.CustomEvent??Event;let Ed=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};class Sd extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"}let Ad=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"};class Cd extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"}function Id(e,t={}){const r=function(e,t){const r=Ss();e.sink(r).catch((async e=>{await r.end(e)})),e.sink=async e=>{for await(const t of e)await r.push(t);await r.end()};let n=e.source;null!=e.source[Symbol.iterator]?n=e.source[Symbol.iterator]():null!=e.source[Symbol.asyncIterator]&&(n=e.source[Symbol.asyncIterator]());const s=new ns;return{async read(e){if(e?.signal?.throwIfAborted(),null==e?.bytes){const{done:t,value:r}=await vs(n.next(),e?.signal);return!0===t?null:r}for(;s.byteLength<e.bytes;){const{value:t,done:r}=await vs(n.next(),e?.signal);if(!0===r)throw new Ed("unexpected end of input");s.append(t)}const t=s.sublist(0,e.bytes);return s.consume(e.bytes),t},async write(e,t){t?.signal?.throwIfAborted(),e instanceof Uint8Array?await r.push(e,t):await r.push(e.subarray(),t)},unwrap(){if(s.byteLength>0){const r=e.source;e.source=async function*(){!1===t?.yieldBytes?yield s:yield*s,yield*r}()}return e}}}(e,t);null!=t.maxDataLength&&null==t.maxLengthLength&&(t.maxLengthLength=c(t.maxDataLength));const n=t?.lengthDecoder??d,s=t?.lengthEncoder??h;return{async read(e){let s=-1;const o=new ns;for(;;){o.append(await r.read({...e,bytes:1}));try{s=n(o)}catch(e){if(e instanceof RangeError)continue;throw e}if(s<0)throw new Sd("Invalid message length");if(null!=t?.maxLengthLength&&o.byteLength>t.maxLengthLength)throw new Cd("message length length too long");if(s>-1)break}if(null!=t?.maxDataLength&&s>t.maxDataLength)throw new Ad("message length too long");return r.read({...e,bytes:s})},async write(e,t){await r.write(new ns(s(e.byteLength),e),t)},async writeV(e,t){const n=new ns(...e.flatMap((e=>[s(e.byteLength),e])));await r.write(n,t)},unwrap(){return r.unwrap()}}}function xd(e,t){const r=Id(e,t),n={async read(e,t){const n=await r.read(t);return e.decode(n)},async write(e,t,n){await r.write(t.encode(e),n)},async writeV(e,t,n){await r.writeV(e.map((e=>t.encode(e))),n)},pb(e){return{async read(t){return n.read(e,t)},async write(t,r){return n.write(t,e,r)},async writeV(t,r){return n.writeV(t,e,r)},unwrap(){return n}}},unwrap(){return r.unwrap()}};return n}var kd;(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.protocolVersion&&(t.uint32(42),t.string(e.protocolVersion)),null!=e.agentVersion&&(t.uint32(50),t.string(e.agentVersion)),null!=e.publicKey&&(t.uint32(10),t.bytes(e.publicKey)),null!=e.listenAddrs)for(const r of e.listenAddrs)t.uint32(18),t.bytes(r);if(null!=e.observedAddr&&(t.uint32(34),t.bytes(e.observedAddr)),null!=e.protocols)for(const r of e.protocols)t.uint32(26),t.string(r);null!=e.signedPeerRecord&&(t.uint32(66),t.bytes(e.signedPeerRecord)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={listenAddrs:[],protocols:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 5:n.protocolVersion=e.string();break;case 6:n.agentVersion=e.string();break;case 1:n.publicKey=e.bytes();break;case 2:if(null!=r.limits?.listenAddrs&&n.listenAddrs.length===r.limits.listenAddrs)throw new Yt('Decode error - map field "listenAddrs" had too many elements');n.listenAddrs.push(e.bytes());break;case 4:n.observedAddr=e.bytes();break;case 3:if(null!=r.limits?.protocols&&n.protocols.length===r.limits.protocols)throw new Yt('Decode error - map field "protocols" had too many elements');n.protocols.push(e.string());break;case 8:n.signedPeerRecord=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(kd||(kd={}));const Pd={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:8192,runOnConnectionOpen:!0,runOnLimitedConnection:!0};class Td{host;protocol;started;timeout;peerId;privateKey;peerStore;registrar;addressManager;maxInboundStreams;maxOutboundStreams;maxMessageSize;maxObservedAddresses;events;runOnLimitedConnection;log;constructor(e,t){var r,n;this.protocol=t.protocol,this.started=!1,this.peerId=e.peerId,this.privateKey=e.privateKey,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.events=e.events,this.log=t.log,this.timeout=t.timeout??Pd.timeout,this.maxInboundStreams=t.maxInboundStreams??Pd.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??Pd.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??Pd.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??Pd.maxObservedAddresses,this.runOnLimitedConnection=t.runOnLimitedConnection??Pd.runOnLimitedConnection,this.host={protocolVersion:(t.protocolPrefix??Pd.protocolPrefix)+"/0.1.0",agentVersion:(r=e.nodeInfo,n=t.agentVersion,null!=n?n:r.userAgent)}}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:tt(this.host.agentVersion),ProtocolVersion:tt(this.host.protocolVersion)}}),await this.registrar.handle(this.protocol,(e=>{this.handleProtocol(e).catch((e=>{this.log.error(e)}))}),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.protocol),this.started=!1}}var _d,Rd={};var Ld=(_d||(_d=1,function(){var e,t,r,n,s,o,i,a;a=e=>[(e&255<<24)>>>24,(e&255<<16)>>>16,(65280&e)>>>8,255&e].join("."),i=e=>{var r,n,s,o,i,a;for(r=[],s=o=0;o<=3&&0!==e.length;s=++o){if(s>0){if("."!==e[0])throw Error("Invalid IP");e=e.substring(1)}i=(a=t(e))[0],n=a[1],e=e.substring(n),r.push(i)}if(0!==e.length)throw Error("Invalid IP");switch(r.length){case 1:if(r[0]>4294967295)throw Error("Invalid IP");return r[0]>>>0;case 2:if(r[0]>255||r[1]>16777215)throw Error("Invalid IP");return(r[0]<<24|r[1])>>>0;case 3:if(r[0]>255||r[1]>255||r[2]>65535)throw Error("Invalid IP");return(r[0]<<24|r[1]<<16|r[2])>>>0;case 4:if(r[0]>255||r[1]>255||r[2]>255||r[3]>255)throw Error("Invalid IP");return(r[0]<<24|r[1]<<16|r[2]<<8|r[3])>>>0;default:throw Error("Invalid IP")}},n=(r=e=>e.charCodeAt(0))("0"),o=r("a"),s=r("A"),t=e=>{var t,i,a,c,l;for(c=0,t=10,i="9",a=0,e.length>1&&"0"===e[a]&&("x"===e[a+1]||"X"===e[a+1]?(a+=2,t=16):"0"<=e[a+1]&&e[a+1]<="9"&&(a++,t=8,i="7")),l=a;a<e.length;){if("0"<=e[a]&&e[a]<=i)c=c*t+(r(e[a])-n)>>>0;else{if(16!==t)break;if("a"<=e[a]&&e[a]<="f")c=c*t+(10+r(e[a])-o)>>>0;else{if(!("A"<=e[a]&&e[a]<="F"))break;c=c*t+(10+r(e[a])-s)>>>0}}if(c>4294967295)throw Error("too large");a++}if(a===l)throw Error("empty octet");return[c,a]},e=function(){function e(e,t){var r,n,s;if("string"!=typeof e)throw Error("Missing `net' parameter");if(t||(s=e.split("/",2),e=s[0],t=s[1]),t||(t=32),"string"==typeof t&&t.indexOf(".")>-1){try{this.maskLong=i(t)}catch(e){throw Error("Invalid mask: "+t)}for(r=n=32;n>=0;r=--n)if(this.maskLong===4294967295<<32-r>>>0){this.bitmask=r;break}}else{if(!t&&0!==t)throw Error("Invalid mask: empty");this.bitmask=parseInt(t,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0)}try{this.netLong=(i(e)&this.maskLong)>>>0}catch(t){throw Error("Invalid net address: "+e)}if(!(this.bitmask<=32))throw Error("Invalid mask for ip4: "+t);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return e.prototype.contains=function(t){return"string"==typeof t&&(t.indexOf("/")>0||4!==t.split(".").length)&&(t=new e(t)),t instanceof e?this.contains(t.base)&&this.contains(t.broadcast||t.last):(i(t)&this.maskLong)>>>0==(this.netLong&this.maskLong)>>>0},e.prototype.next=function(t){return null==t&&(t=1),new e(a(this.netLong+this.size*t),this.mask)},e.prototype.forEach=function(e){var t,r,n;for(n=i(this.first),r=i(this.last),t=0;n<=r;)e(a(n),n,t),t++,n++},e.prototype.toString=function(){return this.base+"/"+this.bitmask},e}(),Rd.ip2long=i,Rd.long2ip=a,Rd.Netmask=e}()),Rd);const Dd=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"].map((e=>new Ld.Netmask(e)));function Nd(e){for(const t of Dd)if(t.contains(e))return!0;return!1}function Md(e){return Qo(e)?Nd(e):/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(e)?function(e){const t=e.split(":");if(t.length<2)return!1;const r=t[t.length-1].padStart(4,"0"),n=t[t.length-2].padStart(4,"0");return Nd(`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(r.substring(0,2),16)}.${parseInt(r.substring(2),16)}`)}(e):function(e){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(e)}(e)?function(e){const t=e.split(":");return Nd(t[t.length-1])}(e):Jo(e)?function(e){return/^::$/.test(e)||/^::1$/.test(e)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(e)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(e)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(e)||/^ff([0-9a-fA-F]{2,2}):/i.test(e)}(e):void 0}function Od(e){try{if(!function(e){try{for(const{code:t}of e.getComponents())if(42!==t)return 4===t||t===ei}catch{}return!1}(e))return!1;const[[,t]]=e.stringTuples();return null!=t&&(Md(t)??!1)}catch{}return!0}const Fd=e=>({match(t){return!(t.length<1)&&(!!e(t[0])&&t.slice(1))},pattern:"fn"}),Ud=e=>({match(t){return Fd((t=>t===e)).match(t)},pattern:e}),Bd=()=>({match(e){return Fd((e=>"string"==typeof e)).match(e)},pattern:"{string}"}),qd=()=>({match(e){return Fd((e=>!isNaN(parseInt(e)))).match(e)},pattern:"{number}"}),$d=()=>({match(e){if(e.length<2)return!1;if("p2p"!==e[0]&&"ipfs"!==e[0])return!1;if(!e[1].startsWith("Q")&&!e[1].startsWith("1"))return!1;try{he.decode("z"+e[1])}catch(e){return!1}return e.slice(2)},pattern:"/p2p/{peerid}"}),zd=()=>({match(e){if(e.length<2)return!1;if("certhash"!==e[0])return!1;try{me.decode(e[1])}catch{return!1}return e.slice(2)},pattern:"/certhash/{certhash}"}),Kd=e=>({match(t){const r=e.match(t);return!1===r?t:r},pattern:`optional(${e.pattern})`}),Vd=(...e)=>({match(t){let r;for(const n of e){const e=n.match(t);!1!==e&&((null==r||e.length<r.length)&&(r=e))}return null!=r&&r},pattern:`or(${e.map((e=>e.pattern)).join(", ")})`}),Hd=(...e)=>({match(t){for(const r of e){const e=r.match(t);if(!1===e)return!1;t=e}return t},pattern:`and(${e.map((e=>e.pattern)).join(", ")})`});function jd(...e){function t(t){let r=(e=>e.toString().split("/").slice(1))(t);for(const t of e){const e=t.match(r);if(!1===e)return!1;r=e}return r}return{matchers:e,matches(e){return!1!==t(e)},exactMatch(e){const r=t(e);return!1!==r&&0===r.length}}}jd($d());const Gd=Hd(Ud("dns4"),Bd()),Wd=Hd(Ud("dns6"),Bd()),Xd=Hd(Ud("dnsaddr"),Bd()),Zd=Hd(Ud("dns"),Bd());jd(Gd,Kd($d())),jd(Wd,Kd($d())),jd(Xd,Kd($d())),jd(Vd(Zd,Xd,Gd,Wd),Kd($d()));const Yd=Hd(Ud("ip4"),Fd(Qo)),Qd=Hd(Ud("ip6"),Fd(Jo)),Jd=Vd(Yd,Qd),ep=Vd(Jd,Zd,Gd,Wd,Xd),tp=jd(Vd(Jd,Hd(Vd(Zd,Xd,Gd,Wd),Kd($d()))));jd(Yd),jd(Qd),jd(Jd);const rp=Hd(ep,Ud("tcp"),qd()),np=Hd(ep,Ud("udp"),qd()),sp=jd(Hd(rp,Kd($d())));jd(np);const op=Hd(np,Ud("quic"),Kd($d())),ip=Hd(np,Ud("quic-v1"),Kd($d())),ap=Vd(op,ip);jd(op),jd(ip);const cp=Vd(ep,rp,np,op,ip),lp=Vd(Hd(cp,Ud("ws"),Kd($d()))),up=jd(lp),hp=Vd(Hd(cp,Ud("wss"),Kd($d())),Hd(cp,Ud("tls"),Kd(Hd(Ud("sni"),Bd())),Ud("ws"),Kd($d()))),dp=jd(hp),pp=Hd(np,Ud("webrtc-direct"),Kd(zd()),Kd(zd()),Kd($d())),fp=jd(pp),gp=Hd(ip,Ud("webtransport"),Kd(zd()),Kd(zd()),Kd($d())),mp=jd(gp),yp=Vd(lp,hp,Hd(rp,Kd($d())),Hd(ap,Kd($d())),Hd(ep,Kd($d())),pp,gp,$d());jd(yp);const bp=jd(Hd(yp,Ud("p2p-circuit"),$d())),wp=jd(Vd(Hd(yp,Ud("p2p-circuit"),Ud("webrtc"),Kd($d())),Hd(yp,Ud("webrtc"),Kd($d())),Hd(Ud("webrtc"),Kd($d()))));jd(Vd(Hd(ep,Ud("tcp"),qd(),Ud("http"),Kd($d())),Hd(ep,Ud("http"),Kd($d()))));jd(Vd(Hd(ep,Ud("tcp"),Vd(Hd(Ud("443"),Ud("http")),Hd(qd(),Ud("https")),Hd(qd(),Ud("tls"),Ud("http"))),Kd($d())),Hd(ep,Ud("tls"),Ud("http"),Kd($d())),Hd(ep,Ud("https"),Kd($d()))));jd(Vd(Hd(Ud("memory"),Bd(),Kd($d()))));class vp extends Td{constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??Pd.protocolPrefix}/id/1.0.0`,log:e.logger.forComponent("libp2p:identify")}),(t.runOnConnectionOpen??Pd.runOnConnectionOpen)&&e.events.addEventListener("connection:open",(e=>{const t=e.detail;this.identify(t).catch((e=>{e.name!==_o.name&&this.log.error("error during identify trigged by connection:open",e)}))}))}[zo]=["@libp2p/identify"];async _identify(e,t={}){let r;if(null==t.signal){const e=AbortSignal.timeout(this.timeout);t={...t,signal:e}}try{r=await e.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const n=xd(r,{maxDataLength:this.maxMessageSize}).pb(kd),s=await n.read(t);return await r.close(t),s}catch(e){throw r?.abort(e),e}}async identify(e,t={}){const r=await this._identify(e,t),{publicKey:n,protocols:s,observedAddr:o}=r;if(null==n)throw new Ro("public key was missing from identify message");const i=mu(ou(n).toCID());if(!e.remotePeer.equals(i))throw new Ro("identified peer does not match the expected peer");if(this.peerId.equals(i))throw new Ro("identified peer is our own peer id?");return this.maybeAddObservedAddress(o),this.log("identify completed for peer %p and protocols %o",i,s),async function(e,t,r,n,s){if(r("received identify from %p",n.remotePeer),null==s)throw new Ro("message was null or undefined");const o={};if(s.listenAddrs.length>0&&(o.addresses=s.listenAddrs.map((e=>({isCertified:!1,multiaddr:Ri(e)})))),s.protocols.length>0&&(o.protocols=s.protocols),null!=s.publicKey){const e=ou(s.publicKey);if(!fu(e).equals(n.remotePeer))throw new Ro("public key did not match remote PeerId");o.publicKey=e}let i;if(null!=s.signedPeerRecord){r.trace("received signedPeerRecord from %p",n.remotePeer);let t=s.signedPeerRecord;const a=await pd.openAndCertify(t,yd.DOMAIN);let c=yd.createFromProtobuf(a.payload);const l=mu(a.publicKey.toCID());if(!c.peerId.equals(l))throw new Ro("signing key does not match PeerId in the PeerRecord");if(!n.remotePeer.equals(c.peerId))throw new Ro("signing key does not match remote PeerId");let u;try{u=await e.get(c.peerId)}catch(e){if("NotFoundError"!==e.name)throw e}if(null!=u&&(o.metadata=u.metadata,null!=u.peerRecordEnvelope)){const e=pd.createFromProtobuf(u.peerRecordEnvelope),n=yd.createFromProtobuf(e.payload);n.seqNumber>=c.seqNumber&&(r("sequence number was lower or equal to existing sequence number - stored: %d received: %d",n.seqNumber,c.seqNumber),c=n,t=u.peerRecordEnvelope)}o.peerRecordEnvelope=t,o.addresses=c.multiaddrs.map((e=>({isCertified:!0,multiaddr:e}))),i={seq:c.seqNumber,addresses:c.multiaddrs}}else r("%p did not send a signed peer record",n.remotePeer);if(r.trace("patching %p with",n.remotePeer,o),await e.patch(n.remotePeer,o),null!=s.agentVersion||null!=s.protocolVersion){const t={};null!=s.agentVersion&&(t.AgentVersion=tt(s.agentVersion)),null!=s.protocolVersion&&(t.ProtocolVersion=tt(s.protocolVersion)),r.trace("merging %p metadata",n.remotePeer,t),await e.merge(n.remotePeer,{metadata:t})}const a={peerId:n.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map((e=>Ri(e))),observedAddr:null==s.observedAddr?void 0:Ri(s.observedAddr),protocols:s.protocols,signedPeerRecord:i,connection:n};return t.safeDispatchEvent("peer:identify",{detail:a}),a}(this.peerStore,this.events,this.log,e,r)}maybeAddObservedAddress(e){const t=function(e){if(null!=e&&e.length>0)try{return Ri(e)}catch{}}(e);if(null==t)return;if(this.log.trace("our observed address was %a",t),Od(t))return void this.log.trace("our observed address was private");const r=t.getComponents();r[0].code!==ei&&(42!==r[0].code||r[1].code!==ei)||function(e){try{for(const{code:r,value:n}of e.getComponents())if(null!=n&&r===ei)return t=n,new xi("2000::/3").contains(t)}catch{}var t;return!1}(t)?sp.exactMatch(t)||(this.log.trace("storing the observed address"),this.addressManager.addObservedAddr(t)):this.log.trace("our observed address was IPv6 but not a global unicast address")}async handleProtocol(e){const{connection:t,stream:r}=e,n=AbortSignal.timeout(this.timeout);try{const e=await this.peerStore.get(this.peerId),s=this.addressManager.getAddresses().map((e=>e.decapsulateCode(function(e){const t=di.getProtocol(e);return{code:t.code,size:t.size??0,name:t.name,resolvable:!!t.resolvable,path:!!t.path}}("p2p").code)));let o=e.peerRecordEnvelope;if(s.length>0&&null==o){const e=new yd({peerId:this.peerId,multiaddrs:s});o=(await pd.seal(e,this.privateKey)).marshal().subarray()}let i=t.remoteAddr.bytes;tp.matches(t.remoteAddr)||(i=void 0);const a=xd(r).pb(kd);await a.write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:iu(this.privateKey.publicKey),listenAddrs:s.map((e=>e.bytes)),signedPeerRecord:o,observedAddr:i,protocols:e.protocols},{signal:n}),await r.close({signal:n})}catch(e){this.log.error("could not respond to identify request",e),r.abort(e)}}}function Ep(e={}){return t=>new vp(t,e)}function Sp(e,t){const r=function(e){if(null!=e){if("function"==typeof e[Symbol.iterator])return e[Symbol.iterator]();if("function"==typeof e[Symbol.asyncIterator])return e[Symbol.asyncIterator]();if("function"==typeof e.next)return e}throw Error("argument is not an iterator or iterable")}(e).return?.();var n;null!=(n=r)&&"function"==typeof n.then&&"function"==typeof n.catch&&"function"==typeof n.finally&&r.catch((e=>{t.error("could not cause iterator to return",e)}))}const Ap=()=>{const e=Error("Delay aborted");return e.name="AbortError",e},Cp=new WeakMap;const Ip=function({clearTimeout:e,setTimeout:t}={}){return(r,{value:n,signal:s}={})=>{if(s?.aborted)return Promise.reject(Ap());let o,i,a;const c=e??clearTimeout,l=()=>{c(o),a(Ap())},u=new Promise(((e,c)=>{i=()=>{s&&s.removeEventListener("abort",l),e(n)},a=c,o=(t??setTimeout)(i,r)}));return s&&s.addEventListener("abort",l,{once:!0}),Cp.set(u,(()=>{c(o),o=null,i()})),u}}();class xp extends Error{remainingPoints;msBeforeNext;consumedPoints;isFirstInDuration;constructor(e="Rate limit exceeded",t){super(e),this.name="RateLimitError",this.remainingPoints=t.remainingPoints,this.msBeforeNext=t.msBeforeNext,this.consumedPoints=t.consumedPoints,this.isFirstInDuration=t.isFirstInDuration}}let kp=class extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}};class Pp{memoryStorage;points;duration;blockDuration;execEvenly;execEvenlyMinDelayMs;keyPrefix;constructor(e={}){this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.execEvenly=e.execEvenly??!1,this.execEvenlyMinDelayMs=e.execEvenlyMinDelayMs??1e3*this.duration/this.points,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new Tp}async consume(e,t=1,r={}){const n=this.getKey(e),s=this._getKeySecDuration(r);let o=this.memoryStorage.incrby(n,t,s);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(n,o.consumedPoints,this.blockDuration)),new xp("Rate limit exceeded",o);if(this.execEvenly&&o.msBeforeNext>0&&!o.isFirstInDuration){let e=Math.ceil(o.msBeforeNext/(o.remainingPoints+2));e<this.execEvenlyMinDelayMs&&(e=o.consumedPoints*this.execEvenlyMinDelayMs),await Ip(e)}return o}penalty(e,t=1,r={}){const n=this.getKey(e),s=this._getKeySecDuration(r),o=this.memoryStorage.incrby(n,t,s);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,r={}){const n=this.getKey(e),s=this._getKeySecDuration(r),o=this.memoryStorage.incrby(n,-t,s);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const r=1e3*t,n=this.points+1;return this.memoryStorage.set(this.getKey(e),n,t),{remainingPoints:0,msBeforeNext:0===r?-1:r,consumedPoints:n,isFirstInDuration:!1}}set(e,t,r=0){const n=1e3*(r>=0?r:this.duration);return this.memoryStorage.set(this.getKey(e),t,r),{remainingPoints:0,msBeforeNext:0===n?-1:n,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return null!=t&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return null!=e?.customDuration&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class Tp{storage;constructor(){this.storage=new Map}incrby(e,t,r){const n=this.storage.get(e);if(null!=n){const s=null!=n.expiresAt?n.expiresAt.getTime()-(new Date).getTime():-1;return null==n.expiresAt||s>0?(n.value+=t,{remainingPoints:0,msBeforeNext:s,consumedPoints:n.value,isFirstInDuration:!1}):this.set(e,t,r)}return this.set(e,t,r)}set(e,t,r){const n=1e3*r,s=this.storage.get(e);null!=s&&clearTimeout(s.timeoutId);const o={value:t,expiresAt:n>0?new Date(Date.now()+n):void 0};return this.storage.set(e,o),n>0&&(o.timeoutId=setTimeout((()=>{this.storage.delete(e)}),n),null!=o.timeoutId.unref&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:0===n?-1:n,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(null!=t){return{remainingPoints:0,msBeforeNext:null!=t.expiresAt?t.expiresAt.getTime()-(new Date).getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}}delete(e){const t=this.storage.get(e);return null!=t&&(null!=t.timeoutId&&clearTimeout(t.timeoutId),this.storage.delete(e),!0)}}var _p;(e=>{e[e.NEW_STREAM=0]="NEW_STREAM",e[e.MESSAGE_RECEIVER=1]="MESSAGE_RECEIVER",e[e.MESSAGE_INITIATOR=2]="MESSAGE_INITIATOR",e[e.CLOSE_RECEIVER=3]="CLOSE_RECEIVER",e[e.CLOSE_INITIATOR=4]="CLOSE_INITIATOR",e[e.RESET_RECEIVER=5]="RESET_RECEIVER",e[e.RESET_INITIATOR=6]="RESET_INITIATOR"})(_p||(_p={}));const Rp=Object.freeze({0:"NEW_STREAM",1:"MESSAGE_RECEIVER",2:"MESSAGE_INITIATOR",3:"CLOSE_RECEIVER",4:"CLOSE_INITIATOR",5:"RESET_RECEIVER",6:"RESET_INITIATOR"}),Lp=Object.freeze({NEW_STREAM:_p.NEW_STREAM,MESSAGE:_p.MESSAGE_INITIATOR,CLOSE:_p.CLOSE_INITIATOR,RESET:_p.RESET_INITIATOR}),Dp=Object.freeze({MESSAGE:_p.MESSAGE_RECEIVER,CLOSE:_p.CLOSE_RECEIVER,RESET:_p.RESET_RECEIVER}),Np=1<<20;class Mp{_buffer;_headerInfo;_maxMessageSize;_maxUnprocessedMessageQueueSize;constructor(e=Np,t=4194304){this._buffer=new ns,this._headerInfo=null,this._maxMessageSize=e,this._maxUnprocessedMessageQueueSize=t}write(e){if(null==e||0===e.length)return[];if(this._buffer.append(e),this._buffer.byteLength>this._maxUnprocessedMessageQueueSize)throw new Ro("Unprocessed message queue size too large!");const t=[];for(;0!==this._buffer.length;){if(null==this._headerInfo)try{this._headerInfo=this._decodeHeader(this._buffer)}catch(e){if("InvalidMessageError"===e.name)throw e;break}const{id:e,type:r,length:n,offset:s}=this._headerInfo;if(this._buffer.length-s<n)break;const o={id:e,type:r};r!==_p.NEW_STREAM&&r!==_p.MESSAGE_INITIATOR&&r!==_p.MESSAGE_RECEIVER||(o.data=this._buffer.sublist(s,s+n)),t.push(o),this._buffer.consume(s+n),this._headerInfo=null}return t}_decodeHeader(e){const{value:t,offset:r}=Up(e),{value:n,offset:s}=Up(e,r),o=7&t;if(null==Rp[o])throw Error("Invalid type received: "+o);if(n>this._maxMessageSize)throw new Ro("Message size too large");return{id:t>>3,type:o,offset:r+s,length:n}}}const Op=128,Fp=127;function Up(e,t=0){let r,n=0,s=0,o=t;const i=e.length;do{if(o>=i||s>49)throw t=0,new RangeError("Could not decode varint");r=e.get(o++),n+=s<28?(r&Fp)<<s:(r&Fp)*Math.pow(2,s),s+=7}while(r>=Op);return{value:n,offset:t=o-t}}const Bp=10240;const qp=new class{_pool;_poolOffset;constructor(){this._pool=t(Bp),this._poolOffset=0}write(e,r){const n=this._pool;let s=this._poolOffset;h(e.id<<3|e.type,n,s),s+=c(e.id<<3|e.type),e.type!==_p.NEW_STREAM&&e.type!==_p.MESSAGE_INITIATOR&&e.type!==_p.MESSAGE_RECEIVER||null==e.data?(h(0,n,s),s+=c(0)):(h(e.data.length,n,s),s+=c(e.data.length));const o=n.subarray(this._poolOffset,s);Bp-s<100?(this._pool=t(Bp),this._poolOffset=0):this._poolOffset=s,r.append(o),e.type!==_p.NEW_STREAM&&e.type!==_p.MESSAGE_INITIATOR&&e.type!==_p.MESSAGE_RECEIVER||null==e.data||r.append(e.data)}};class $p extends Error{constructor(e="Stream input buffer error"){super(e),this.name="StreamInputBufferError"}}function zp(e){return null!=e&&("function"==typeof e.then&&"function"==typeof e.catch&&"function"==typeof e.finally)}class Kp{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(e){this.sinkController=new AbortController,this.sinkEnd=fs(),this.closed=fs(),this.log=e.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=e.id,this.metadata=e.metadata??{},this.direction=e.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=e.sendCloseWriteTimeout??5e3,this.onEnd=e.onEnd,this.onCloseRead=e.onCloseRead,this.onCloseWrite=e.onCloseWrite,this.onReset=e.onReset,this.onAbort=e.onAbort,this.source=this.streamSource=bs({onEnd:e=>{null!=e?this.log.trace("source ended with error",e):this.log.trace("source ended"),this.onSourceEnd(e)}}),this.sink=this.sink.bind(this)}async sink(e){if("ready"!==this.writeStatus)throw new Co(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";const t={signal:this.sinkController.signal};if("outbound"===this.direction){const e=this.sendNewStream(t);zp(e)&&await e}const r=()=>{Sp(e,this.log)};try{this.sinkController.signal.addEventListener("abort",r),this.log.trace("sink reading from source");for await(let r of e){r=r instanceof Uint8Array?new ns(r):r;const e=this.sendData(r,t);zp(e)&&(this.sendingData=fs(),await e,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",r)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),"writing"===this.writeStatus&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(e){throw this.log.trace("sink ended with error, calling abort with error",e),this.abort(e),e}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(e){null==this.timeline.closeRead&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",null!=e&&null==this.endErr&&(this.endErr=e),this.onCloseRead?.(),null!=this.timeline.closeWrite?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),"aborted"!==this.status&&"reset"!==this.status&&(this.status="closed"),null!=this.onEnd&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(e){null==this.timeline.closeWrite&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",null!=e&&null==this.endErr&&(this.endErr=e),this.onCloseWrite?.(),null!=this.timeline.closeRead?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),"aborted"!==this.status&&"reset"!==this.status&&(this.status="closed"),null!=this.onEnd&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(e){"open"===this.status&&(this.log.trace("closing gracefully"),this.status="closing",await vs(Promise.all([this.closeWrite(e),this.closeRead(e),this.closed.promise]),e?.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(e={}){if("closing"===this.readStatus||"closed"===this.readStatus)return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const t=this.readStatus;this.readStatus="closing","reset"!==this.status&&"aborted"!==this.status&&null==this.timeline.closeRead&&(this.log.trace("send close read to remote"),await this.sendCloseRead(e)),"ready"===t&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(e={}){"closing"!==this.writeStatus&&"closed"!==this.writeStatus&&(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),"ready"===this.writeStatus&&(this.log.trace("sink was never sunk, sink an empty array"),await vs(this.sink([]),e.signal)),"writing"===this.writeStatus&&(null!=this.sendingData&&await vs(this.sendingData.promise,e.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await vs(this.sinkEnd.promise,e.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(e){if("closed"===this.status||"aborted"===this.status||"reset"===this.status)return;this.log("abort with error",e),this.log("try to send reset to remote");const t=this.sendReset();zp(t)&&t.catch((e=>{this.log.error("error sending reset message",e)})),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(e),this.onAbort?.(e)}reset(){if("closed"===this.status||"aborted"===this.status||"reset"===this.status)return;const e=new Ao("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(e),this.onReset?.()}_closeSinkAndSource(e){this._closeSink(e),this._closeSource(e)}_closeSink(e){"writing"===this.writeStatus&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(e)}_closeSource(e){"closing"!==this.readStatus&&"closed"!==this.readStatus&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(e))}remoteCloseWrite(){"closing"!==this.readStatus&&"closed"!==this.readStatus?(this.log.trace("remote close write"),this._closeSource()):this.log("received remote close write but local source is already closed")}remoteCloseRead(){"closing"!==this.writeStatus&&"closed"!==this.writeStatus?(this.log.trace("remote close read"),this._closeSink()):this.log("received remote close read but local sink is already closed")}destroy(){"closed"!==this.status&&"aborted"!==this.status&&"reset"!==this.status?(this.log.trace("stream destroyed"),this._closeSinkAndSource()):this.log("received destroy but we are already closed")}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}class Vp extends Kp{name;streamId;send;types;maxDataSize;constructor(e){super(e),this.types="outbound"===e.direction?Lp:Dp,this.send=e.send,this.name=e.name,this.streamId=e.streamId,this.maxDataSize=e.maxDataSize}async sendNewStream(){await this.send({id:this.streamId,type:Lp.NEW_STREAM,data:new ns(tt(this.name))})}async sendData(e){for(e=e.sublist();e.byteLength>0;){const t=Math.min(e.byteLength,this.maxDataSize);await this.send({id:this.streamId,type:this.types.MESSAGE,data:e.sublist(0,t)}),e.consume(t)}}async sendReset(){await this.send({id:this.streamId,type:this.types.RESET})}async sendCloseWrite(){await this.send({id:this.streamId,type:this.types.CLOSE})}async sendCloseRead(){}}function Hp(e){const t={...e,type:`${Rp[e.type]} (${e.type})`};return e.type===_p.NEW_STREAM&&(t.data=mn(e.data instanceof Uint8Array?e.data:e.data.subarray())),e.type!==_p.MESSAGE_INITIATOR&&e.type!==_p.MESSAGE_RECEIVER||(t.data=mn(e.data instanceof Uint8Array?e.data:e.data.subarray(),"base16")),t}class jp{protocol="/mplex/6.7.0";sink;source;log;_streamId;_streams;_init;_source;closeController;rateLimiter;closeTimeout;logger;constructor(e,t){t=t??{},this.log=e.logger.forComponent("libp2p:mplex"),this.logger=e.logger,this._streamId=0,this._streams={initiators:new Map,receivers:new Map},this._init=t,this.closeTimeout=t.closeTimeout??500,this.sink=this._createSink(),this._source=bs({objectMode:!0,onEnd:()=>{for(const e of this._streams.initiators.values())e.destroy();for(const e of this._streams.receivers.values())e.destroy()}}),this.source=Is(this._source,(e=>async function*(e){for await(const t of e){const e=new ns;qp.write(t,e),yield e}}(e))),this.closeController=new AbortController,this.rateLimiter=new Pp({points:t.disconnectThreshold??5,duration:1})}get streams(){const e=[];for(const t of this._streams.initiators.values())e.push(t);for(const t of this._streams.receivers.values())e.push(t);return e}newStream(e){if(this.closeController.signal.aborted)throw new So("Muxer already closed");const t=this._streamId++;e=null==e?t.toString():e.toString();const r=this._streams.initiators;return this._newStream({id:t,name:e,type:"initiator",registry:r})}async close(e){if(this.closeController.signal.aborted)return;const t=e?.signal??AbortSignal.timeout(this.closeTimeout);try{await Promise.all(this.streams.map((async e=>e.close({signal:t})))),this._source.end(),await this._source.onEmpty({signal:t}),this.closeController.abort()}catch(e){this.abort(e)}}abort(e){this.closeController.signal.aborted||(this.streams.forEach((t=>{t.abort(e)})),this.closeController.abort(e))}_newReceiverStream(e){const{id:t,name:r}=e,n=this._streams.receivers;return this._newStream({id:t,name:r,type:"receiver",registry:n})}_newStream(e){const{id:t,name:r,type:n,registry:s}=e;if(this.log("new %s stream %s",n,t),"initiator"===n&&this._streams.initiators.size===(this._init.maxOutboundStreams??1024))throw new Uo("Too many outbound streams open");if(s.has(t))throw Error(`${n} stream ${t} already exists!`);const o=function(e){const{id:t,name:r,send:n,onEnd:s,type:o="initiator",maxMsgSize:i=Np}=e;return new Vp({id:"initiator"===o?"i"+t:"r"+t,streamId:t,name:""+(r??t),direction:"initiator"===o?"outbound":"inbound",maxDataSize:i,onEnd:s,send:n,log:e.logger.forComponent(`libp2p:mplex:stream:${o}:${t}`)})}({id:t,name:r,send:async e=>{this.log.enabled&&this.log.trace("%s stream %s send",n,t,Hp(e)),this._source.push(e)},type:n,onEnd:()=>{this.log("%s stream with id %s and protocol %s ended",n,t,o.protocol),s.delete(t),null!=this._init.onStreamEnd&&this._init.onStreamEnd(o)},maxMsgSize:this._init.maxMsgSize,logger:this.logger});return s.set(t,o),o}_createSink(){return async e=>{const t=()=>{Sp(e,this.log)};this.closeController.signal.addEventListener("abort",t);try{const t=new Mp(this._init.maxMsgSize,this._init.maxUnprocessedMessageQueueSize);for await(const r of e)for(const e of t.write(r))await this._handleIncoming(e);this._source.end()}catch(e){this.log("error in sink",e),this._source.end(e)}finally{this.closeController.signal.removeEventListener("abort",t)}}}async _handleIncoming(e){const{id:t,type:r}=e;if(this.log.enabled&&this.log.trace("incoming message",Hp(e)),e.type===_p.NEW_STREAM){if(this._streams.receivers.size===(this._init.maxInboundStreams??1024)){this.log("too many inbound streams open"),this._source.push({id:t,type:_p.RESET_RECEIVER});try{await this.rateLimiter.consume("new-stream",1)}catch{return this.log("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection"),void this.abort(Error("Too many open streams"))}return}const r=this._newReceiverStream({id:t,name:mn(e.data instanceof Uint8Array?e.data:e.data.subarray())});return void(null!=this._init.onIncomingStream&&this._init.onIncomingStream(r))}const n=(1&~r?this._streams.receivers:this._streams.initiators).get(t);if(null==n){this.log("missing stream %s for message type %s",t,Rp[r]);try{await this.rateLimiter.consume("missing-stream",1)}catch{return this.log("rate limit hit when receiving messages for streams that do not exist - closing remote connection"),void this.abort(Error("Too many messages for missing streams"))}return}const s=this._init.maxStreamBufferSize??4194304;try{switch(r){case _p.MESSAGE_INITIATOR:case _p.MESSAGE_RECEIVER:if(n.sourceReadableLength()>s)throw this._source.push({id:e.id,type:r===_p.MESSAGE_INITIATOR?_p.RESET_RECEIVER:_p.RESET_INITIATOR}),new $p("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers");n.sourcePush(e.data);break;case _p.CLOSE_INITIATOR:case _p.CLOSE_RECEIVER:n.remoteCloseWrite();break;case _p.RESET_INITIATOR:case _p.RESET_RECEIVER:n.reset();break;default:this.log("unknown message type %s",r)}}catch(e){this.log.error("error while processing message",e),n.abort(e)}}}class Gp{protocol="/mplex/6.7.0";_init;components;constructor(e,t={}){this.components=e,this._init=t}[Symbol.toStringTag]="@libp2p/mplex";[zo]=["@libp2p/stream-multiplexing"];createStreamMuxer(e={}){return new jp(this.components,{...e,...this._init})}}function Wp(e={}){return t=>new Gp(t,e)}function Xp(e){if(null!=e[Symbol.asyncIterator])return(async()=>{for await(const t of e)return t})();for(const t of e)return t}class Zp{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;log;constructor(e,t={}){this.components=e,this.log=e.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${t.protocolPrefix??"ipfs"}/ping/1.0.0`,this.timeout=t.timeout??1e4,this.maxInboundStreams=t.maxInboundStreams??2,this.maxOutboundStreams=t.maxOutboundStreams??1,this.runOnLimitedConnection=t.runOnLimitedConnection??!0,this.handleMessage=this.handleMessage.bind(this)}[Symbol.toStringTag]="@libp2p/ping";async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(e){this.log("incoming ping from %p",e.connection.remotePeer);const{stream:t}=e,r=Date.now();AbortSignal.timeout(this.timeout).addEventListener("abort",(()=>{t?.abort(new Do("ping timeout"))})),Is(t,(async function*(e){let r=0;for await(const n of e){if(r+=n.byteLength,r>32)return void t?.abort(new Ro("Too much data received"));yield n}}),t).catch((r=>{this.log.error("incoming ping from %p failed with error",e.connection.remotePeer,r),t?.abort(r)})).finally((()=>{const t=Date.now()-r;this.log("incoming ping from %p complete in %dms",e.connection.remotePeer,t)}))}async ping(e,t={}){this.log("pinging %p",e);const r=Date.now(),n=Pl(32),s=await this.components.connectionManager.openConnection(e,t);let o,i=()=>{};if(null==t.signal){const e=AbortSignal.timeout(this.timeout);t={...t,signal:e}}try{o=await s.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection}),i=()=>{o?.abort(new go)},t.signal?.addEventListener("abort",i,{once:!0});const e=await Is([n],o,(async e=>Xp(e))),a=Date.now()-r;if(null==e)throw new Lo(`Did not receive a ping ack after ${a}ms`);if(!Jn(n,e.subarray()))throw new Lo(`Received wrong ping ack after ${a}ms`);return this.log("ping %p complete in %dms",s.remotePeer,a),a}catch(e){throw this.log.error("error while pinging %p",s.remotePeer,e),o?.abort(e),e}finally{t.signal?.removeEventListener("abort",i),null!=o&&await o.close()}}}function Yp(e={}){return t=>new Zp(t,e)}const Qp=[6,53,56,54,55];function Jp(e){return tf("sni",e)?.value}function ef(e){const t=tf("tcp",e)?.value;return null==t?"":":"+t}function tf(e,t){return t.find((t=>t.name===e))}function rf(e){return e.some((({code:e})=>448===e))}function nf(e,t){const r=sf[e.name];if(null==r)throw Error("Can't interpret protocol "+e.name);const n=r(e,t);return e.code===ei?`[${n}]`:n}const sf={ip4(e){return e.value},ip6(e,t){return 0===t.length?e.value:`[${e.value}]`},tcp(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");return`tcp://${nf(r,t)}:${e.value}`},udp(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");return`udp://${nf(r,t)}:${e.value}`},dnsaddr(e){return e.value},dns4(e){return e.value},dns6(e){return e.value},dns(e){return e.value},ipfs(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");return""+nf(r,t)},p2p(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");return""+nf(r,t)},http(e,t){const r=rf(t),n=Jp(t),s=ef(t);if(r&&null!=n)return`https://${n}${s}`;const o=r?"https://":"http://",i=t.pop();if(null==i)throw Error("Unexpected end of multiaddr");let a=nf(i,t);return a=a?.replace("tcp://",""),`${o}${a}`},"http-path"(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");return`${nf(r,t)}${decodeURIComponent(e.value??"")}`},tls(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");return nf(r,t)},sni(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");return nf(r,t)},https(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");let n=nf(r,t);return n=n?.replace("tcp://",""),"https://"+n},ws(e,t){const r=rf(t),n=Jp(t),s=ef(t);if(r&&null!=n)return`wss://${n}${s}`;const o=r?"wss://":"ws://",i=t.pop();if(null==i)throw Error("Unexpected end of multiaddr");let a=nf(i,t);return a=a?.replace("tcp://",""),`${o}${a}`},wss(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");let n=nf(r,t);return n=n?.replace("tcp://",""),"wss://"+n}};var of,af,cf=async e=>{if(e.readyState>=2)throw Error("socket closed");1!==e.readyState&&await new Promise(((t,r)=>{function n(){e.removeEventListener("open",s),e.removeEventListener("error",o)}function s(){n(),t()}function o(t){n(),r(t.error??Error("connect ECONNREFUSED "+e.url))}e.addEventListener("open",s),e.addEventListener("error",o)}))},lf=(e,t)=>{(t=t??{}).closeOnEnd=!1!==t.closeOnEnd;return async r=>{for await(const t of r){try{await cf(e)}catch(e){if("socket closed"===e.message)break;throw e}if(e.readyState===e.CLOSING||e.readyState===e.CLOSED)break;e.send(t)}null!=t.closeOnEnd&&e.readyState<=1&&await new Promise(((t,r)=>{e.addEventListener("close",(e=>{if(e.wasClean||1006===e.code)t();else{const t=Object.assign(Error("ws error"),{event:e});r(t)}})),setTimeout((()=>{e.close()}))}))}},uf={},hf={};var df=function(){if(af)return uf;af=1,Object.defineProperty(uf,"__esModule",{value:!0});const e=function(){if(of)return hf;of=1,Object.defineProperty(hf,"__esModule",{value:!0});class e{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(e){if(this.isStopped)return;const t={value:e,done:!1};if(this.pullQueue.length){const e=this.pullQueue.shift();e&&e.resolve(t)}else this.pushQueue.push(Promise.resolve(t)),void 0!==this.highWaterMark&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const e of this.pullQueue)e.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(e){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const t of this.pullQueue)t.reject(e);this.pullQueue.length=0}else{const t=Promise.reject(e);t.catch((()=>{})),this.pushQueue.push(t)}}remove(){Promise.resolve().then((()=>{this.removeCallback&&this.removeCallback()}))}[Symbol.asyncIterator](){return{next:()=>{const e=this.pushQueue.shift();return e?(void 0!==this.lowWaterMark&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),e):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise(((e,t)=>{this.pullQueue.push({resolve:e,reject:t})}))},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}class t{constructor(t,{highWaterMark:r=100,lowWaterMark:n=1}={}){const s=new e;s.highWaterMark=r,s.lowWaterMark=n,s.removeCallback=t({push:e=>s.push(e),stop:()=>s.stop(),fail:e=>s.fail(e),on(e,t){s.eventHandlers[e]=t}})||(()=>{}),this[Symbol.asyncIterator]=()=>s[Symbol.asyncIterator](),Object.freeze(this)}}return hf.EventIterator=t,hf.default=t,hf}();return uf.EventIterator=e.EventIterator,uf.subscribe=function(t,r,n){return new e.EventIterator((({push:e})=>(this.addEventListener(t,e,r),()=>this.removeEventListener(t,e,r))),n)},uf.default=e.EventIterator,uf}();function pf(e){return e instanceof ArrayBuffer||"ArrayBuffer"===e?.constructor?.name&&"number"==typeof e?.byteLength}var ff=(e,t)=>{t=t??{};const r=(e=>{e.binaryType="arraybuffer";const t=async()=>{await new Promise(((t,r)=>{if(s)return void t();if(null!=n)return void r(n);const o=t=>{e.removeEventListener("open",i),e.removeEventListener("error",a),t()},i=()=>{o(t)},a=t=>{o((()=>{r(t.error??Error("connect ECONNREFUSED "+e.url))}))};e.addEventListener("open",i),e.addEventListener("error",a)}))},r=async function*(){const r=new df.EventIterator((({push:t,stop:r,fail:n})=>{const s=e=>{let r=null;"string"==typeof e.data&&(r=tt(e.data)),pf(e.data)&&(r=new Uint8Array(e.data)),e.data instanceof Uint8Array&&(r=e.data),null!=r&&t(r)},o=e=>{n(e.error??Error("Socket error"))};return e.addEventListener("message",s),e.addEventListener("error",o),e.addEventListener("close",r),()=>{e.removeEventListener("message",s),e.removeEventListener("error",o),e.removeEventListener("close",r)}}),{highWaterMark:1/0});await t();for await(const e of r)yield pf(e)?new Uint8Array(e):e}();let n,s=1===e.readyState;return e.addEventListener("open",(()=>{s=!0,n=null})),e.addEventListener("close",(()=>{s=!1,n=null})),e.addEventListener("error",(t=>{s||(n=t.error??Error("connect ECONNREFUSED "+e.url))})),Object.assign(r,{connected:t})})(e);let n=t.remoteAddress,s=t.remotePort;if(null!=e.url)try{const t=new URL(e.url);n=t.hostname,s=parseInt(t.port,10)}catch{}if(null==n||null==s)throw Error("Remote connection did not have address and/or port");return{sink:lf(e,t),source:r,async connected(){await r.connected()},async close(){e.readyState!==e.CONNECTING&&e.readyState!==e.OPEN||await new Promise((t=>{e.addEventListener("close",(()=>{t()})),e.close()}))},destroy(){null!=e.terminate?e.terminate():e.close()},remoteAddress:n,remotePort:s,socket:e}},gf=WebSocket;const mf={"http:":"ws:","https:":"wss:"};function yf(e,t){t=t??{};const r=((e,t)=>{if(e.startsWith("//")&&(e=`${t?.protocol??"ws:"}${e}`),e.startsWith("/")&&null!=t){const r=t.protocol??"ws:",n=t.host,s=null!=t.port&&!0!==n?.endsWith(":"+t.port)?":"+t.port:"";e=`${r}//${n}${s}${e}`}const r=new URL(e);for(const[e,t]of Object.entries(mf))r.protocol===e&&(r.protocol=t);return r})(e,"undefined"==typeof window?void 0:window.location),n=new gf(r.toString(),t.websocket);return ff(n,t)}class bf extends Event{type;detail;constructor(e,t){super(e),this.type=e,this.detail=t}}function wf(e){return e.filter((e=>dp.exactMatch(e)||up.exactMatch(e)))}function vf(e){return e.filter((e=>dp.exactMatch(e)))}class Ef{log;init;logger;metrics;components;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:websockets"),this.logger=e.logger,this.components=e,this.init=t,null!=e.metrics&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}[po]=!0;[Symbol.toStringTag]="@libp2p/websockets";[zo]=["@libp2p/transport"];async dial(e,t){this.log("dialing %s",e),t=t??{};const r=function(e,t,r){const n=r.logger.forComponent("libp2p:websockets:maconn"),s=r.metrics,o=r.metricPrefix??"",i={log:n,async sink(t){try{await e.sink(async function*(){for await(const e of t)e instanceof Uint8Array?yield e:yield e.subarray()}())}catch(e){"aborted"!==e.type&&n.error(e)}},source:e.source,remoteAddr:t,timeline:{open:Date.now()},async close(t={}){const r=Date.now();if(null==t.signal){const e=AbortSignal.timeout(500);t={...t,signal:e}}const s=()=>{const{host:e,port:t}=i.remoteAddr.toOptions();n("timeout closing stream to %s:%s after %dms, destroying it manually",e,t,Date.now()-r),this.abort(new go("Socket close timeout"))};t.signal?.addEventListener("abort",s);try{await e.close()}catch(e){n.error("error closing WebSocket gracefully",e),this.abort(e)}finally{t.signal?.removeEventListener("abort",s),i.timeline.close=Date.now()}},abort(t){const{host:r,port:a}=i.remoteAddr.toOptions();n("timeout closing stream to %s:%s due to error",r,a,t),e.destroy(),i.timeline.close=Date.now(),s?.increment({[o+"error"]:!0})}};return e.socket.addEventListener("close",(()=>{s?.increment({[o+"close"]:!0}),null==i.timeline.close&&(i.timeline.close=Date.now())}),{once:!0}),i}(await this._connect(e,t),e,{logger:this.logger,metrics:this.metrics?.dialerEvents});this.log("new outbound connection %s",r.remoteAddr);const n=await t.upgrader.upgradeOutbound(r,t);return this.log("outbound connection %s upgraded",r.remoteAddr),n}async _connect(e,t){t?.signal?.throwIfAborted();const r=e.toOptions();this.log("dialing %s:%s",r.host,r.port);const n=fs(),s=yf(function(e){const t=Ri(e).getComponents(),r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");const n=sf[r.name];if(null==n)throw Error("No interpreter found for "+r.name);let s=n(r,t)??"";return Qp.includes(r.code)&&(s=s.replace(/^.*:\/\//,""),s="443"===r.value?"https://"+s:"http://"+s),(s.startsWith("http://")||s.startsWith("https://")||s.startsWith("ws://")||s.startsWith("wss://"))&&(s=new URL(s).toString(),s.endsWith("/")&&(s=s.substring(0,s.length-1))),s}(e),this.init);s.socket.addEventListener("error",(()=>{const t=new Eo("Could not connect to "+e.toString());this.log.error("connection error:",t),this.metrics?.dialerEvents.increment({error:!0}),n.reject(t)}));try{t.onProgress?.(new bf("websockets:open-connection")),await vs(Promise.race([s.connected(),n.promise]),t.signal)}catch(e){throw t.signal?.aborted&&this.metrics?.dialerEvents.increment({abort:!0}),s.close().catch((e=>{this.log.error("error closing raw socket",e)})),e}return this.log("connected %s",e),this.metrics?.dialerEvents.increment({connect:!0}),s}createListener(e){return function(){throw Error("WebSocket Servers can not be created in the browser!")}((this.logger,this.components.events,this.components.metrics),this.init)}listenFilter(e){return e=Array.isArray(e)?e:[e],null!=this.init?.filter?this.init?.filter(e):wf(e)}dialFilter(e){return this.listenFilter(e)}}function Sf(e={}){return t=>new Ef(t,e)}var Af,Cf={exports:{}};var If=(Af||(Af=1,function(e){var t={}.hasOwnProperty,r="~";function n(){}function s(e,t,r){this.fn=e,this.context=t,this.once=r||!1}function o(e,t,n,o,i){if("function"!=typeof n)throw new TypeError("The listener must be a function");var a=new s(n,o||e,i),c=r?r+t:t;return e._events[c]?e._events[c].fn?e._events[c]=[e._events[c],a]:e._events[c].push(a):(e._events[c]=a,e._eventsCount++),e}function i(e,t){0==--e._eventsCount?e._events=new n:delete e._events[t]}function a(){this._events=new n,this._eventsCount=0}Object.create&&(n.prototype=Object.create(null),(new n).__proto__||(r=!1)),a.prototype.eventNames=function(){var e,n,s=[];if(0===this._eventsCount)return s;for(n in e=this._events)t.call(e,n)&&s.push(r?n.slice(1):n);return Object.getOwnPropertySymbols?s.concat(Object.getOwnPropertySymbols(e)):s},a.prototype.listeners=function(e){var t=r?r+e:e,n=this._events[t];if(!n)return[];if(n.fn)return[n.fn];for(var s=0,o=n.length,i=Array(o);s<o;s++)i[s]=n[s].fn;return i},a.prototype.listenerCount=function(e){var t=r?r+e:e,n=this._events[t];return n?n.fn?1:n.length:0},a.prototype.emit=function(e,t,n,s,o,i){var a=r?r+e:e;if(!this._events[a])return!1;var c,l,u=this._events[a],h=arguments.length;if(u.fn){switch(u.once&&this.removeListener(e,u.fn,void 0,!0),h){case 1:return u.fn.call(u.context),!0;case 2:return u.fn.call(u.context,t),!0;case 3:return u.fn.call(u.context,t,n),!0;case 4:return u.fn.call(u.context,t,n,s),!0;case 5:return u.fn.call(u.context,t,n,s,o),!0;case 6:return u.fn.call(u.context,t,n,s,o,i),!0}for(l=1,c=Array(h-1);l<h;l++)c[l-1]=arguments[l];u.fn.apply(u.context,c)}else{var d,p=u.length;for(l=0;l<p;l++)switch(u[l].once&&this.removeListener(e,u[l].fn,void 0,!0),h){case 1:u[l].fn.call(u[l].context);break;case 2:u[l].fn.call(u[l].context,t);break;case 3:u[l].fn.call(u[l].context,t,n);break;case 4:u[l].fn.call(u[l].context,t,n,s);break;default:if(!c)for(d=1,c=Array(h-1);d<h;d++)c[d-1]=arguments[d];u[l].fn.apply(u[l].context,c)}}return!0},a.prototype.on=function(e,t,r){return o(this,e,t,r,!1)},a.prototype.once=function(e,t,r){return o(this,e,t,r,!0)},a.prototype.removeListener=function(e,t,n,s){var o=r?r+e:e;if(!this._events[o])return this;if(!t)return i(this,o),this;var a=this._events[o];if(a.fn)a.fn!==t||s&&!a.once||n&&a.context!==n||i(this,o);else{for(var c=0,l=[],u=a.length;c<u;c++)(a[c].fn!==t||s&&!a[c].once||n&&a[c].context!==n)&&l.push(a[c]);l.length?this._events[o]=1===l.length?l[0]:l:i(this,o)}return this},a.prototype.removeAllListeners=function(e){var t;return e?(t=r?r+e:e,this._events[t]&&i(this,t)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=r,a.EventEmitter=a,e.exports=a}(Cf)),Cf.exports),xf=Ln(If);class kf extends Error{constructor(e){super(e),this.name="TimeoutError"}}let Pf=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const Tf=e=>void 0===globalThis.DOMException?new Pf(e):new DOMException(e),_f=e=>{const t=void 0===e.reason?Tf("This operation was aborted."):e.reason;return t instanceof Error?t:Tf(t)};let Rf=class{#s=[];enqueue(e,t){const r={priority:(t={priority:0,...t}).priority,id:t.id,run:e};if(0===this.size||this.#s[this.size-1].priority>=t.priority)return void this.#s.push(r);const n=function(e,t,r){let n=0,s=e.length;for(;s>0;){const o=Math.trunc(s/2);let i=n+o;r(e[i],t)<=0?(n=++i,s-=o+1):s=o}return n}(this.#s,r,((e,t)=>t.priority-e.priority));this.#s.splice(n,0,r)}setPriority(e,t){const r=this.#s.findIndex((t=>t.id===e));if(-1===r)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[n]=this.#s.splice(r,1);this.enqueue(n.run,{priority:t,id:e})}dequeue(){const e=this.#s.shift();return e?.run}filter(e){return this.#s.filter((t=>t.priority===e.priority)).map((e=>e.run))}get size(){return this.#s.length}};class Lf extends xf{#o;#i;#a=0;#c;#l;#u=0;#h;#d;#s;#p;#f=0;#g;#m;#y;#b=1n;timeout;constructor(e){if(super(),!("number"==typeof(e={carryoverConcurrencyCount:!1,intervalCap:1/0,interval:0,concurrency:1/0,autoStart:!0,queueClass:Rf,...e}).intervalCap&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(void 0===e.interval||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#o=e.carryoverConcurrencyCount,this.#i=e.intervalCap===1/0||0===e.interval,this.#c=e.intervalCap,this.#l=e.interval,this.#s=new e.queueClass,this.#p=e.queueClass,this.concurrency=e.concurrency,this.timeout=e.timeout,this.#y=!0===e.throwOnTimeout,this.#m=!1===e.autoStart}get#w(){return this.#i||this.#a<this.#c}get#v(){return this.#f<this.#g}#E(){this.#f--,this.#S(),this.emit("next")}#A(){this.#C(),this.#I(),this.#d=void 0}get#x(){const e=Date.now();if(void 0===this.#h){const t=this.#u-e;if(!(t<0))return void 0===this.#d&&(this.#d=setTimeout((()=>{this.#A()}),t)),!0;this.#a=this.#o?this.#f:0}return!1}#S(){if(0===this.#s.size)return this.#h&&clearInterval(this.#h),this.#h=void 0,this.emit("empty"),0===this.#f&&this.emit("idle"),!1;if(!this.#m){const e=!this.#x;if(this.#w&&this.#v){const t=this.#s.dequeue();return!!t&&(this.emit("active"),t(),e&&this.#I(),!0)}}return!1}#I(){this.#i||void 0!==this.#h||(this.#h=setInterval((()=>{this.#C()}),this.#l),this.#u=Date.now()+this.#l)}#C(){0===this.#a&&0===this.#f&&this.#h&&(clearInterval(this.#h),this.#h=void 0),this.#a=this.#o?this.#f:0,this.#k()}#k(){for(;this.#S(););}get concurrency(){return this.#g}set concurrency(e){if(!("number"==typeof e&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#g=e,this.#k()}async#P(e){return new Promise(((t,r)=>{e.addEventListener("abort",(()=>{r(e.reason)}),{once:!0})}))}setPriority(e,t){this.#s.setPriority(e,t)}async add(e,t={}){return t.id??=""+this.#b++,t={timeout:this.timeout,throwOnTimeout:this.#y,...t},new Promise(((r,n)=>{this.#s.enqueue((async()=>{this.#f++,this.#a++;try{t.signal?.throwIfAborted();let n=e({signal:t.signal});t.timeout&&(n=function(e,t){const{milliseconds:r,fallback:n,message:s,customTimers:o={setTimeout,clearTimeout}}=t;let i,a;const c=new Promise(((c,l)=>{if("number"!=typeof r||1!==Math.sign(r))throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${r}\``);if(t.signal){const{signal:e}=t;e.aborted&&l(_f(e)),a=()=>{l(_f(e))},e.addEventListener("abort",a,{once:!0})}if(r===1/0)return void e.then(c,l);const u=new kf;i=o.setTimeout.call(void 0,(()=>{if(n)try{c(n())}catch(e){l(e)}else"function"==typeof e.cancel&&e.cancel(),!1===s?c():s instanceof Error?l(s):(u.message=s??`Promise timed out after ${r} milliseconds`,l(u))}),r),(async()=>{try{c(await e)}catch(e){l(e)}})()})).finally((()=>{c.clear(),a&&t.signal&&t.signal.removeEventListener("abort",a)}));return c.clear=()=>{o.clearTimeout.call(void 0,i),i=void 0},c}(Promise.resolve(n),{milliseconds:t.timeout})),t.signal&&(n=Promise.race([n,this.#P(t.signal)]));const s=await n;r(s),this.emit("completed",s)}catch(e){if(e instanceof kf&&!t.throwOnTimeout)return void r();n(e),this.emit("error",e)}finally{this.#E()}}),t),this.emit("add"),this.#S()}))}async addAll(e,t){return Promise.all(e.map((async e=>this.add(e,t))))}start(){return this.#m?(this.#m=!1,this.#k(),this):this}pause(){this.#m=!0}clear(){this.#s=new this.#p}async onEmpty(){0!==this.#s.size&&await this.#T("empty")}async onSizeLessThan(e){this.#s.size<e||await this.#T("next",(()=>this.#s.size<e))}async onIdle(){0===this.#f&&0===this.#s.size||await this.#T("idle")}async#T(e,t){return new Promise((r=>{const n=()=>{t&&!t()||(this.off(e,n),r())};this.on(e,n)}))}get size(){return this.#s.size}sizeBy(e){return this.#s.filter(e).length}get pending(){return this.#f}get isPaused(){return this.#m}}function Df(e){const t=[zf.A];return null==e?t:Array.isArray(e)?0===e.length?t:e:[e]}function Nf(e){return{Status:e.Status??0,TC:e.TC??e.flag_tc??!1,RD:e.RD??e.flag_rd??!1,RA:e.RA??e.flag_ra??!1,AD:e.AD??e.flag_ad??!1,CD:e.CD??e.flag_cd??!1,Question:(e.Question??e.questions??[]).map((e=>({name:e.name,type:zf[e.type]}))),Answer:(e.Answer??e.answers??[]).map((e=>({name:e.name,type:zf[e.type],TTL:e.TTL??e.ttl??60,data:e.data instanceof Uint8Array?mn(e.data):e.data})))}}function Mf(e,t={}){const r=new Lf({concurrency:t.queryConcurrency??4});return async(t,n={})=>{const s=new URLSearchParams;s.set("name",t),Df(n.types).forEach((e=>{s.append("type",zf[e])})),n.onProgress?.(new bf("dns:query",{detail:t}));const o=await r.add((async()=>{const t=await fetch(`${e}?${s}`,{headers:{accept:"application/dns-json"},signal:n?.signal});if(200!==t.status)throw Error(`Unexpected HTTP status: ${t.status} - ${t.statusText}`);const r=Nf(await t.json());return n.onProgress?.(new bf("dns:response",{detail:r})),r}),{signal:n.signal});if(null==o)throw Error("No DNS response received");return o}}var Of,Ff;var Uf=(Ff||(Ff=1,Of=e=>{if(!e)throw Error("hashlru must have a max value, of type number, greater than 0");var t=0,r=Object.create(null),n=Object.create(null);function s(s,o){r[s]=o,++t>=e&&(t=0,n=r,r=Object.create(null))}return{has:e=>void 0!==r[e]||void 0!==n[e],remove(e){void 0!==r[e]&&(r[e]=void 0),void 0!==n[e]&&(n[e]=void 0)},get(e){var t=r[e];return void 0!==t?t:void 0!==(t=n[e])?(s(e,t),t):void 0},set(e,t){void 0!==r[e]?r[e]=t:s(e,t)},clear(){r=Object.create(null),n=Object.create(null)}}}),Of),Bf=Ln(Uf);class qf{lru;constructor(e){this.lru=Bf(e)}get(e,t){let r=!0;const n=[];for(const s of t){const t=this.getAnswers(e,s);if(0===t.length){r=!1;break}n.push(...t)}if(r)return Nf({answers:n})}getAnswers(e,t){const r=`${e.toLowerCase()}-${t}`,n=this.lru.get(r);if(null!=n){const e=n.filter((e=>e.expires>Date.now())).map((({expires:e,value:t})=>({...t,TTL:Math.round((e-Date.now())/1e3),type:zf[t.type]})));return 0===e.length&&this.lru.remove(r),e}return[]}add(e,t){const r=`${e.toLowerCase()}-${t.type}`,n=this.lru.get(r)??[];n.push({expires:Date.now()+1e3*(t.TTL??60),value:t}),this.lru.set(r,n)}remove(e,t){const r=`${e.toLowerCase()}-${t}`;this.lru.remove(r)}clear(){this.lru.clear()}}class $f{resolvers;cache;constructor(e){var t;this.resolvers={},this.cache=(t=e.cacheSize??1e3,new qf(t)),Object.entries(e.resolvers??{}).forEach((([e,t])=>{Array.isArray(t)||(t=[t]),e.endsWith(".")||(e+="."),this.resolvers[e]=t})),null==this.resolvers["."]&&(this.resolvers["."]=[Mf("https://cloudflare-dns.com/dns-query"),Mf("https://dns.google/resolve")])}async query(e,t={}){const r=Df(t.types),n=!1!==t.cached?this.cache.get(e,r):void 0;if(null!=n)return t.onProgress?.(new bf("dns:cache",{detail:n})),n;const s=e.split(".").pop()+".",o=(this.resolvers[s]??this.resolvers["."]).sort((()=>Math.random()>.5?-1:1)),i=[];for(const n of o){if(!0===t.signal?.aborted)break;try{const s=await n(e,{...t,types:r});for(const t of s.Answer)this.cache.add(e,t);return s}catch(e){i.push(e),t.onProgress?.(new bf("dns:error",{detail:e}))}}if(1===i.length)throw i[0];throw new AggregateError(i,`DNS lookup of ${e} ${r} failed`)}}var zf;(e=>{e[e.A=1]="A",e[e.CNAME=5]="CNAME",e[e.TXT=16]="TXT",e[e.AAAA=28]="AAAA"})(zf||(zf={}));const Kf=-1,Vf={},Hf={};[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,Kf,"ip6zone"],[43,8,"ipcidr"],[53,Kf,"dns",!0],[54,Kf,"dns4",!0],[55,Kf,"dns6",!0],[56,Kf,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,Kf,"unix",!1,!0],[421,Kf,"ipfs"],[421,Kf,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,Kf,"garlic64"],[448,0,"tls"],[449,Kf,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,Kf,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,Kf,"http-path"],[777,Kf,"memory"]].forEach((e=>{const t=function(e,t,r,n,s){return{code:e,size:t,name:r,resolvable:!!n,path:!!s}}(...e);Hf[t.code]=t,Vf[t.name]=t}));const{code:jf}=function(e){if(null!=Vf[e])return Vf[e];throw Error("no protocol with name: "+e)}("dnsaddr");class Gf extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}const Wf=async function(e,t={}){const r=t.maxRecursiveDepth??32;if(0===r)throw new Gf("Max recursive depth reached");const[,n]=e.stringTuples().find((([e])=>e===jf))??[],s=t?.dns??function(e={}){return new $f(e)}(),o=await s.query("_dnsaddr."+n,{signal:t?.signal,types:[zf.TXT]}),i=e.getPeerId(),a=[];for(const e of o.Answer){const n=e.data.replace(/["']/g,"").trim().split("=")[1];if(null==n)continue;if(null!=i&&!n.includes(i))continue;const s=Ri(n);if(n.startsWith("/dnsaddr")){const e=await s.resolve({...t,maxRecursiveDepth:r-1});a.push(...e.map((e=>e.toString())))}else a.push(s.toString())}return a};var Xf,Zf,Yf,Qf;var Jf=function(){if(Qf)return Yf;Qf=1;const e=Zf?Xf:(Zf=1,Xf=e=>{if("[object Object]"!=={}.toString.call(e))return!1;const t=Object.getPrototypeOf(e);return null===t||t===Object.prototype}),{hasOwnProperty:t}=Object.prototype,{propertyIsEnumerable:r}=Object,n=(e,t,r)=>Object.defineProperty(e,t,{value:r,writable:!0,enumerable:!0,configurable:!0}),s=Yf,o={concatArrays:!1,ignoreUndefined:!1},i=e=>{const n=[];for(const r in e)t.call(e,r)&&n.push(r);if(Object.getOwnPropertySymbols){const t=Object.getOwnPropertySymbols(e);for(const s of t)r.call(e,s)&&n.push(s)}return n};function a(t){return Array.isArray(t)?function(e){const t=e.slice(0,0);return i(e).forEach((r=>{n(t,r,a(e[r]))})),t}(t):e(t)?function(e){const t=null===Object.getPrototypeOf(e)?Object.create(null):{};return i(e).forEach((r=>{n(t,r,a(e[r]))})),t}(t):t}const c=(e,t,r,s)=>(r.forEach((r=>{void 0===t[r]&&s.ignoreUndefined||(r in e&&e[r]!==Object.getPrototypeOf(e)?n(e,r,u(e[r],t[r],s)):n(e,r,a(t[r])))})),e),l=(e,r,s)=>{let o=e.slice(0,0),l=0;return[e,r].forEach((r=>{const u=[];for(let s=0;s<r.length;s++)t.call(r,s)&&(u.push(s+""),n(o,l++,r===e?r[s]:a(r[s])));o=c(o,r,i(r).filter((e=>!u.includes(e))),s)})),o};function u(t,r,n){return n.concatArrays&&Array.isArray(t)&&Array.isArray(r)?l(t,r,n):e(r)&&e(t)?c(t,r,i(r),n):a(r)}return Yf=function(...t){const r=u(a(o),this!==s&&this||{},o);let n={_:{}};for(const s of t)if(void 0!==s){if(!e(s))throw new TypeError("`"+s+"` is not an Option Object");n=u(n,{_:s},r)}return n._}}(),eg=Ln(Jf);const tg={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter(e){return e}},connectionManager:{resolvers:{dnsaddr:Wf}},transportManager:{faultTolerance:fo.FATAL_ALL}};async function rg(e){const t=eg(tg,e);if(null===t.connectionProtector&&null!=globalThis.process?.env?.LIBP2P_FORCE_PNET)throw new yo("Private network is enforced, but no protector was provided");return t}const ng=1e3,sg=60*ng,og=60*sg,ig=24*og,ag=7*ig,cg=365.25*ig;function lg(e,t){try{if("string"==typeof e&&e.length>0)return function(e){if((e+="").length>100)throw Error("Value exceeds the maximum length of 100 characters.");const t=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(!t)return NaN;const r=parseFloat(t[1]),n=(t[2]||"ms").toLowerCase();switch(n){case"years":case"year":case"yrs":case"yr":case"y":return r*cg;case"weeks":case"week":case"w":return r*ag;case"days":case"day":case"d":return r*ig;case"hours":case"hour":case"hrs":case"hr":case"h":return r*og;case"minutes":case"minute":case"mins":case"min":case"m":return r*sg;case"seconds":case"second":case"secs":case"sec":case"s":return r*ng;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return r;default:throw Error(`The unit ${n} was matched, but no matching case exists.`)}}(e);if("number"==typeof e&&isFinite(e))return t?.long?function(e){const t=Math.abs(e);if(t>=ig)return ug(e,t,ig,"day");if(t>=og)return ug(e,t,og,"hour");if(t>=sg)return ug(e,t,sg,"minute");if(t>=ng)return ug(e,t,ng,"second");return e+" ms"}(e):function(e){const t=Math.abs(e);if(t>=ig)return Math.round(e/ig)+"d";if(t>=og)return Math.round(e/og)+"h";if(t>=sg)return Math.round(e/sg)+"m";if(t>=ng)return Math.round(e/ng)+"s";return e+"ms"}(e);throw Error("Value is not a string or number.")}catch(t){const r=function(e){return"object"==typeof e&&null!==e&&"message"in e}(t)?`${t.message}. value=${JSON.stringify(e)}`:"An unknown error has occured.";throw Error(r)}}function ug(e,t,r,n){const s=t>=1.5*r;return`${Math.round(e/r)} ${n}${s?"s":""}`}const hg=function(){try{return localStorage}catch(e){}}();const dg=console.debug??console.log??(()=>{});var pg=function(e){function t(e){let n,s,o,i=null;function a(...e){if(!a.enabled)return;const r=a,s=Number(new Date),o=s-(n||s);r.diff=o,r.prev=n,r.curr=s,n=s,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let i=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,((n,s)=>{if("%%"===n)return"%";i++;const o=t.formatters[s];if("function"==typeof o){const t=e[i];n=o.call(r,t),e.splice(i,1),i--}return n})),t.formatArgs.call(r,e);(r.log||t.log).apply(r,e)}return a.namespace=e,a.useColors=t.useColors(),a.color=t.selectColor(e),a.extend=r,a.destroy=t.destroy,Object.defineProperty(a,"enabled",{enumerable:!0,configurable:!1,get(){return null!==i?i:(s!==t.namespaces&&(s=t.namespaces,o=t.enabled(e)),o)},set(e){i=e}}),"function"==typeof t.init&&t.init(a),a}function r(e,r){const n=t(this.namespace+(void 0===r?":":r)+e);return n.log=this.log,n}function n(e){return e.toString().substring(2,e.toString().length-2).replace(/\.\*\?$/,"*")}return t.debug=t,t.default=t,t.coerce=function(e){if(e instanceof Error)return e.stack??e.message;return e},t.disable=function(){const e=[...t.names.map(n),...t.skips.map(n).map((e=>"-"+e))].join(",");return t.enable(""),e},t.enable=function(e){let r;t.save(e),t.namespaces=e,t.names=[],t.skips=[];const n=("string"==typeof e?e:"").split(/[\s,]+/),s=n.length;for(r=0;r<s;r++)n[r]&&("-"===(e=n[r].replace(/\*/g,".*?"))[0]?t.skips.push(RegExp("^"+e.substr(1)+"$")):t.names.push(RegExp("^"+e+"$")))},t.enabled=function(e){if("*"===e[e.length-1])return!0;let r,n;for(r=0,n=t.skips.length;r<n;r++)if(t.skips[r].test(e))return!1;for(r=0,n=t.names.length;r<n;r++)if(t.names[r].test(e))return!0;return!1},t.humanize=lg,t.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(e).forEach((r=>{t[r]=e[r]})),t.names=[],t.skips=[],t.formatters={},t.selectColor=function(e){let r=0;for(let t=0;t<e.length;t++)r=(r<<5)-r+e.charCodeAt(t),r|=0;return t.colors[Math.abs(r)%t.colors.length]},t.setupFormatters(t.formatters),t.enable(t.load()),t}({formatArgs(e){if(e[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+e[0]+(this.useColors?"%c ":" ")+"+"+lg(this.diff),!this.useColors)return;const t="color: "+this.color;e.splice(1,0,t,"color: inherit");let r=0,n=0;e[0].replace(/%[a-zA-Z%]/g,(e=>{"%%"!==e&&(r++,"%c"===e&&(n=r))})),e.splice(n,0,t)},save(e){try{e?hg?.setItem("debug",e):hg?.removeItem("debug")}catch(e){}},load(){let e;try{e=hg?.getItem("debug")}catch(e){}return!e&&void 0!==globalThis.process&&"env"in globalThis.process&&(e=globalThis.process.env.DEBUG),e},useColors(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type&&!window.process.__nwjs)||("undefined"==typeof navigator||null==navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement?.style?.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&null!=navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/))},setupFormatters(e){e.j=e=>{try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}},colors:["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],storage:hg,log:dg});function fg(){return{forComponent:e=>gg(e)}}function gg(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}(e+":trace");return pg.enabled(e+":trace")&&null!=pg.names.map((e=>e.toString())).find((e=>e.includes(":trace")))&&(t=pg(e+":trace")),Object.assign(pg(e),{error:pg(e+":error"),trace:t,newScope(t){return gg(`${e}:${t}`)}})}function mg(e){if(null!=e&&0!==(e=e.trim()).length)return e}function yg(e,t){const r={[Symbol.iterator](){return r},next(){const r=e.next(),n=r.value;if(!0===r.done||null==n){return{done:!0,value:void 0}}return{done:!1,value:t(n)}}};return r}function bg(e){return gu(Oe(he.decode("z"+e)))}pg.formatters.b=e=>null==e?"undefined":he.baseEncode(e),pg.formatters.t=e=>null==e?"undefined":Q.baseEncode(e),pg.formatters.m=e=>null==e?"undefined":fe.baseEncode(e),pg.formatters.p=e=>null==e?"undefined":e.toString(),pg.formatters.c=e=>null==e?"undefined":e.toString(),pg.formatters.k=e=>null==e?"undefined":e.toString(),pg.formatters.a=e=>null==e?"undefined":e.toString(),pg.formatters.e=e=>null==e?"undefined":mg(e.stack)??mg(e.message)??e.toString();class wg{map;constructor(e){if(this.map=new Map,null!=e)for(const[t,r]of e.entries())this.map.set(t.toString(),{key:t,value:r})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return yg(this.map.entries(),(e=>[e[1].key,e[1].value]))}forEach(e){this.map.forEach((t=>{e(t.value,t.key,this)}))}get(e){return this.map.get(e.toString())?.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return yg(this.map.values(),(e=>e.key))}values(){return yg(this.map.values(),(e=>e.value))}get size(){return this.map.size}}class vg{set;constructor(e){if(this.set=new Set,null!=e)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return yg(this.set.entries(),(e=>{const t=bg(e[0]);return[t,t]}))}forEach(e){this.set.forEach((t=>{const r=bg(t);e(r,r,this)}))}has(e){return this.set.has(e.toString())}values(){return yg(this.set.values(),(e=>bg(e)))}intersection(e){const t=new vg;for(const r of e)this.has(r)&&t.add(r);return t}difference(e){const t=new vg;for(const r of this)e.has(r)||t.add(r);return t}union(e){const t=new vg;for(const r of e)t.add(r);for(const e of this)t.add(e);return t}}const Eg={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},Sg={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},Ag=new globalThis.TextEncoder;function Cg(e,{size:t=32,utf8Buffer:r}={}){if(!Eg[t])throw Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if("string"==typeof e){if(r)return function(e,t,r){if(0===r.length)throw Error("The `utf8Buffer` option must have a length greater than zero");const n=Eg[t];let s=Sg[t],o=e;for(;o.length>0;){const e=Ag.encodeInto(o,r);o=o.slice(e.read);for(let o=0;o<e.written;o++)s^=BigInt(r[o]),s=BigInt.asUintN(t,s*n)}return s}(e,t,r);e=Ag.encode(e)}return function(e,t){const r=Eg[t];let n=Sg[t];for(let s=0;s<e.length;s++)n^=BigInt(e[s]),n=BigInt.asUintN(t,n*r);return n}(e,t)}const Ig={hash(e){return Number(Cg(e,{size:32}))},hashV(e,t){return function(e){let t=e.toString(16);t.length%2==1&&(t="0"+t);return tt(t,"base16")}(Ig.hash(e,t))}};class xg{fp;h;seed;constructor(t,r,n,s=2){if(s>64)throw new TypeError("Invalid Fingerprint Size");const o=r.hashV(t,n),i=e(s);for(let e=0;e<i.length;e++)i[e]=o[e];0===i.length&&(i[0]=7),this.fp=i,this.h=r,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return e?.fp instanceof Uint8Array&&Jn(this.fp,e.fp)}}function kg(e,t){return Math.floor(Math.random()*(t-e))+e}class Pg{contents;constructor(e){this.contents=Array(e).fill(null)}has(e){if(!(e instanceof xg))throw new TypeError("Invalid Fingerprint");return this.contents.some((t=>e.equals(t)))}add(e){if(!(e instanceof xg))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(null==this.contents[t])return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof xg))throw new TypeError("Invalid Fingerprint");const t=kg(0,this.contents.length-1),r=this.contents[t];return this.contents[t]=e,r}remove(e){if(!(e instanceof xg))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex((t=>e.equals(t)));return t>-1&&(this.contents[t]=null,!0)}}class Tg{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(e){this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??Ig,this.seed=e.seed??kg(0,1024)}add(e){"string"==typeof e&&(e=tt(e));const t=new xg(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,n=(r^t.hash())%this.filterSize;if(null==this.buckets[r]&&(this.buckets[r]=new Pg(this.bucketSize)),null==this.buckets[n]&&(this.buckets[n]=new Pg(this.bucketSize)),this.buckets[r].add(t)||this.buckets[n].add(t))return this.count++,!0;const s=[r,n];let o=s[kg(0,s.length-1)];null==this.buckets[o]&&(this.buckets[o]=new Pg(this.bucketSize));for(let e=0;e<500;e++){const e=this.buckets[o].swap(t);if(null!=e&&(o=(o^e.hash())%this.filterSize,null==this.buckets[o]&&(this.buckets[o]=new Pg(this.bucketSize)),this.buckets[o].add(e)))return this.count++,!0}return!1}has(e){"string"==typeof e&&(e=tt(e));const t=new xg(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,n=this.buckets[r]?.has(t)??!1;if(n)return n;const s=(r^t.hash())%this.filterSize;return this.buckets[s]?.has(t)??!1}remove(e){"string"==typeof e&&(e=tt(e));const t=new xg(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,n=this.buckets[r]?.remove(t)??!1;if(n)return this.count--,n;const s=(r^t.hash())%this.filterSize,o=this.buckets[s]?.remove(t)??!1;return o&&this.count--,o}get reliable(){return Math.floor(this.count/this.filterSize*100)<=90}}const _g={1:.5,2:.84,4:.95,8:.98};function Rg(e,t=.001){const r=function(e=.001){return e>.002?2:e>1e-5?4:8}(t);return{filterSize:Math.round(e/_g[r]),bucketSize:r,fingerprintSize:Math.min(Math.ceil(Math.log2(1/t)+Math.log2(2*r)),64)}}class Lg{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(e){this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??Ig,this.seed=e.seed??kg(0,1024),this.filterSeries=[new Tg({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if("string"==typeof e&&(e=tt(e)),this.has(e))return!0;let t=this.filterSeries.find((e=>e.reliable));if(null==t){const e=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new Tg({filterSize:e,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){"string"==typeof e&&(e=tt(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){"string"==typeof e&&(e=tt(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce(((e,t)=>e+t.count),0)}}class Dg extends wg{metric;constructor(e){super();const{name:t,metrics:r}=e;this.metric=r.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}let Ng=class extends Error{static name="AbortError";name="AbortError";constructor(e="The operation was aborted",...t){super(e,...t)}};async function Mg(e,t,r,n){const s=new Ng(n?.errorMessage);null!=n?.errorCode&&(s.code=n.errorCode);const o=n?.errorEvent??"error";return!0===r?.aborted?Promise.reject(s):new Promise(((i,a)=>{function c(){Fg(r,"abort",h),Fg(e,t,l),Fg(e,o,u)}const l=e=>{try{if(!1===n?.filter?.(e))return}catch(e){return c(),void a(e)}c(),i(e)},u=e=>{c(),a(e instanceof Error?e:e.detail??n?.error??Error(`The "${n?.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))},h=()=>{c(),a(s)};Og(r,"abort",h),Og(e,t,l),Og(e,o,u)}))}function Og(e,t,r){null!=e&&(Ug(e)?e.addEventListener(t,r):e.addListener(t,r))}function Fg(e,t,r){null!=e&&(Ug(e)?e.removeEventListener(t,r):e.removeListener(t,r))}function Ug(e){return"function"==typeof e.addEventListener&&"function"==typeof e.removeEventListener}class Bg extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}let qg=class{deferred;signal;constructor(e){this.signal=e,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new Ng)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}};let $g=class{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=`${parseInt(1e9*Math.random()+"",10).toString()}${Date.now()}`,this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce(((e,t)=>e&&!0===t.signal?.aborted),!0)&&(this.controller.abort(new Ng),this.cleanup())}async join(e={}){const t=new qg(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await vs(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach((t=>{t.deferred.resolve(e)})),this.status="complete"}catch(e){this.recipients.forEach((t=>{t.deferred.reject(e)})),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach((e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)}))}};function zg(e,t){let r;const n=()=>{clearTimeout(r),r=setTimeout((()=>{r=void 0,e()}),t)};return n.start=()=>{},n.stop=()=>{clearTimeout(r)},n}let Kg=class extends qo{concurrency;maxSize;queue;pending;sort;autoStart;constructor(e={}){super(),this.concurrency=e.concurrency??1/0,this.maxSize=e.maxSize??1/0,this.pending=0,this.autoStart=e.autoStart??!0,this.sort=e.sort,this.queue=[],this.emitEmpty=zg(this.emitEmpty.bind(this),1),this.emitIdle=zg(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){0===this.size&&this.safeDispatchEvent("empty")}emitIdle(){0===this.running&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(0===this.size)return this.emitEmpty(),0===this.running&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if("queued"===t.status){e=t;break}return null!=e&&(this.safeDispatchEvent("active"),this.pending++,e.run().finally((()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()})),!0)}return!1}enqueue(e){this.queue.push(e),null!=this.sort&&this.queue.sort(this.sort)}start(){!1===this.autoStart&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new Bg;const r=new $g(e,t);return this.enqueue(r),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),r.join(t).then((e=>(this.safeDispatchEvent("success",{detail:{job:r,result:e}}),e))).catch((e=>{if("queued"===r.status)for(let e=0;e<this.queue.length;e++)if(this.queue[e]===r){this.queue.splice(e,1);break}throw this.safeDispatchEvent("failure",{detail:{job:r,error:e}}),e}))}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach((e=>{e.abort(new Ng)})),this.clear()}async onEmpty(e){0!==this.size&&await Mg(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await Mg(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){0===this.pending&&0===this.size||await Mg(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=bs({objectMode:!0}),r=e=>{null!=e?this.abort():this.clear(),t.end(e)},n=e=>{null!=e.detail&&t.push(e.detail.result)},s=e=>{r(e.detail.error)},o=()=>{r()},i=()=>{r(new Ng("Queue aborted"))};this.addEventListener("success",n),this.addEventListener("failure",s),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",i);try{yield*t}finally{this.removeEventListener("success",n),this.removeEventListener("failure",s),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",i),r()}}};const Vg="lock:worker:request-read",Hg="lock:worker:abort-read-request",jg="lock:worker:release-read",Gg="lock:master:grant-read",Wg="lock:master:error-read",Xg="lock:worker:request-write",Zg="lock:worker:abort-write-request",Yg="lock:worker:release-write",Qg="lock:master:grant-write",Jg="lock:master:error-write",em="lock:worker:finalize",tm="mortice",rm={singleProcess:!1},nm=(e,t,r,n,s,o,i,a,c)=>l=>{if(null==l.data)return;const u={type:l.data.type,name:l.data.name,identifier:l.data.identifier};u.type===s&&e.safeDispatchEvent(r,{detail:{name:u.name,identifier:u.identifier,async handler(){t.postMessage({type:c,name:u.name,identifier:u.identifier}),await new Promise((e=>{const r=n=>{if(null==n?.data)return;const s=n.data.type,o=(n.data.name,n.data.identifier);s===a&&o===u.identifier&&(t.removeEventListener("message",r),e())};t.addEventListener("message",r)}))},onError(e){t.postMessage({type:i,name:u.name,identifier:u.identifier,error:{message:e.message,name:e.name,stack:e.stack}})}}}),u.type===o&&e.safeDispatchEvent(n,{detail:{name:u.name,identifier:u.identifier}}),u.type===em&&e.safeDispatchEvent("finalizeRequest",{detail:{name:u.name}})};class sm{name;channel;constructor(e){this.name=e,this.channel=new BroadcastChannel(tm)}readLock(e){return this.sendRequest(Vg,Hg,Gg,Wg,jg,e)}writeLock(e){return this.sendRequest(Xg,Zg,Qg,Jg,Yg,e)}finalize(){this.channel.postMessage({type:em,name:this.name}),this.channel.close()}async sendRequest(e,t,r,n,s,o){o?.signal?.throwIfAborted();const i=((e=10)=>Math.random().toString().substring(2,e+2))();return this.channel.postMessage({type:e,identifier:i,name:this.name}),new Promise(((e,a)=>{const c=()=>{this.channel.postMessage({type:t,identifier:i,name:this.name})};o?.signal?.addEventListener("abort",c,{once:!0});const l=t=>{if(t.data?.identifier===i&&(t.data?.type===r&&(this.channel.removeEventListener("message",l),o?.signal?.removeEventListener("abort",c),e((()=>{this.channel.postMessage({type:s,identifier:i,name:this.name})}))),t.data.type===n)){this.channel.removeEventListener("message",l),o?.signal?.removeEventListener("abort",c);const e=Error();null!=t.data.error&&(e.message=t.data.error.message,e.name=t.data.error.name,e.stack=t.data.error.stack),a(e)}};this.channel.addEventListener("message",l)}))}}const om=new Map;let im;function am(e){return"function"==typeof e?.readLock&&"function"==typeof e?.writeLock}function cm(e){if(null==im&&(im=(e=>{if(e=Object.assign({},rm,e),!!globalThis.document||e.singleProcess){const e=new BroadcastChannel(tm),t=new qo;return e.addEventListener("message",nm(t,e,"requestReadLock","abortReadLockRequest",Vg,Hg,Wg,jg,Gg)),e.addEventListener("message",nm(t,e,"requestWriteLock","abortWriteLockRequest",Xg,Zg,Jg,Yg,Qg)),t}return new sm(e.name)})(e),!am(im))){const e=im;e.addEventListener("requestReadLock",(t=>{const r=t.detail.name,n=t.detail.identifier,s=om.get(r);if(null==s)return;const o=new AbortController,i=e=>{e.detail.name===r&&e.detail.identifier===n&&o.abort()};e.addEventListener("abortReadLockRequest",i),s.readLock({signal:o.signal}).then((async e=>{await t.detail.handler().finally((()=>{e()}))})).catch((e=>{t.detail.onError(e)})).finally((()=>{e.removeEventListener("abortReadLockRequest",i)}))})),e.addEventListener("requestWriteLock",(t=>{const r=t.detail.name,n=t.detail.identifier,s=om.get(r);if(null==s)return;const o=new AbortController,i=e=>{e.detail.name===r&&e.detail.identifier===n&&o.abort()};e.addEventListener("abortWriteLockRequest",i),s.writeLock({signal:o.signal}).then((async e=>{await t.detail.handler().finally((()=>{e()}))})).catch((e=>{t.detail.onError(e)})).finally((()=>{e.removeEventListener("abortWriteLockRequest",i)}))})),e.addEventListener("finalizeRequest",(e=>{const t=e.detail.name,r=om.get(t);null!=r&&r.finalize()}))}return im}async function lm(e,t){let r,n;const s=new Promise(((e,t)=>{r=e,n=t})),o=()=>{n(new Ng)};return t?.signal?.addEventListener("abort",o,{once:!0}),e.add((async()=>{await new Promise((e=>{r((()=>{t?.signal?.removeEventListener("abort",o),e()}))}))}),{signal:t?.signal}).catch((e=>{n(e)})),s}const um={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function hm(e){const t=Object.assign({},um,e);return((e,t)=>{let r=om.get(e);if(null!=r)return r;const n=cm(t);if(am(n))return r=n,om.set(e,r),r;const s=new Kg({concurrency:1});let o;return r={async readLock(e){if(null!=o)return lm(o,e);o=new Kg({concurrency:t.concurrency,autoStart:!1});const r=o,n=lm(o,e);return s.add((async()=>{r.start(),await r.onIdle().then((()=>{o===r&&(o=null)}))})),n},async writeLock(e){return o=null,lm(s,e)},finalize(){om.delete(e)},queue:s},om.set(e,r),!0===t.autoFinalize&&s.addEventListener("idle",(()=>{r.finalize()}),{once:!0}),r})(t.name,t)}var dm,pm,fm;function gm(e,t){if(null!=e.publicKey||null==t.publicKey)return e;let r;"RSA"===e.type&&(r=e.toMultihash());return fu(ou(t.publicKey,r))}function mm(e,t,r){const n=new Map,s=BigInt(Date.now());for(const[e,r]of t.tags.entries())null!=r.expiry&&r.expiry<s||n.set(e,r);return{...t,id:gm(e,t),addresses:t.addresses.filter((({observed:e})=>null!=e&&e>Date.now()-r)).map((({multiaddr:e,isCertified:t})=>({multiaddr:Ri(e),isCertified:t??!1}))),metadata:t.metadata,peerRecordEnvelope:t.peerRecordEnvelope??void 0,tags:n}}function ym(e,t){return u=e.addresses,h=t.addresses,wm(u,h,((e,t)=>e.isCertified===t.isCertified&&!!Jn(e.multiaddr,t.multiaddr)))&&(c=e.protocols,l=t.protocols,wm(c,l,((e,t)=>e===t)))&&(i=e.publicKey,a=t.publicKey,bm(i,a))&&(s=e.peerRecordEnvelope,o=t.peerRecordEnvelope,bm(s,o))&&(r=e.metadata,n=t.metadata,vm(r,n,((e,t)=>Jn(e,t))))&&function(e,t){return vm(e,t,((e,t)=>e.value===t.value&&e.expiry===t.expiry))}(e.tags,t.tags);var r,n,s,o,i,a,c,l,u,h}function bm(e,t){return null==e&&null==t||null!=e&&null!=t&&Jn(e,t)}function wm(e,t,r){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(!r(e[n],t[n]))return!1;return!0}function vm(e,t,r){if(e.size!==t.size)return!1;for(const[n,s]of e.entries()){const e=t.get(n);if(null==e)return!1;if(!r(s,e))return!1}return!0}(t=>{let r;(t=>{let r;t.codec=()=>(null==r&&(r=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.key&&""!==e.key&&(t.uint32(10),t.string(e.key)),null!=e.value&&e.value.byteLength>0&&(t.uint32(18),t.bytes(e.value)),!1!==r.lengthDelimited&&t.ldelim()}),((t,r)=>{const n={key:"",value:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.key=t.string();break;case 2:n.value=t.bytes();break;default:t.skipType(7&e)}}return n}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(t.Peer$metadataEntry||(t.Peer$metadataEntry={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.key&&""!==e.key&&(t.uint32(10),t.string(e.key)),null!=e.value&&(t.uint32(18),fm.codec().encode(e.value,t)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t,r={})=>{const n={key:""},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.key=e.string();break;case 2:n.value=fm.codec().decode(e,e.uint32(),{limits:r.limits?.value});break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(t.Peer$tagsEntry||(t.Peer$tagsEntry={})),t.codec=()=>(null==r&&(r=Zt(((e,r,n={})=>{if(!1!==n.lengthDelimited&&r.fork(),null!=e.addresses)for(const t of e.addresses)r.uint32(10),pm.codec().encode(t,r);if(null!=e.protocols)for(const t of e.protocols)r.uint32(18),r.string(t);if(null!=e.publicKey&&(r.uint32(34),r.bytes(e.publicKey)),null!=e.peerRecordEnvelope&&(r.uint32(42),r.bytes(e.peerRecordEnvelope)),null!=e.metadata&&0!==e.metadata.size)for(const[n,s]of e.metadata.entries())r.uint32(50),t.Peer$metadataEntry.codec().encode({key:n,value:s},r);if(null!=e.tags&&0!==e.tags.size)for(const[n,s]of e.tags.entries())r.uint32(58),t.Peer$tagsEntry.codec().encode({key:n,value:s},r);null!=e.updated&&(r.uint32(64),r.uint64Number(e.updated)),!1!==n.lengthDelimited&&r.ldelim()}),((e,r,n={})=>{const s={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=null==r?e.len:e.pos+r;for(;e.pos<o;){const r=e.uint32();switch(r>>>3){case 1:if(null!=n.limits?.addresses&&s.addresses.length===n.limits.addresses)throw new Yt('Decode error - map field "addresses" had too many elements');s.addresses.push(pm.codec().decode(e,e.uint32(),{limits:n.limits?.addresses$}));break;case 2:if(null!=n.limits?.protocols&&s.protocols.length===n.limits.protocols)throw new Yt('Decode error - map field "protocols" had too many elements');s.protocols.push(e.string());break;case 4:s.publicKey=e.bytes();break;case 5:s.peerRecordEnvelope=e.bytes();break;case 6:{if(null!=n.limits?.metadata&&s.metadata.size===n.limits.metadata)throw new Qt('Decode error - map field "metadata" had too many elements');const r=t.Peer$metadataEntry.codec().decode(e,e.uint32());s.metadata.set(r.key,r.value);break}case 7:{if(null!=n.limits?.tags&&s.tags.size===n.limits.tags)throw new Qt('Decode error - map field "tags" had too many elements');const r=t.Peer$tagsEntry.codec().decode(e,e.uint32(),{limits:{value:n.limits?.tags$value}});s.tags.set(r.key,r.value);break}case 8:s.updated=e.uint64Number();break;default:e.skipType(7&r)}}return s}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(dm||(dm={})),(t=>{let r;t.codec=()=>(null==r&&(r=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.multiaddr&&e.multiaddr.byteLength>0&&(t.uint32(10),t.bytes(e.multiaddr)),null!=e.isCertified&&(t.uint32(16),t.bool(e.isCertified)),null!=e.observed&&(t.uint32(24),t.uint64Number(e.observed)),!1!==r.lengthDelimited&&t.ldelim()}),((t,r)=>{const n={multiaddr:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.multiaddr=t.bytes();break;case 2:n.isCertified=t.bool();break;case 3:n.observed=t.uint64Number();break;default:t.skipType(7&e)}}return n}))),r),t.encode=e=>gt(e,t.codec()),t.decode=(e,r)=>P(e,t.codec(),r)})(pm||(pm={})),(e=>{let t;e.codec=()=>(null==t&&(t=Zt(((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.value&&0!==e.value&&(t.uint32(8),t.uint32(e.value)),null!=e.expiry&&(t.uint32(16),t.uint64(e.expiry)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={value:0},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.value=e.uint32();break;case 2:r.expiry=e.uint64();break;default:e.skipType(7&t)}}return r}))),t),e.encode=t=>gt(t,e.codec()),e.decode=(t,r)=>P(t,e.codec(),r)})(fm||(fm={}));const Em="/",Sm=(new TextEncoder).encode(Em),Am=Sm[0];class Cm{_buf;constructor(e,t){if("string"==typeof e)this._buf=tt(e);else{if(!(e instanceof Uint8Array))throw Error("Invalid key, should be String of Uint8Array");this._buf=e}if(null==t&&(t=!0),t&&this.clean(),0===this._buf.byteLength||this._buf[0]!==Am)throw Error("Invalid key")}toString(e="utf8"){return mn(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new Cm(e.join(Em))}static random(){return new Cm(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||"string"==typeof e?new Cm(e):"function"==typeof e.uint8Array?new Cm(e.uint8Array()):null}clean(){if(null!=this._buf&&0!==this._buf.byteLength||(this._buf=Sm),this._buf[0]!==Am){const e=new Uint8Array(this._buf.byteLength+1);e.fill(Am,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===Am;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),r=e.list();for(let e=0;e<t.length;e++){if(r.length<e+1)return!1;const n=t[e],s=r[e];if(n<s)return!0;if(n>s)return!1}return t.length<r.length}reverse(){return Cm.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(Em).slice(1)}type(){return function(e){const t=e.split(":");if(t.length<2)return"";return t.slice(0,-1).join(":")}(this.baseNamespace())}name(){return function(e){const t=e.split(":");return t[t.length-1]}(this.baseNamespace())}instance(e){return new Cm(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(Em)||(e+=Em),e+=this.type(),new Cm(e)}parent(){const e=this.list();return 1===e.length?new Cm(Em):new Cm(e.slice(0,-1).join(Em))}child(e){return this.toString()===Em?e:e.toString()===Em?this:new Cm(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()!==this.toString()&&e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()!==this.toString()&&this.toString().startsWith(e.toString())}isTopLevel(){return 1===this.list().length}concat(...e){return Cm.withNamespaces([...this.namespaces(),...(t=e.map((e=>e.namespaces())),[].concat(...t))]);var t}}const Im="/peers/";function xm(e){if(!lo(e)||null==e.type)throw new yo("Invalid PeerId");const t=e.toCID().toString();return new Cm(`${Im}${t}`)}async function km(e,t,r,n,s){const o=new Map;for(const n of r){if(null==n)continue;if(n.multiaddr instanceof Uint8Array&&(n.multiaddr=Ri(n.multiaddr)),!_i(n.multiaddr))throw new yo("Multiaddr was invalid");if(!await t(e,n.multiaddr,s))continue;const r=n.isCertified??!1,i=n.multiaddr.toString(),a=o.get(i);null!=a?n.isCertified=a.isCertified||r:o.set(i,{multiaddr:n.multiaddr,isCertified:r})}return[...o.values()].sort(((e,t)=>e.multiaddr.toString().localeCompare(t.multiaddr.toString()))).map((({isCertified:t,multiaddr:r})=>{const n=r.getPeerId();return e.equals(n)&&(r=r.decapsulate(Ri("/p2p/"+e))),{isCertified:t,multiaddr:r.bytes}}))}async function Pm(e,t,r,n){if(null==t)throw new yo("Invalid PeerData");if(null!=t.publicKey&&null!=e.publicKey&&!t.publicKey.equals(e.publicKey))throw new yo("publicKey bytes do not match peer id publicKey bytes");const s=n.existingPeer?.peer;if(null!=s&&!e.equals(s.id))throw new yo("peer id did not match existing peer id");let o,i=s?.addresses??[],a=new Set(s?.protocols??[]),c=s?.metadata??new Map,l=s?.tags??new Map,u=s?.peerRecordEnvelope;if("patch"===r){if(null==t.multiaddrs&&null==t.addresses||(i=[],null!=t.multiaddrs&&i.push(...t.multiaddrs.map((e=>({isCertified:!1,multiaddr:e})))),null!=t.addresses&&i.push(...t.addresses)),null!=t.protocols&&(a=new Set(t.protocols)),null!=t.metadata){c=Tm(t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata),{validate:_m})}if(null!=t.tags){l=Tm(t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags),{validate:Rm,map:Lm})}null!=t.peerRecordEnvelope&&(u=t.peerRecordEnvelope)}if("merge"===r){if(null!=t.multiaddrs&&i.push(...t.multiaddrs.map((e=>({isCertified:!1,multiaddr:e})))),null!=t.addresses&&i.push(...t.addresses),null!=t.protocols&&(a=new Set([...a,...t.protocols])),null!=t.metadata){const e=t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata);for(const[t,r]of e)null==r?c.delete(t):c.set(t,r);c=Tm([...c.entries()],{validate:_m})}if(null!=t.tags){const e=t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags),r=new Map(l);for(const[t,n]of e)null==n?r.delete(t):r.set(t,n);l=Tm([...r.entries()],{validate:Rm,map:Lm})}null!=t.peerRecordEnvelope&&(u=t.peerRecordEnvelope)}null!=s?.id.publicKey?o=iu(s.id.publicKey):null!=t.publicKey?o=iu(t.publicKey):null!=e.publicKey&&(o=iu(e.publicKey));const h={addresses:await km(e,n.addressFilter??(async()=>!0),i,n.existingPeer?.peerPB.addresses,n),protocols:[...a.values()].sort(((e,t)=>e.localeCompare(t))),metadata:c,tags:l,publicKey:o,peerRecordEnvelope:u};return h.addresses.forEach((e=>{e.observed=n.existingPeer?.peerPB.addresses?.find((e=>Jn(e.multiaddr,e.multiaddr)))?.observed??Date.now()})),"RSA"!==e.type&&delete h.publicKey,h}function Tm(e,t){const r=new Map;for(const[r,n]of e)null!=n&&t.validate(r,n);for(const[n,s]of e.sort((([e],[t])=>e.localeCompare(t))))null!=s&&r.set(n,t.map?.(n,s)??s);return r}function _m(e,t){if("string"!=typeof e)throw new yo("Metadata key must be a string");if(!(t instanceof Uint8Array))throw new yo("Metadata value must be a Uint8Array")}function Rm(e,t){if("string"!=typeof e)throw new yo("Tag name must be a string");if(null!=t.value){if(parseInt(""+t.value,10)!==t.value)throw new yo("Tag value must be an integer");if(t.value<0||t.value>100)throw new yo("Tag value must be between 0-100")}if(null!=t.ttl){if(parseInt(""+t.ttl,10)!==t.ttl)throw new yo("Tag ttl must be an integer");if(t.ttl<0)throw new yo("Tag ttl must be between greater than 0")}}function Lm(e,t){let r;null!=t.expiry&&(r=t.expiry),null!=t.ttl&&(r=BigInt(Date.now()+Number(t.ttl)));const n={value:t.value??0};return null!=r&&(n.expiry=r),n}function Dm(e){const t=e.toString().split("/")[2];return mu(He.parse(t,Q))}function Nm(e,t,r){return function(e,t,r){return mm(e,dm.decode(t),r)}(Dm(e),t,r)}class Mm{peerId;datastore;locks;addressFilter;log;maxAddressAge;maxPeerAge;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.locks=function(e){const{name:t,metrics:r}=e;let n;return n=null!=r?new Dg({name:t,metrics:r}):new wg,n}({name:"libp2p_peer_store_locks",metrics:e.metrics}),this.maxAddressAge=t.maxAddressAge??36e5,this.maxPeerAge=t.maxPeerAge??216e5}getLock(e){let t=this.locks.get(e);return null==t&&(t={refs:0,lock:hm({name:e.toString(),singleProcess:!0})},this.locks.set(e,t)),t.refs++,t}maybeRemoveLock(e,t){t.refs--,0===t.refs&&(t.lock.finalize(),this.locks.delete(e))}async getReadLock(e,t){const r=this.getLock(e);try{const n=await r.lock.readLock(t);return()=>{n(),this.maybeRemoveLock(e,r)}}catch(t){throw this.maybeRemoveLock(e,r),t}}async getWriteLock(e,t){const r=this.getLock(e);try{const n=await r.lock.writeLock(t);return()=>{n(),this.maybeRemoveLock(e,r)}}catch(t){throw this.maybeRemoveLock(e,r),t}}async has(e,t){try{return await this.load(e,t),!0}catch(e){if("NotFoundError"!==e.name)throw e}return!1}async delete(e,t){this.peerId.equals(e)||await this.datastore.delete(xm(e),t)}async load(e,t){const r=xm(e),n=await this.datastore.get(r,t),s=dm.decode(n);if(this.#_(e,s))throw await this.datastore.delete(r,t),new Io;return mm(e,s,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t,r){const n=await this.#R(e,r),s=await Pm(e,t,"patch",{...r,addressFilter:this.addressFilter});return this.#L(e,s,n)}async patch(e,t,r){const n=await this.#R(e,r),s=await Pm(e,t,"patch",{...r,addressFilter:this.addressFilter,existingPeer:n});return this.#L(e,s,n)}async merge(e,t,r){const n=await this.#R(e,r),s=await Pm(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:n});return this.#L(e,s,n)}async*all(e){for await(const{key:t,value:r}of this.datastore.query(function(e,t){return{prefix:Im,filters:(e.filters??[]).map((e=>({key:r,value:n})=>e(Nm(r,n,t)))),orders:(e.orders??[]).map((e=>(r,n)=>e(Nm(r.key,r.value,t),Nm(n.key,n.value,t))))}}(e??{},this.maxAddressAge),e)){const n=Dm(t);if(n.equals(this.peerId))continue;const s=dm.decode(r);this.#_(n,s)?await this.datastore.delete(t,e):yield mm(n,s,this.peerId.equals(n)?1/0:this.maxAddressAge)}}async#R(e,t){try{const r=xm(e),n=await this.datastore.get(r,t),s=dm.decode(n);if(this.#_(e,s))throw await this.datastore.delete(r,t),new Io;return{peerPB:s,peer:mm(e,s,this.maxAddressAge)}}catch(e){"NotFoundError"!==e.name&&this.log.error("invalid peer data found in peer store - %e",e)}}async#L(e,t,r,n){t.updated=Date.now();const s=dm.encode(t);return await this.datastore.put(xm(e),s,n),{peer:mm(e,t,this.maxAddressAge),previous:r?.peer,updated:null==r||!ym(t,r.peerPB)}}#_(e,t){if(null==t.updated)return!0;if(this.peerId.equals(e))return!1;const r=t.updated<Date.now()-this.maxPeerAge,n=Date.now()-this.maxAddressAge,s=t.addresses.filter((e=>null!=e.observed&&e.observed>n));return r&&0===s.length}}class Om{store;events;peerId;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new Mm(e,t)}[Symbol.toStringTag]="@libp2p/peer-store";async forEach(e,t){for await(const r of this.store.all(t))e(r)}async all(e){return Yn(this.store.all(e))}async delete(e,t){const r=await this.store.getReadLock(e,t);try{await this.store.delete(e,t)}finally{r()}}async has(e,t){const r=await this.store.getReadLock(e,t);try{return await this.store.has(e,t)}finally{this.log.trace("has release read lock"),r?.()}}async get(e,t){const r=await this.store.getReadLock(e,t);try{return await this.store.load(e,t)}finally{r?.()}}async getInfo(e,t){const r=await this.get(e,t);return{id:r.id,multiaddrs:r.addresses.map((({multiaddr:e})=>e))}}async save(e,t,r){const n=await this.store.getWriteLock(e,r);try{const n=await this.store.save(e,t,r);return this.#D(e,n),n.peer}finally{n?.()}}async patch(e,t,r){const n=await this.store.getWriteLock(e,r);try{const n=await this.store.patch(e,t,r);return this.#D(e,n),n.peer}finally{n?.()}}async merge(e,t,r){const n=await this.store.getWriteLock(e,r);try{const n=await this.store.merge(e,t,r);return this.#D(e,n),n.peer}finally{n?.()}}async consumePeerRecord(e,t,r){const n=lo(t)?t:lo(t?.expectedPeer)?t.expectedPeer:void 0,s=lo(t)||void 0===t?r:t,o=await pd.openAndCertify(e,yd.DOMAIN,s),i=mu(o.publicKey.toCID());if(!1===n?.equals(i))return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",n,i),!1;const a=yd.createFromProtobuf(o.payload);let c;try{c=await this.get(i,s)}catch(e){if("NotFoundError"!==e.name)throw e}if(null!=c?.peerRecordEnvelope){const e=pd.createFromProtobuf(c.peerRecordEnvelope),t=yd.createFromProtobuf(e.payload);if(t.seqNumber>=a.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",t.seqNumber,a.seqNumber),!1}return await this.patch(a.peerId,{peerRecordEnvelope:e,addresses:a.multiaddrs.map((e=>({isCertified:!0,multiaddr:e})))},s),!0}#D(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))}}class Fm extends Error{static name="NotFoundError";static code="ERR_NOT_FOUND";name=Fm.name;code=Fm.code;constructor(e="Not Found"){super(e)}}function Um(e,t){let r=0;if(null!=e[Symbol.asyncIterator])return async function*(){for await(const n of e)await t(n,r++)&&(yield n)}();const n=function(e){const[t,r]=null!=e[Symbol.asyncIterator]?[e[Symbol.asyncIterator](),Symbol.asyncIterator]:[e[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>t.next(),push(e){n.push(e)},next:()=>n.length>0?{done:!1,value:n.shift()}:t.next(),[r](){return this}}}(e),{value:s,done:o}=n.next();if(!0===o)return function*(){}();const i=t(s,r++);if("function"==typeof i.then)return async function*(){await i&&(yield s);for await(const e of n)await t(e,r++)&&(yield e)}();const a=t;return function*(){!0===i&&(yield s);for(const e of n)a(e,r++)&&(yield e)}()}function Bm(e,t){return null!=e[Symbol.asyncIterator]?async function*(){const r=await Yn(e);yield*r.sort(t)}():function*(){const r=Yn(e);yield*r.sort(t)}()}function qm(e,t){return null!=e[Symbol.asyncIterator]?async function*(){let r=0;if(!(t<1))for await(const n of e)if(yield n,r++,r===t)return}():function*(){let r=0;if(!(t<1))for(const n of e)if(yield n,r++,r===t)return}()}class $m{put(e,t,r){return Promise.reject(Error(".put is not implemented"))}get(e,t){return Promise.reject(Error(".get is not implemented"))}has(e,t){return Promise.reject(Error(".has is not implemented"))}delete(e,t){return Promise.reject(Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:r,value:n}of e)await this.put(r,n,t),yield r}async*getMany(e,t={}){for await(const r of e)yield{key:r,value:await this.get(r,t)}}async*deleteMany(e,t={}){for await(const r of e)await this.delete(r,t),yield r}batch(){let e=[],t=[];return{put(t,r){e.push({key:t,value:r})},delete(e){t.push(e)},commit:async r=>{await wd(this.putMany(e,r)),e=[],await wd(this.deleteMany(t,r)),t=[]}}}async*_all(e,t){throw Error("._all is not implemented")}async*_allKeys(e,t){throw Error("._allKeys is not implemented")}query(e,t){let r=this._all(e,t);if(null!=e.prefix){const t=e.prefix;r=Um(r,(e=>e.key.toString().startsWith(t)))}if(Array.isArray(e.filters)&&(r=e.filters.reduce(((e,t)=>Um(e,t)),r)),Array.isArray(e.orders)&&(r=e.orders.reduce(((e,t)=>Bm(e,t)),r)),null!=e.offset){let t=0;const n=e.offset;r=Um(r,(()=>t++>=n))}return null!=e.limit&&(r=qm(r,e.limit)),r}queryKeys(e,t){let r=this._allKeys(e,t);if(null!=e.prefix){const t=e.prefix;r=Um(r,(e=>e.toString().startsWith(t)))}if(Array.isArray(e.filters)&&(r=e.filters.reduce(((e,t)=>Um(e,t)),r)),Array.isArray(e.orders)&&(r=e.orders.reduce(((e,t)=>Bm(e,t)),r)),null!=e.offset){const t=e.offset;let n=0;r=Um(r,(()=>n++>=t))}return null!=e.limit&&(r=qm(r,e.limit)),r}}class zm extends $m{data;constructor(){super(),this.data=new Map}put(e,t){return this.data.set(e.toString(),t),e}get(e){const t=this.data.get(e.toString());if(null==t)throw new Fm;return t}has(e){return this.data.has(e.toString())}delete(e){this.data.delete(e.toString())}*_all(){for(const[e,t]of this.data.entries())yield{key:new Cm(e),value:t}}*_allKeys(){for(const e of this.data.keys())yield new Cm(e)}}const Km=e=>e;function Vm(e,t){const r=e.getPeerId();if(null!=r){pu(r).equals(t)&&(e=e.decapsulate(Ri("/p2p/"+t.toString())))}return e}class Hm{log;components;listen;announce;observed;announceFilter;constructor(e,t={}){const{listen:r=[],announce:n=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=r.map((e=>e.toString())),this.announce=new Set(n.map((e=>e.toString()))),this.observed=new Map,this.announceFilter=t.announceFilter??Km,this._updatePeerStoreAddresses=function(e,t){let r;return()=>{clearTimeout(r),r=setTimeout((()=>{r=void 0,e()}),t)}}(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",(()=>{this._updatePeerStoreAddresses()})),e.events.addEventListener("transport:close",(()=>{this._updatePeerStoreAddresses()}))}[Symbol.toStringTag]="@libp2p/address-manager";_updatePeerStoreAddresses(){const e=this.getAnnounceAddrs().concat(this.components.transportManager.getAddrs()).concat([...this.observed.entries()].filter((([e,t])=>t.confident)).map((([e])=>Ri(e)))).map((e=>e.getPeerId()===this.components.peerId.toString()?e.decapsulate("/p2p/"+this.components.peerId.toString()):e));this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch((e=>{this.log.error("error updating addresses",e)}))}getListenAddrs(){return Array.from(this.listen).map((e=>Ri(e)))}getAnnounceAddrs(){return Array.from(this.announce).map((e=>Ri(e)))}getObservedAddrs(){return Array.from(this.observed).map((([e])=>Ri(e)))}addObservedAddr(e){const t=(e=Vm(e,this.components.peerId)).toString();this.observed.has(t)||this.observed.set(t,{confident:!1})}confirmObservedAddr(e){const t=(e=Vm(e,this.components.peerId)).toString(),r=(this.observed.get(t)??{confident:!1}).confident;this.observed.set(t,{confident:!0}),r||this._updatePeerStoreAddresses()}removeObservedAddr(e){const t=(e=Vm(e,this.components.peerId)).toString();this.observed.delete(t)}getAddresses(){let e=this.getAnnounceAddrs().map((e=>e.toString()));0===e.length&&(e=this.components.transportManager.getAddrs().map((e=>e.toString()))),e=e.concat(Array.from(this.observed).filter((([e,t])=>t.confident)).map((([e])=>e)));const t=new Set(e);return this.announceFilter(Array.from(t).map((e=>Ri(e)))).map((e=>!0===e.protos().pop()?.path||e.getPeerId()===this.components.peerId.toString()?e:e.encapsulate("/p2p/"+this.components.peerId.toString())))}}var jm;(e=>{e.NOT_STARTED_YET="The libp2p node is not started yet",e.NOT_FOUND="Not found"})(jm||(jm={}));class Gm extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class Wm extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class Xm extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class Zm extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class Ym extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class Qm extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class Jm extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class ey extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class ty extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class ry extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class ny extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class sy extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class oy extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class iy extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class ay{components={};_started=!1;constructor(e={}){this.components={};for(const[t,r]of Object.entries(e))this.components[t]=r;null==this.components.logger&&(this.components.logger=fg())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter((e=>$o(e))).map((async t=>{await(t[e]?.())})))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const cy=["metrics","connectionProtector","dns"],ly=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function uy(e){return Array.isArray(e?.[zo])?e[zo]:[]}function hy(e){return Array.isArray(e?.[Ko])?e[Ko]:[]}function dy(e){return e?.[Symbol.toStringTag]??e?.toString()??"unknown"}function py(e={}){return{async denyDialPeer(){return!1},async denyDialMultiaddr(e){const t=e.stringTuples();return(4===t[0][0]||41===t[0][0])&&!!Md(""+t[0][1])},async denyInboundConnection(){return!1},async denyOutboundConnection(){return!1},async denyInboundEncryptedConnection(){return!1},async denyOutboundEncryptedConnection(){return!1},async denyInboundUpgradedConnection(){return!1},async denyOutboundUpgradedConnection(){return!1},async filterMultiaddrForPeer(){return!0},...e}}function fy(e){if(lo(e))return{peerId:e,multiaddrs:[]};let t;if(Array.isArray(e)||(e=[e]),e.length>0){const r=e[0].getPeerId();t=null==r?void 0:pu(r),e.forEach((e=>{if(!_i(e))throw new ko("Invalid multiaddr");const r=e.getPeerId();if(null==r){if(null!=t)throw new yo("Multiaddrs must all have the same peer id or have no peer id")}else{const e=pu(r);if(!0!==t?.equals(e))throw new yo("Multiaddrs must all have the same peer id or have no peer id")}}))}return{peerId:t,multiaddrs:e}}const gy=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];const my="last-dial-failure",yy="last-dial-success",by={maxConnections:100,allow:[]};class wy{maxConnections;connectionManager;peerStore;allow;events;log;constructor(e,t={}){this.maxConnections=t.maxConnections??by.maxConnections,this.allow=t.allow??by.allow,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch((e=>{this.log.error("error while pruning connections %e",e)}))}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length;if(this.log("checking max connections limit %d/%d",t,this.maxConnections),t<=this.maxConnections)return;const r=new wg;for(const t of e){const e=t.remotePeer;if(!r.has(e)){r.set(e,0);try{const t=await this.peerStore.get(e);r.set(e,[...t.tags.values()].reduce(((e,t)=>e+t.value),0))}catch(e){"NotFoundError"!==e.name&&this.log.error("error loading peer tags",e)}}}const n=this.sortConnections(e,r),s=Math.max(t-this.maxConnections,0),o=[];for(const e of n){this.log("too many connections open - closing a connection to %p",e.remotePeer);if(this.allow.some((t=>e.remoteAddr.toString().startsWith(t.toString())))||o.push(e),o.length===s)break}await Promise.all(o.map((async e=>{await async function(e,t){const r=e?.streams?.map((e=>e.protocol))??[],n=t?.closableProtocols??gy;if(!(r.filter((e=>null!=e&&!n.includes(e))).length>0))try{await(e?.close(t))}catch(t){e?.abort(t)}}(e,{signal:AbortSignal.timeout(1e3)})}))),this.events.safeDispatchEvent("connection:prune",{detail:o})}sortConnections(e,t){return e.sort(((e,t)=>{const r=e.timeline.open,n=t.timeline.open;return r<n?1:r>n?-1:0})).sort(((e,t)=>"outbound"===e.direction&&"inbound"===t.direction?1:"inbound"===e.direction&&"outbound"===t.direction?-1:0)).sort(((e,t)=>e.streams.length>t.streams.length?1:e.streams.length<t.streams.length?-1:0)).sort(((e,r)=>{const n=t.get(e.remotePeer)??0,s=t.get(r.remotePeer)??0;return n>s?1:n<s?-1:0}))}}class vy{deferred;signal;constructor(e){this.signal=e,this.deferred=fs(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new go)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}}class Ey{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=`${parseInt(1e9*Math.random()+"",10).toString()}${Date.now()}`,this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce(((e,t)=>e&&!0===t.signal?.aborted),!0)&&(this.controller.abort(new go),this.cleanup())}async join(e={}){const t=new vy(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await vs(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach((t=>{t.deferred.resolve(e)})),this.status="complete"}catch(e){this.recipients.forEach((t=>{t.deferred.reject(e)})),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach((e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)}))}}class Sy extends qo{concurrency;maxSize;queue;pending;sort;constructor(e={}){super(),this.concurrency=e.concurrency??1/0,this.maxSize=e.maxSize??1/0,this.pending=0,null!=e.metricName&&e.metrics?.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=e.sort,this.queue=[],this.emitEmpty=bd(this.emitEmpty.bind(this),1),this.emitIdle=bd(this.emitIdle.bind(this),1)}emitEmpty(){0===this.size&&this.safeDispatchEvent("empty")}emitIdle(){0===this.running&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(0===this.size)return this.emitEmpty(),0===this.running&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if("queued"===t.status){e=t;break}return null!=e&&(this.safeDispatchEvent("active"),this.pending++,e.run().finally((()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")})),!0)}return!1}enqueue(e){this.queue.push(e),null!=this.sort&&this.queue.sort(this.sort)}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new kp;const r=new Ey(e,t);return this.enqueue(r),this.safeDispatchEvent("add"),this.tryToStartAnother(),r.join(t).then((e=>(this.safeDispatchEvent("completed",{detail:e}),this.safeDispatchEvent("success",{detail:{job:r,result:e}}),e))).catch((e=>{if("queued"===r.status)for(let e=0;e<this.queue.length;e++)if(this.queue[e]===r){this.queue.splice(e,1);break}throw this.safeDispatchEvent("failure",{detail:{job:r,error:e}}),e}))}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach((e=>{e.abort(new go)})),this.clear()}async onEmpty(e){0!==this.size&&await Mg(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await Mg(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){0===this.pending&&0===this.size||await Mg(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=bs({objectMode:!0}),r=e=>{null!=e?this.abort():this.clear(),t.end(e)},n=e=>{null!=e.detail&&t.push(e.detail)},s=e=>{r(e.detail.error)},o=()=>{r()},i=()=>{r(new go("Queue aborted"))};this.addEventListener("completed",n),this.addEventListener("failure",s),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",i);try{yield*t}finally{this.removeEventListener("completed",n),this.removeEventListener("failure",s),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",i),r()}}}class Ay extends Sy{constructor(e={}){super({...e,sort(e,t){return e.options.priority>t.options.priority?-1:e.options.priority<t.options.priority?1:0}})}}function Cy(e){const t=new globalThis.AbortController;function r(){t.abort();for(const t of e)null!=t?.removeEventListener&&t.removeEventListener("abort",r)}for(const t of e){if(!0===t?.aborted){r();break}null!=t?.addEventListener&&t.addEventListener("abort",r)}const n=t.signal;return n.clear=function(){for(const t of e)null!=t?.removeEventListener&&t.removeEventListener("abort",r)},n}function Iy(e,t){const r=sp.exactMatch(e.multiaddr),n=sp.exactMatch(t.multiaddr);if(r&&!n)return-1;if(!r&&n)return 1;const s=dp.exactMatch(e.multiaddr),o=dp.exactMatch(t.multiaddr);if(s&&!o)return-1;if(!s&&o)return 1;const i=up.exactMatch(e.multiaddr),a=up.exactMatch(t.multiaddr);if(i&&!a)return-1;if(!i&&a)return 1;const c=wp.exactMatch(e.multiaddr),l=wp.exactMatch(t.multiaddr);if(c&&!l)return-1;if(!c&&l)return 1;const u=fp.exactMatch(e.multiaddr),h=fp.exactMatch(t.multiaddr);if(u&&!h)return-1;if(!u&&h)return 1;const d=mp.exactMatch(e.multiaddr),p=mp.exactMatch(t.multiaddr);return d&&!p?-1:!d&&p?1:0}function xy(e,t){const r=Od(e.multiaddr),n=Od(t.multiaddr);return r&&!n?1:!r&&n?-1:0}function ky(e,t){return e.isCertified&&!t.isCertified?-1:!e.isCertified&&t.isCertified?1:0}function Py(e,t){const r=bp.exactMatch(e.multiaddr),n=bp.exactMatch(t.multiaddr);return r&&!n?1:!r&&n?-1:0}const Ty=50,_y=500,Ry=25,Ly=5e3;class Dy{queue;components;addressSorter;maxPeerAddrsToDial;maxDialQueueLength;dialTimeout;shutDownController;connections;log;constructor(e,t={}){this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??Ry,this.maxDialQueueLength=t.maxDialQueueLength??_y,this.dialTimeout=t.dialTimeout??Ly,this.connections=t.connections??new wg,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.shutDownController=new AbortController,this.shutDownController.signal;for(const[e,r]of Object.entries(t.resolvers??{}))Ti.set(e,r);this.queue=new Ay({concurrency:t.maxParallelDials??Ty,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("error",(e=>{e.detail.name!==go.name&&this.log.error("error in dial queue - %e",e.detail)}))}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){const{peerId:r,multiaddrs:n}=fy(e),s=Array.from(this.connections.values()).flat().find((e=>!0!==t.force&&(!!e.remotePeer.equals(r)||n.find((t=>t.equals(e.remoteAddr))))));if("open"===s?.status)return this.log("already connected to %a",s.remoteAddr),t.onProgress?.(new bf("dial-queue:already-connected")),s;const o=this.queue.queue.find((e=>{if(!0===r?.equals(e.options.peerId))return!0;const t=e.options.multiaddrs;if(null==t)return!1;for(const e of n)if(t.has(e.toString()))return!0;return!1}));if(null!=o){this.log("joining existing dial target for %p",r);for(const e of n)o.options.multiaddrs.add(e.toString());return t.onProgress?.(new bf("dial-queue:already-in-dial-queue")),o.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new Mo("Dial queue is full");return this.log("creating dial target for %p",r,n.map((e=>e.toString()))),t.onProgress?.(new bf("dial-queue:add-to-dial-queue")),this.queue.add((async e=>{e?.onProgress?.(new bf("dial-queue:start-dial"));const t=this.createDialAbortController(e?.signal);let n;try{n=await this.calculateMultiaddrs(r,e?.multiaddrs,{...e,signal:t}),e?.onProgress?.(new bf("dial-queue:calculated-addresses",n)),n.map((({multiaddr:e})=>e.toString())).forEach((t=>{e?.multiaddrs.add(t)}))}catch(e){throw t.clear(),e}try{let s=0;const o=[];for(const i of n){if(s===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",s,r),new Mo("Peer had more than maxPeerAddrsToDial");s++;try{const n=await this.components.transportManager.dial(i.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",i.multiaddr);try{await this.components.peerStore.merge(n.remotePeer,{multiaddrs:[n.remoteAddr],metadata:{[yy]:tt(Date.now().toString())}})}catch(e){this.log.error("could not update last dial failure key for %p",r,e)}return n}catch(e){if(this.log.error("dial failed to %a",i.multiaddr,e),null!=r)try{await this.components.peerStore.merge(r,{metadata:{[my]:tt(Date.now().toString())}})}catch(e){this.log.error("could not update last dial failure key for %p",r,e)}if(t.aborted)throw new Do(e.message);o.push(e)}}if(1===o.length)throw o[0];throw new AggregateError(o,"All multiaddr dials failed")}finally{t.clear()}}),{peerId:r,priority:t.priority??Zy,multiaddrs:new Set(n.map((e=>e.toString()))),signal:t.signal,onProgress:t.onProgress})}createDialAbortController(e){return Cy([AbortSignal.timeout(this.dialTimeout),this.shutDownController.signal,e])}async calculateMultiaddrs(e,t=new Set,r={}){const n=[...t].map((e=>({multiaddr:Ri(e),isCertified:!1})));if(null!=e){if(this.components.peerId.equals(e))throw new Mo("Tried to dial self");if(!0===await(this.components.connectionGater.denyDialPeer?.(e)))throw new ey("The dial request is blocked by gater.allowDialPeer");if(0===n.length){this.log("loading multiaddrs for %p",e);try{const t=await this.components.peerStore.get(e);n.push(...t.addresses),this.log("loaded multiaddrs for %p",e,n.map((({multiaddr:e})=>e.toString())))}catch(e){if("NotFoundError"!==e.name)throw e}}if(0===n.length){this.log("looking up multiaddrs for %p in the peer routing",e);try{const t=await this.components.peerRouting.findPeer(e);this.log("found multiaddrs for %p in the peer routing",e,n.map((({multiaddr:e})=>e.toString()))),n.push(...t.multiaddrs.map((e=>({multiaddr:e,isCertified:!1}))))}catch(t){"NoPeerRoutersError"!==t.name&&this.log.error("looking up multiaddrs for %p in the peer routing failed",e,t)}}}let s=(await Promise.all(n.map((async e=>{const t=await async function(e,t){let r=!1;for(const t of Ti.keys())if(r=e.protoNames().includes(t),r)break;if(!r)return[e];const n=await e.resolve(t);return t.log("resolved %s to",e,n.map((e=>e.toString()))),n}(e.multiaddr,{dns:this.components.dns,...r,log:this.log});return 1===t.length&&t[0].equals(e.multiaddr)?e:t.map((e=>({multiaddr:e,isCertified:!1})))})))).flat();if(null!=e){const t="/p2p/"+e.toString();s=s.map((e=>{const r=e.multiaddr.protos().pop();return!0===r?.path?e:null==e.multiaddr.getPeerId()?{multiaddr:e.multiaddr.encapsulate(t),isCertified:e.isCertified}:e}))}const o=s.filter((t=>{if(null==this.components.transportManager.dialTransportForMultiaddr(t.multiaddr))return!1;const r=t.multiaddr.getPeerId();return null==e||null==r||e.equals(r)})),i=new Map;for(const e of o){const t=e.multiaddr.toString(),r=i.get(t);null==r?i.set(t,e):r.isCertified=r.isCertified||e.isCertified||!1}const a=[...i.values()];if(0===a.length)throw new ty("The dial request has no valid addresses");const c=[];for(const e of a)null!=this.components.connectionGater.denyDialMultiaddr&&await this.components.connectionGater.denyDialMultiaddr(e.multiaddr)||c.push(e);const l=null==this.addressSorter?c.sort(Iy).sort(ky).sort(Py).sort(xy):c.sort(this.addressSorter);if(0===l.length)throw new ey("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",s.map((({multiaddr:e})=>e.toString()))),this.log.trace("addresses for %p after filtering",e??"unknown peer",l.map((({multiaddr:e})=>e.toString()))),l}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const r=await this.calculateMultiaddrs(void 0,new Set(e.map((e=>e.toString()))),t);return!1!==t.runOnLimitedConnection||null!=r.find((e=>!bp.matches(e.multiaddr)))}catch(e){this.log.trace("error calculating if multiaddr(s) were dialable",e)}return!1}}class Ny extends Sy{has(e){return null!=this.find(e)}find(e){return this.queue.find((t=>e.equals(t.options.peerId)))}}var My,Oy,Fy,Uy,By,qy={};function $y(){return Fy||(Fy=1,e=qy,t=function(){if(Oy)return My;function e(e,t){"boolean"==typeof t&&(t={forever:t}),this._originalTimeouts=JSON.parse(JSON.stringify(e)),this._timeouts=e,this._options=t||{},this._maxRetryTime=t&&t.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}return Oy=1,My=e,e.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},e.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},e.prototype.retry=function(e){if(this._timeout&&clearTimeout(this._timeout),!e)return!1;var t=(new Date).getTime();if(e&&t-this._operationStart>=this._maxRetryTime)return this._errors.push(e),this._errors.unshift(Error("RetryOperation timeout occurred")),!1;this._errors.push(e);var r=this._timeouts.shift();if(void 0===r){if(!this._cachedTimeouts)return!1;this._errors.splice(0,this._errors.length-1),r=this._cachedTimeouts.slice(-1)}var n=this;return this._timer=setTimeout((()=>{n._attempts++,n._operationTimeoutCb&&(n._timeout=setTimeout((()=>{n._operationTimeoutCb(n._attempts)}),n._operationTimeout),n._options.unref&&n._timeout.unref()),n._fn(n._attempts)}),r),this._options.unref&&this._timer.unref(),!0},e.prototype.attempt=function(e,t){this._fn=e,t&&(t.timeout&&(this._operationTimeout=t.timeout),t.cb&&(this._operationTimeoutCb=t.cb));var r=this;this._operationTimeoutCb&&(this._timeout=setTimeout((()=>{r._operationTimeoutCb()}),r._operationTimeout)),this._operationStart=(new Date).getTime(),this._fn(this._attempts)},e.prototype.try=function(e){this.attempt(e)},e.prototype.start=function(e){this.attempt(e)},e.prototype.start=e.prototype.try,e.prototype.errors=function(){return this._errors},e.prototype.attempts=function(){return this._attempts},e.prototype.mainError=function(){if(0===this._errors.length)return null;for(var e={},t=null,r=0,n=0;n<this._errors.length;n++){var s=this._errors[n],o=s.message,i=(e[o]||0)+1;e[o]=i,i>=r&&(t=s,r=i)}return t},My}(),e.operation=r=>{var n=e.timeouts(r);return new t(n,{forever:r&&(r.forever||r.retries===1/0),unref:r&&r.unref,maxRetryTime:r&&r.maxRetryTime})},e.timeouts=function(e){if(e instanceof Array)return[].concat(e);var t={retries:10,factor:2,minTimeout:1e3,maxTimeout:1/0,randomize:!1};for(var r in e)t[r]=e[r];if(t.minTimeout>t.maxTimeout)throw Error("minTimeout is greater than maxTimeout");for(var n=[],s=0;s<t.retries;s++)n.push(this.createTimeout(s,t));return e&&e.forever&&!n.length&&n.push(this.createTimeout(s,t)),n.sort(((e,t)=>e-t)),n},e.createTimeout=(e,t)=>{var r=t.randomize?Math.random()+1:1,n=Math.round(r*Math.max(t.minTimeout,1)*Math.pow(t.factor,e));return n=Math.min(n,t.maxTimeout)},e.wrap=function(t,r,n){if(r instanceof Array&&(n=r,r=null),!n)for(var s in n=[],t)"function"==typeof t[s]&&n.push(s);for(var o=0;o<n.length;o++){var i=n[o],a=t[i];t[i]=function(n){var s=e.operation(r),o=[].slice.call(arguments,1),i=o.pop();o.push((function(e){s.retry(e)||(e&&(arguments[0]=s.mainError()),i.apply(this,arguments))})),s.attempt((()=>{n.apply(t,o)}))}.bind(t,a),t[i].options=r}}),qy;var e,t}var zy=Ln(By?Uy:(By=1,Uy=$y()));const Ky={}.toString,Vy=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Load failed","Network request failed","fetch failed","terminated"]);function Hy(e){var t;return!(!e||(t=e,"[object Error]"!==Ky.call(t))||"TypeError"!==e.name||"string"!=typeof e.message)&&("Load failed"===e.message?void 0===e.stack:Vy.has(e.message))}let jy=class extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,({message:e}=e)):(this.originalError=Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}};const Gy=(e,t,r)=>{const n=r.retries-(t-1);return e.attemptNumber=t,e.retriesLeft=n,e};class Wy{log;queue;started;peerStore;retries;retryInterval;backoffFactor;connectionManager;events;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new Ny({concurrency:t.maxParallelReconnects??5,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",(e=>{this.maybeReconnect(e.detail).catch((t=>{this.log.error("failed to maybe reconnect to %p - %e",e.detail,t)}))}))}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);Xy(t)&&(this.queue.has(e)||this.queue.add((async t=>{await async function(e,t){return new Promise(((r,n)=>{t={...t},t.onFailedAttempt??=()=>{},t.shouldRetry??=()=>!0,t.retries??=10;const s=zy.operation(t),o=()=>{s.stop(),n(t.signal?.reason)};t.signal&&!t.signal.aborted&&t.signal.addEventListener("abort",o,{once:!0});const i=()=>{t.signal?.removeEventListener("abort",o),s.stop()};s.attempt((async o=>{try{const t=await e(o);i(),r(t)}catch(e){try{if(!(e instanceof Error))throw new TypeError(`Non-error was thrown: "${e}". You should only throw errors.`);if(e instanceof jy)throw e.originalError;if(e instanceof TypeError&&!Hy(e))throw e;if(Gy(e,o,t),await t.shouldRetry(e)||(s.stop(),n(e)),await t.onFailedAttempt(e),!s.retry(e))throw s.mainError()}catch(e){Gy(e,o,t),i(),n(e)}}}))}))}((async r=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:t?.signal})}catch(t){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,r,this.retries,t),t}}),{signal:t?.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})}),{peerId:e}).catch((async r=>{this.log.error("failed to reconnect to %p - %e",e,r);const n={};[...t.tags.keys()].forEach((e=>{e.startsWith(ho)&&(n[e]=void 0)})),await this.peerStore.merge(e,{tags:n}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})})).catch((async t=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,t)})))}start(){this.started=!0}async afterStart(){Promise.resolve().then((async()=>{const e=await this.peerStore.all({filters:[e=>Xy(e)]});await Promise.all(e.map((async e=>{await this.connectionManager.openConnection(e.id).catch((e=>{this.log.error(e)}))})))})).catch((e=>{this.log.error(e)}))}stop(){this.started=!1,this.queue.abort()}}function Xy(e){for(const t of e.tags.keys())if(t.startsWith(ho))return!0;return!1}const Zy=50,Yy=100,Qy=5,Jy=10;class eb{started;connections;allow;deny;maxIncomingPendingConnections;incomingPendingConnections;outboundPendingConnections;maxConnections;dialQueue;reconnectQueue;connectionPruner;inboundConnectionRateLimiter;peerStore;metrics;events;log;peerId;constructor(e,t={}){if(this.maxConnections=t.maxConnections??Yy,this.maxConnections<1)throw new yo("Connection Manager maxConnections must be greater than 0");this.connections=new wg,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map((e=>Ri(e))),this.deny=(t.deny??[]).map((e=>Ri(e))),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??Jy,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new Pp({points:t.inboundConnectionThreshold??Qy,duration:1}),this.connectionPruner=new wy({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{maxConnections:this.maxConnections,allow:this.allow}),this.dialQueue=new Dy(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??50,maxDialQueueLength:t.maxDialQueueLength??500,maxPeerAddrsToDial:t.maxPeerAddrsToDial??25,dialTimeout:t.dialTimeout??5e3,resolvers:t.resolvers??{dnsaddr:Wf},connections:this.connections}),this.reconnectQueue=new Wy({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}[Symbol.toStringTag]="@libp2p/connection-manager";async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const e={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const t of this.connections.values())for(const r of t)e[r.direction]++;return e}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const r of t)for(const t of r.streams){const r=`${t.direction} ${t.protocol??"unnegotiated"}`;e[r]=(e[r]??0)+1}return e}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const r of t){const t={};for(const e of r.streams){const r=`${e.direction} ${e.protocol??"unnegotiated"}`;t[r]=(t[r]??0)+1}for(const[r,n]of Object.entries(t))e[r]=e[r]??[],e[r].push(n)}const t={};for(let[r,n]of Object.entries(e)){n=n.sort(((e,t)=>e-t));const e=Math.floor(.9*n.length);t[r]=n[e]}return t}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await async function(...e){const t=[];for(const r of e)$o(r)&&t.push(r);await Promise.all(t.map((async e=>{null!=e.beforeStart&&await e.beforeStart()}))),await Promise.all(t.map((async e=>{await e.start()}))),await Promise.all(t.map((async e=>{null!=e.afterStart&&await e.afterStart()})))}(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await async function(...e){const t=[];for(const r of e)$o(r)&&t.push(r);await Promise.all(t.map((async e=>{null!=e.beforeStop&&await e.beforeStop()}))),await Promise.all(t.map((async e=>{await e.stop()}))),await Promise.all(t.map((async e=>{null!=e.afterStop&&await e.afterStop()})))}(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const r of t)e.push((async()=>{try{await r.close()}catch(e){this.log.error(e)}})());this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}onConnect(e){this._onConnect(e).catch((e=>{this.log.error(e)}))}async _onConnect(e){const{detail:t}=e;if(!this.started)return void await t.close();if("open"!==t.status)return;const r=t.remotePeer,n=!this.connections.has(r),s=this.connections.get(r)??[];s.push(t),this.connections.set(r,s),null!=r.publicKey&&"RSA"===r.type&&await this.peerStore.patch(r,{publicKey:r.publicKey}),n&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,r=t.remotePeer,n=(this.connections.get(r)??[]).filter((e=>e.id!==t.id));this.connections.set(r,n),0===n.length&&(this.log("onDisconnect remove all connections for peer %p",r),this.connections.delete(r),this.events.safeDispatchEvent("peer:disconnect",{detail:t.remotePeer}))}getConnections(e){if(null!=e)return this.connections.get(e)??[];let t=[];for(const e of this.connections.values())t=t.concat(e);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){if(!this.started)throw new No("Not started");this.outboundPendingConnections++;try{t.signal?.throwIfAborted();const{peerId:r}=fy(e);if(this.peerId.equals(r))throw new xo("Can not dial self");if(null!=r&&!0!==t.force){this.log("dial %p",r);const e=this.getConnections(r).find((e=>null==e.limits));if(null!=e)return this.log("had an existing non-limited connection to %p",r),t.onProgress?.(new bf("dial-queue:already-connected")),e}const n=await this.dialQueue.dial(e,{...t,priority:t.priority??Zy});if("open"!==n.status)throw new vo("Remote closed connection during opening");let s=this.connections.get(n.remotePeer);null==s&&(s=[],this.connections.set(n.remotePeer,s));let o=!1;for(const e of s)if(e.id===n.id&&(o=!0),!0!==t.force&&e.id!==n.id&&e.remoteAddr.equals(n.remoteAddr))return n.abort(new ko("Duplicate multiaddr connection")),e;return o||s.push(n),n}finally{this.outboundPendingConnections--}}async closeConnections(e,t={}){const r=this.connections.get(e)??[];await Promise.all(r.map((async e=>{try{await e.close(t)}catch(t){e.abort(t)}})))}async acceptIncomingConnection(e){if(this.deny.some((t=>e.remoteAddr.toString().startsWith(t.toString()))))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some((t=>e.remoteAddr.toString().startsWith(t.toString()))))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(e.remoteAddr.isThinWaistAddress()){const t=e.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(t,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,t),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map((t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map((e=>Ri(e)))})))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}class tb{movingAverage;variance;deviation;forecast;timeSpan;previousTime;constructor(e){this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(null!=this.previousTime){const r=this.alpha(t,this.previousTime),n=e-this.movingAverage,s=r*n;this.movingAverage=r*e+(1-r)*this.movingAverage,this.variance=(1-r)*(this.variance+n*s),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+r*n}else this.movingAverage=e;this.previousTime=t}}class rb{success;failure;next;metric;timeoutMultiplier;failureMultiplier;minTimeout;maxTimeout;constructor(e={}){const t=e.interval??5e3;this.success=new tb(t),this.failure=new tb(t),this.next=new tb(t),this.failureMultiplier=e.failureMultiplier??2,this.timeoutMultiplier=e.timeoutMultiplier??1.2,this.minTimeout=e.minTimeout??5e3,this.maxTimeout=e.maxTimeout??6e4,null!=e.metricName&&(this.metric=e.metrics?.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){let t=Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier));t<this.minTimeout&&(t=this.minTimeout),t>this.maxTimeout&&(t=this.maxTimeout);const r=AbortSignal.timeout(t),n=Cy([e.signal,r]);return n.start=Date.now(),n.timeout=t,n}cleanUp(e){const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),this.metric?.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),this.metric?.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}class nb{readNext;haveNext;ended;nextResult;constructor(){this.ended=!1,this.readNext=fs(),this.haveNext=fs()}[Symbol.asyncIterator](){return this}async next(){if(null==this.nextResult&&await this.haveNext.promise,null==this.nextResult)throw Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=fs(),e}async throw(e){this.ended=!0,null!=e&&(this.haveNext.promise.catch((()=>{})),this.haveNext.reject(e));return{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){null!=e?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(null!=e&&this.ended)throw Error("Cannot push value onto an ended pushable");for(;null!=this.nextResult;)await this.readNext.promise;null!=e?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=fs(),await vs(this.readNext.promise,t?.signal,t)}}class sb extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"}class ob extends Error{code;constructor(e,t){super(e),this.code=t}}class ib extends ob{type;constructor(e){super(e,"ABORT_ERR"),this.type="aborted",this.name="AbortError"}}function ab(e){const t=new nb;e.sink(t).catch((async e=>{await t.end(e)})),e.sink=async e=>{for await(const r of e)await t.push(r);await t.end()};let r=e.source;null!=e.source[Symbol.iterator]?r=e.source[Symbol.iterator]():null!=e.source[Symbol.asyncIterator]&&(r=e.source[Symbol.asyncIterator]());const n=new ns,s={async read(e,t){let s;t?.signal?.throwIfAborted();const o=new Promise(((e,r)=>{s=()=>{r(new ib("Read aborted"))},t?.signal?.addEventListener("abort",s)}));try{if(null==e){const{done:e,value:t}=await Promise.race([r.next(),o]);return!0===e?new ns:t}for(;n.byteLength<e;){const{value:e,done:t}=await Promise.race([r.next(),o]);if(!0===t)throw new sb("unexpected end of input");n.append(e)}const t=n.sublist(0,e);return n.consume(e),t}finally{null!=s&&t?.signal?.removeEventListener("abort",s)}},async write(e,r){r?.signal?.throwIfAborted(),e instanceof Uint8Array?await t.push(e,r):await t.push(e.subarray(),r)},unwrap(){if(n.byteLength>0){const t=e.source;e.source=async function*(){yield*n,yield*t}()}return e}};return s}class cb{protocol;components;log;heartbeatInterval;pingIntervalMs;abortController;timeout;abortConnectionOnPingFailure;constructor(e,t={}){this.components=e,this.protocol=`/${t.protocolPrefix??"ipfs"}/ping/1.0.0`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??1e4,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??true,this.timeout=new rb({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}[Symbol.toStringTag]="@libp2p/connection-monitor";[zo]=["@libp2p/connection-monitor"];start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval((()=>{this.components.connectionManager.getConnections().forEach((e=>{Promise.resolve().then((async()=>{let t=Date.now();try{const r=this.timeout.getTimeoutSignal({signal:this.abortController?.signal}),n=ab(await e.newStream(this.protocol,{signal:r,runOnLimitedConnection:!0}));t=Date.now(),await Promise.all([n.write(Pl(32),{signal:r}),n.read(32,{signal:r})]),e.rtt=Date.now()-t,await n.unwrap().close({signal:r})}catch(r){if("UnsupportedProtocolError"!==r.name)throw r;e.rtt=(Date.now()-t)/2}})).catch((t=>{this.log.error("error during heartbeat",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")}))}))}),this.pingIntervalMs)}stop(){this.abortController?.abort(),null!=this.heartbeatInterval&&clearInterval(this.heartbeatInterval)}}class lb{routers;started;components;constructor(e,t){this.routers=t.routers??[],this.started=!1,this.components=e}[Symbol.toStringTag]="@libp2p/content-routing";isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(0===this.routers.length)throw new Xm("No content routers available");const r=this,n=new vg;for await(const s of Cs(...r.routers.map((r=>r.findProviders(e,t)))))null!=s&&(s.multiaddrs.length>0&&await this.components.peerStore.merge(s.id,{multiaddrs:s.multiaddrs}),n.has(s.id)||(n.add(s.id),yield s))}async provide(e,t={}){if(0===this.routers.length)throw new Xm("No content routers available");await Promise.all(this.routers.map((async r=>{await r.provide(e,t)})))}async put(e,t,r){if(!this.isStarted())throw new No;await Promise.all(this.routers.map((async n=>{await n.put(e,t,r)})))}async get(e,t){if(!this.isStarted())throw new No;return Promise.any(this.routers.map((async r=>r.get(e,t))))}}class ub{log;peerId;peerStore;routers;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[]}[Symbol.toStringTag]="@libp2p/peer-routing";async findPeer(e,t){if(0===this.routers.length)throw new Zm("No peer routers available");if(e.toString()===this.peerId.toString())throw new Ym("Should not try to find self");const r=this,n=Cs(...this.routers.map((n=>async function*(){try{yield await n.findPeer(e,t)}catch(e){r.log.error(e)}}())));for await(const e of n)if(null!=e)return e.multiaddrs.length>0&&await this.peerStore.merge(e.id,{multiaddrs:e.multiaddrs}),e;throw new Io}async*getClosestPeers(e,t={}){if(0===this.routers.length)throw new Zm("No peer routers available");const r=this,n=function(e,t=.001){return new Lg({...Rg(e,t)})}(1024);for await(const s of async function*(e,t={}){let r=t.concurrency??1/0;r<1&&(r=1/0);const n=t.ordered??!1,s=new EventTarget,o=[];let i,a=fs(),c=fs(),l=!1,u=!1;function h(){return n?o[0]?.done:!!o.find((e=>e.done))}function*d(){for(;o.length>0&&o[0].done;){const e=o[0];if(o.shift(),!e.ok)throw u=!0,a.resolve(),e.err;yield e.value,a.resolve()}}function*p(){for(;h();)for(let e=0;e<o.length;e++)if(o[e].done){const t=o[e];if(o.splice(e,1),e--,!t.ok)throw u=!0,a.resolve(),t.err;yield t.value,a.resolve()}}for(s.addEventListener("task-complete",(()=>{c.resolve()})),Promise.resolve().then((async()=>{try{for await(const t of e){if(o.length===r&&(a=fs(),await a.promise),u)break;const e={done:!1};o.push(e),t().then((t=>{e.done=!0,e.ok=!0,e.value=t,s.dispatchEvent(new vd("task-complete"))}),(t=>{e.done=!0,e.err=t,s.dispatchEvent(new vd("task-complete"))}))}l=!0,s.dispatchEvent(new vd("task-complete"))}catch(e){i=e,s.dispatchEvent(new vd("task-complete"))}}));;){if(h()||(c=fs(),await c.promise),null!=i)throw i;if(n?yield*d():yield*p(),null!=i)throw i;if(l&&0===o.length)break}}(async function*(){const n=Cs(...r.routers.map((r=>r.getClosestPeers(e,t))));for await(let e of n)yield async()=>{if(0===e.multiaddrs.length)try{e=await r.findPeer(e.id,{...t,useCache:!1})}catch(e){return void r.log.error("could not find peer multiaddrs",e)}return e}}()))null!=s&&(s.multiaddrs.length>0&&await this.peerStore.merge(s.id,{multiaddrs:s.multiaddrs}),n.has(s.id.toMultihash().bytes)||(n.add(s.id.toMultihash().bytes),yield s))}}class hb extends qo{peerRouting;log;walking;walkers;shutdownController;walkController;needNext;constructor(e){super(),this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}[Symbol.toStringTag]="@libp2p/random-walk";start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){this.walking||this.startWalk(),this.walkers++;const t=Cy([this.shutdownController.signal,e?.signal]);try{for(;;){this.needNext?.resolve(),this.needNext=fs();const e=await Mg(this,"walk:peer",t,{errorEvent:"walk:error"});yield e.detail}}finally{t.clear(),this.walkers--,0===this.walkers&&(this.walkController?.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=Cy([this.walkController.signal,this.shutdownController.signal]),t=Date.now();let r=0;Promise.resolve().then((async()=>{for(this.log("start walk");this.walkers>0;)try{const t=Pl(32);let n=Date.now();for await(const s of this.peerRouting.getClosestPeers(t,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",s.id,Date.now()-n,this.walkers),r++,this.safeDispatchEvent("walk:peer",{detail:s}),1===this.walkers&&null!=this.needNext&&(this.log("wait for need next"),await vs(this.needNext.promise,e)),n=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",t,this.walkers,r)}catch(e){this.log.error("randomwalk errored",e),this.safeDispatchEvent("walk:error",{detail:e})}this.log("no walkers left, ended walk")})).catch((e=>{this.log.error("randomwalk errored",e)})).finally((()=>{this.log("finished walk, found %d peers after %dms",r,Date.now()-t),this.walking=!1}))}}class db{log;topologies;handlers;components;constructor(e){this.log=e.logger.forComponent("libp2p:registrar"),this.topologies=new Map,this.handlers=new Map,this.components=e,this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}[Symbol.toStringTag]="@libp2p/registrar";getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(null==t)throw new Qm("No handler registered for protocol "+e);return t}getTopologies(e){const t=this.topologies.get(e);return null==t?[]:[...t.values()]}async handle(e,t,r){if(this.handlers.has(e))throw new Jm("Handler already registered for protocol "+e);const n=eg.bind({ignoreUndefined:!0})({maxInboundStreams:32,maxOutboundStreams:64},r);this.handlers.set(e,{handler:t,options:n}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]})}async unhandle(e){(Array.isArray(e)?e:[e]).forEach((e=>{this.handlers.delete(e)})),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()})}async register(e,t){if(null==t)throw new yo("invalid topology");const r=`${(1e9*Math.random()).toString(36)}${Date.now()}`;let n=this.topologies.get(e);return null==n&&(n=new Map,this.topologies.set(e,n)),n.set(r,t),r}unregister(e){for(const[t,r]of this.topologies.entries())r.has(e)&&(r.delete(e),0===r.size&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail;this.components.peerStore.get(t).then((e=>{for(const r of e.protocols){const e=this.topologies.get(r);if(null!=e)for(const r of e.values())!1!==r.filter?.has(t)&&(r.filter?.remove(t),r.onDisconnect?.(t))}})).catch((e=>{"NotFoundError"!==e.name&&this.log.error("could not inform topologies of disconnecting peer %p",t,e)}))}_onPeerUpdate(e){const{peer:t,previous:r}=e.detail,n=(r?.protocols??[]).filter((e=>!t.protocols.includes(e)));for(const e of n){const r=this.topologies.get(e);if(null!=r)for(const e of r.values())!1!==e.filter?.has(t.id)&&(e.filter?.remove(t.id),e.onDisconnect?.(t.id))}}_onPeerIdentify(e){const t=e.detail.protocols,r=e.detail.connection,n=e.detail.peerId;for(const e of t){const t=this.topologies.get(e);if(null!=t)for(const e of t.values())null!=r.limits&&!0!==e.notifyOnLimitedConnection||!0!==e.filter?.has(n)&&(e.filter?.add(n),e.onConnect?.(n,r))}}}class pb extends Map{metric;constructor(e){super();const{name:t,metrics:r}=e;this.metric=r.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}class fb{log;components;transports;listeners;faultTolerance;started;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=new Map,this.listeners=function(e){const{name:t,metrics:r}=e;let n;return n=null!=r?new pb({name:t,metrics:r}):new Map,n}({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??fo.FATAL_ALL}[Symbol.toStringTag]="@libp2p/transport-manager";add(e){const t=e[Symbol.toStringTag];if(null==t)throw new yo("Transport must have a valid tag");if(this.transports.has(t))throw new yo("There is already a transport with the tag "+t);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,r]of this.listeners)for(this.log("closing listeners for %s",t);r.length>0;){const t=r.pop();null!=t&&e.push(t.close())}await Promise.all(e),this.log("all listeners closed");for(const e of this.listeners.keys())this.listeners.set(e,[]);this.started=!1}async dial(e,t){const r=this.dialTransportForMultiaddr(e);if(null==r)throw new iy("No transport available for address "+(e+""));return t?.onProgress?.(new bf("transport-manager:selected-transport",r[Symbol.toStringTag])),r.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const r of t)e=[...e,...r.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values()){if(t.dialFilter([e]).length>0)return t}}listenTransportForMultiaddr(e){for(const t of this.transports.values()){if(t.listenFilter([e]).length>0)return t}}async listen(e){if(!this.isStarted())throw new No("Not started");if(null==e||0===e.length)return void this.log("no addresses were provided for listening, this node is dial only");const t=[];for(const[r,n]of this.transports.entries()){const s=n.listenFilter(e),o=[];for(const e of s){this.log("creating listener for %s on %a",r,e);const t=n.createListener({upgrader:this.components.upgrader});let s=this.listeners.get(r)??[];null==s&&(s=[],this.listeners.set(r,s)),s.push(t),t.addEventListener("listening",(()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:t})})),t.addEventListener("close",(()=>{const e=s.findIndex((e=>e===t));s.splice(e,1),this.components.events.safeDispatchEvent("transport:close",{detail:t})})),o.push(t.listen(e))}if(0===o.length){t.push(r);continue}if(null==(await Promise.allSettled(o)).find((e=>"fulfilled"===e.status))&&this.faultTolerance!==fo.NO_FATAL)throw new ty(`Transport (${r}) could not listen on any available address`)}if(t.length===this.transports.size){const e=`no valid addresses were provided for transports [${t.join(", ")}]`;if(this.faultTolerance===fo.FATAL_ALL)throw new ty(e);this.log("libp2p in dial mode only: "+e)}}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const r=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const e=t.pop();null!=e&&r.push(e.close())}await Promise.all(r),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}const gb="/multistream/1.0.0",mb=1024,yb=tt("\n");async function bb(e,t,r){await e.write(t,r)}async function wb(e,t){const r=await async function(e,t){const r=await e.read(t);if(0===r.byteLength||r.get(r.byteLength-1)!==yb[0])throw t.log.error("Invalid mss message - missing newline",r),new Ro("Missing newline");return r.sublist(0,-1)}(e,t);return mn(r.subarray())}async function vb(e,t,r){if(1===(t=Array.isArray(t)?[...t]:[t]).length&&!1===r.negotiateFully)return function(e,t,r){const n=e.sink.bind(e),s=e.source;let o=!1,i=!1;const a=fs();let c=!1,l=!1;const u=fs();let d=!1,p=!1;const f=fs(),g=Id({sink:n,source:s},{...r,maxDataLength:mb});async function m(){if(i)return r.log.trace("optimistic: already negotiating %s stream",t),void await a.promise;i=!0;try{c||(r.log.trace("optimistic: doing send protocol for %s stream",t),await y()),d||(r.log.trace("optimistic: doing read protocol for %s stream",t),await b())}finally{i=!1,o=!0,a.resolve()}}async function y(){if(l)await u.promise;else{l=!0;try{r.log.trace('optimistic: write ["%s", "%s", data] in source',gb,t),await g.writeV([tt(gb+"\n"),tt(t+"\n")]),r.log.trace('optimistic: wrote ["%s", "%s", data] in source',gb,t)}finally{c=!0,l=!1,u.resolve()}}}async function b(){if(p)await f.promise;else{p=!0;try{r.log.trace("optimistic: reading multistream select header");let e=await wb(g,r);if(r.log.trace('optimistic: read multistream select header "%s"',e),e===gb&&(e=await wb(g,r)),r.log.trace('optimistic: read protocol "%s", expecting "%s"',e,t),e!==t)throw new _o("protocol selection failed")}finally{d=!0,p=!1,f.resolve()}}}if(e.sink=async e=>{const{sink:n}=g.unwrap();await n(async function*(){let n=!1;for await(const s of e){if(l&&await u.promise,c)yield s;else{l=!0,r.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',gb,t,s.byteLength);const e=t+"\n";yield new ns(Uint8Array.from([19]),tt(gb+"\n"),h(e.length),tt(e),s).subarray(),r.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',gb,t,s.byteLength),c=!0,l=!1,u.resolve(),m().catch((e=>{r.log.error("could not finish optimistic protocol negotiation of %s",t,e)}))}n=!0}n||await m()}())},e.source=async function*(){await m(),r.log.trace('optimistic: reading data from "%s" stream',t),yield*g.unwrap().source}(),null!=e.closeRead){const t=e.closeRead.bind(e);e.closeRead=async e=>{o||await m().catch((e=>{r.log.error("could not negotiate protocol before close read",e)})),await t(e)}}if(null!=e.closeWrite){const t=e.closeWrite.bind(e);e.closeWrite=async e=>{o||await m().catch((e=>{r.log.error("could not negotiate protocol before close write",e)})),await t(e)}}if(null!=e.close){const t=e.close.bind(e);e.close=async e=>{const r=[];l&&r.push(u.promise),p&&r.push(f.promise),r.length>0?await vs(Promise.all(r),e?.signal):(o=!0,i=!1,a.resolve()),await t(e)}}return{stream:e,protocol:t}}(e,t[0],r);const n=Id(e,{...r,maxDataLength:mb}),s=t.shift();if(null==s)throw Error("At least one protocol must be specified");r.log.trace('select: write ["%s", "%s"]',gb,s);const o=tt(gb+"\n"),i=tt(s+"\n");await async function(e,t,r){await e.writeV(t,r)}(n,[o,i],r),r.log.trace("select: reading multistream-select header");let a=await wb(n,r);if(r.log.trace('select: read "%s"',a),a===gb&&(r.log.trace("select: reading protocol response"),a=await wb(n,r),r.log.trace('select: read "%s"',a)),a===s)return{stream:n.unwrap(),protocol:s};for(const e of t){r.log.trace('select: write "%s"',e),await bb(n,tt(e+"\n"),r),r.log.trace("select: reading protocol response");const t=await wb(n,r);if(r.log.trace('select: read "%s" for "%s"',t,e),t===e)return{stream:n.unwrap(),protocol:e}}throw new _o("protocol selection failed")}const Eb=4194304;class Sb extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"}function Ab(e,t){if(e.byteLength>t)throw new Sb("Message length too long")}const Cb=e=>{const r=c(e),n=t(r);return h(e,n),Cb.bytes=r,n};function Ib(e,t){const r=(t=t??{}).lengthEncoder??Cb,n=t?.maxDataLength??Eb;function*s(e){Ab(e,n);const t=r(e.byteLength);t instanceof Uint8Array?yield t:yield*t,e instanceof Uint8Array?yield e:yield*e}return null!=e[Symbol.asyncIterator]?async function*(){for await(const t of e)yield*s(t)}():function*(){for(const t of e)yield*s(t)}()}var xb;async function kb(e,t,r){t=Array.isArray(t)?t:[t],r.log.trace("handle: available protocols %s",t);const n=Id(e,{...r,maxDataLength:mb,maxLengthLength:2});for(;;){r.log.trace("handle: reading incoming string");const e=await wb(n,r);if(r.log.trace('handle: read "%s"',e),e!==gb){if(t.includes(e))return r.log.trace('handle: respond with "%s" for "%s"',e,e),await bb(n,tt(e+"\n"),r),r.log.trace('handle: responded with "%s" for "%s"',e,e),{stream:n.unwrap(),protocol:e};if("ls"!==e)r.log.trace('handle: respond with "na" for "%s"',e),await bb(n,tt("na\n"),r),r.log('handle: responded with "na" for "%s"',e);else{const s=new ns(...t.map((e=>Ib.single(tt(e+"\n")))),tt("\n"));r.log.trace('handle: respond with "%s" for %s',t,e),await bb(n,s,r),r.log.trace('handle: responded with "%s" for %s',t,e)}}else r.log.trace('handle: respond with "%s" for "%s"',gb,e),await bb(n,tt(gb+"\n"),r),r.log.trace('handle: responded with "%s" for "%s"',gb,e)}}Cb.bytes=0,Ib.single=(e,t)=>{const r=(t=t??{}).lengthEncoder??Cb;return Ab(e,t?.maxDataLength??Eb),new ns(r(e.byteLength),e)},(e=>{e[e.LENGTH=0]="LENGTH",e[e.DATA=1]="DATA"})(xb||(xb={}));class Pb{id;remoteAddr;remotePeer;direction;timeline;multiplexer;encryption;status;limits;log;tags;_newStream;_close;_abort;_getStreams;constructor(e){const{remoteAddr:t,remotePeer:r,newStream:n,close:s,abort:o,getStreams:i}=e;this.id=`${parseInt(1e9*Math.random()+"").toString(36)}${Date.now()}`,this.remoteAddr=t,this.remotePeer=r,this.direction=e.direction,this.status="open",this.timeline=e.timeline,this.multiplexer=e.multiplexer,this.encryption=e.encryption,this.limits=e.limits,this.log=e.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),null==this.remoteAddr.getPeerId()&&(this.remoteAddr=this.remoteAddr.encapsulate("/p2p/"+this.remotePeer)),this._newStream=n,this._close=s,this._abort=o,this._getStreams=i,this.tags=[]}[Symbol.toStringTag]="Connection";[oo]=!0;get streams(){return this._getStreams()}async newStream(e,t){if("closing"===this.status)throw new wo("the connection is being closed");if("closed"===this.status)throw new vo("the connection is closed");if(Array.isArray(e)||(e=[e]),null!=this.limits&&!0!==t?.runOnLimitedConnection)throw new Oo("Cannot open protocol stream on limited connection");const r=await this._newStream(e,t);return r.direction="outbound",r}async close(e={}){if("closed"!==this.status&&"closing"!==this.status){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",null==e.signal){const t=AbortSignal.timeout(500);e={...e,signal:t}}try{this.log.trace("closing underlying transport"),await this._close(e),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(e){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,e),this.abort(e)}}}abort(e){"closed"!==this.status&&(this.log.error("aborting connection to %a due to error",this.remoteAddr,e),this.status="closing",this._abort(e),this.status="closed",this.timeline.close=Date.now())}}function Tb(e,t,r){let n=0;return r.streams.forEach((r=>{r.direction===t&&r.protocol===e&&n++})),n}class _b{components;connectionEncrypters;streamMuxers;inboundUpgradeTimeout;outboundUpgradeTimeout;inboundStreamProtocolNegotiationTimeout;outboundStreamProtocolNegotiationTimeout;events;metrics;constructor(e,t){this.components=e,this.connectionEncrypters=new Map,t.connectionEncrypters.forEach((e=>{this.connectionEncrypters.set(e.protocol,e)})),this.streamMuxers=new Map,t.streamMuxers.forEach((e=>{this.streamMuxers.set(e.protocol,e)})),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??3e3,this.outboundUpgradeTimeout=t.outboundUpgradeTimeout??3e3,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??2e3,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??2e3,this.events=e.events,this.metrics={dials:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total")}}[Symbol.toStringTag]="@libp2p/upgrader";async shouldBlockConnection(e,...t){const r=this.components.connectionGater[e];if(null==r)return;if(!0===await r.apply(this.components.connectionGater,t))throw new ry("The multiaddr connection is blocked by gater."+e)}async upgradeInbound(e,t={}){try{this.metrics.dials?.increment({inbound:!0});if(!await this.components.connectionManager.acceptIncomingConnection(e))throw new ny("connection denied");await this.shouldBlockConnection("denyInboundConnection",e);return await this._performUpgrade(e,"inbound",t)}catch(e){throw this.metrics.errors?.increment({inbound:!0}),e}finally{this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t={}){try{this.metrics.dials?.increment({outbound:!0});const r=e.remoteAddr.getPeerId();let n;return null!=r&&(n=pu(r),await this.shouldBlockConnection("denyOutboundConnection",n,e)),await this._performUpgrade(e,"outbound",t)}catch(e){throw this.metrics.errors?.increment({outbound:!0}),e}}async _performUpgrade(e,t,r){let n,s,o,i,a;const c=Cy([AbortSignal.timeout("inbound"===t?this.inboundUpgradeTimeout:this.outboundUpgradeTimeout),r.signal]);r.signal=c,this.components.metrics?.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t);let l=e;if(!0!==r?.skipProtection){const n=this.components.connectionProtector;null!=n&&(e.log("protecting the %s connection",t),l=await n.protect(e,r))}try{if(n=l,!0!==r?.skipEncryption){r?.onProgress?.(new bf(`upgrader:encrypt-${t}-connection`)),({conn:n,remotePeer:s,protocol:a}=await("inbound"===t?this._encryptInbound(l,{...r,signal:c}):this._encryptOutbound(l,{...r,signal:c})));const e={...l,...n};await this.shouldBlockConnection("inbound"===t?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",s,e)}else{const r=e.remoteAddr.getPeerId();if(null==r)throw new ko(t+" connection that skipped encryption must have a peer id");const n=pu(r);a="native",s=n}if(s.equals(this.components.peerId)){const t=new xo("Can not dial self");throw e.abort(t),t}if(o=n,null!=r?.muxerFactory)i=r.muxerFactory;else if(this.streamMuxers.size>0){r?.onProgress?.(new bf(`upgrader:multiplex-${t}-connection`));const e=await("inbound"===t?this._multiplexInbound({...l,...n},this.streamMuxers,r):this._multiplexOutbound({...l,...n},this.streamMuxers,r));i=e.muxerFactory,o=e.stream}}catch(r){throw e.log.error("failed to upgrade inbound connection %s %a - %e","inbound"===t?"from":"to",e.remoteAddr,r),r}finally{c.clear()}return await this.shouldBlockConnection("inbound"===t?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",s,e),e.log("successfully upgraded %s connection",t),this._createConnection({cryptoProtocol:a,direction:t,maConn:e,upgradedConn:o,muxerFactory:i,remotePeer:s,limits:r?.limits})}_createConnection(e){const{cryptoProtocol:t,direction:r,maConn:n,upgradedConn:s,remotePeer:o,muxerFactory:i,limits:a}=e;let c,l,u;null!=i&&(c=i.createStreamMuxer({direction:r,onIncomingStream:e=>{null!=u&&Promise.resolve().then((async()=>{const t=this.components.registrar.getProtocols(),r=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout),{stream:n,protocol:s}=await kb(e,t,{signal:r,log:e.log,yieldBytes:!1});if(null==u)return;u.log("incoming stream opened on %s",s);const i=function(e,t){try{const{options:r}=t.getHandler(e);return r.maxInboundStreams}catch(e){if("UnhandledProtocolError"!==e.name)throw e}return 32}(s,this.components.registrar);if(Tb(s,"inbound",u)===i){const t=new Fo(`Too many inbound protocol streams for protocol "${s}" - limit ${i}`);throw e.abort(t),t}e.source=n.source,e.sink=n.sink,e.protocol=s,null!=n.closeWrite&&(e.closeWrite=n.closeWrite),null!=n.closeRead&&(e.closeRead=n.closeRead),null!=n.close&&(e.close=n.close),await this.components.peerStore.merge(o,{protocols:[s]}),this.components.metrics?.trackProtocolStream(e,u),this._onStream({connection:u,stream:e,protocol:s})})).catch((async t=>{u.log.error("error handling incoming stream id %s - %e",e.id,t),null==e.timeline.close&&await e.close()}))}}),l=async(t,n={})=>{if(null==c)throw new sy("Connection is not multiplexed");u.log.trace("starting new stream for protocols %s",t);const s=await c.newStream();u.log.trace("started new stream %s for protocols %s",s.id,t);try{if(null==n.signal){s.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",t);const e=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);n={...n,signal:e}}s.log.trace("selecting protocol from protocols %s",t);const{stream:e,protocol:r}=await vb(s,t,{...n,log:s.log,yieldBytes:!0});s.log.trace("selected protocol %s",r);const i=function(e,t,r={}){try{const{options:r}=t.getHandler(e);if(null!=r.maxOutboundStreams)return r.maxOutboundStreams}catch(e){if("UnhandledProtocolError"!==e.name)throw e}return r.maxOutboundStreams??64}(r,this.components.registrar,n),a=Tb(r,"outbound",u);if(a>=i){const e=new Uo(`Too many outbound protocol streams for protocol "${r}" - ${a}/${i}`);throw s.abort(e),e}return await this.components.peerStore.merge(o,{protocols:[r]}),s.source=e.source,s.sink=e.sink,s.protocol=r,null!=e.closeWrite&&(s.closeWrite=e.closeWrite),null!=e.closeRead&&(s.closeRead=e.closeRead),null!=e.close&&(s.close=e.close),this.components.metrics?.trackProtocolStream(s,u),s}catch(n){throw u.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e","inbound"===r?"from":"to",e.maConn.remoteAddr,t,n),null==s.timeline.close&&s.abort(n),n}},Promise.all([c.sink(s.source),s.sink(c.source)]).catch((e=>{u.log.error("error piping data through muxer - %e",e)})));const h=n.timeline;n.timeline=new Proxy(h,{set:(...e)=>("close"===e[1]&&null!=e[2]&&null==h.close&&(async()=>{try{"open"===u.status&&await u.close()}catch(e){u.log.error("error closing connection after timeline close %e",e)}finally{this.events.safeDispatchEvent("connection:close",{detail:u})}})().catch((e=>{u.log.error("error thrown while dispatching connection:close event %e",e)})),Reflect.set(...e))}),n.timeline.upgraded=Date.now();var d;return d={remoteAddr:n.remoteAddr,remotePeer:o,status:"open",direction:r,timeline:n.timeline,multiplexer:c?.protocol,encryption:t,limits:a,logger:this.components.logger,newStream:l??(()=>{throw new sy("Connection is not multiplexed")}),getStreams:()=>c?.streams??[],async close(e){await(c?.close(e)),await n.close(e)},abort(e){n.abort(e),c?.abort(e)}},u=new Pb(d),this.events.safeDispatchEvent("connection:open",{detail:u}),u.__maConnTimeline=h,u}_onStream(e){const{connection:t,stream:r,protocol:n}=e,{handler:s,options:o}=this.components.registrar.getHandler(n);if(null!=t.limits&&!0!==o.runOnLimitedConnection)throw new Oo("Cannot open protocol stream on limited connection");s({connection:t,stream:r})}async _encryptInbound(e,t){const r=Array.from(this.connectionEncrypters.keys());try{const{stream:n,protocol:s}=await kb(e,r,{...t,log:e.log}),o=this.connectionEncrypters.get(s);if(null==o)throw new oy("no crypto module found for "+s);return e.log("encrypting inbound connection to %a using %s",e.remoteAddr,s),{...await o.secureInbound(n,t),protocol:s}}catch(t){throw e.log.error("encrypting inbound connection from %a failed",e.remoteAddr,t),new oy(t.message)}}async _encryptOutbound(e,t){const r=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",r);const{stream:n,protocol:s}=await vb(e,r,{...t,log:e.log,yieldBytes:!0}),o=this.connectionEncrypters.get(s);if(null==o)throw new oy("no crypto module found for "+s);return e.log("encrypting outbound connection to %a using %s",e.remoteAddr,s),{...await o.secureOutbound(n,t),protocol:s}}catch(t){throw e.log.error("encrypting outbound connection to %a failed",e.remoteAddr,t),new oy(t.message)}}async _multiplexOutbound(e,t,r){const n=Array.from(t.keys());e.log("outbound selecting muxer %s",n);try{e.log.trace("selecting stream muxer from %s",n);const{stream:s,protocol:o}=await vb(e,n,{...r,log:e.log,yieldBytes:!0});e.log("selected %s as muxer protocol",o);return{stream:s,muxerFactory:t.get(o)}}catch(t){throw e.log.error("error multiplexing outbound connection",t),new sy(t+"")}}async _multiplexInbound(e,t,r){const n=Array.from(t.keys());e.log("inbound handling muxers %s",n);try{const{stream:s,protocol:o}=await kb(e,n,{...r,log:e.log});return{stream:s,muxerFactory:t.get(o)}}catch(t){throw e.log.error("error multiplexing inbound connection",t),new sy(t+"")}}}class Rb extends qo{peerId;peerStore;contentRouting;peerRouting;metrics;services;logger;status;components;log;constructor(e){super(),this.status="stopped";const t=new qo,r=t.dispatchEvent.bind(t);t.dispatchEvent=e=>{const t=r(e),n=this.dispatchEvent(new CustomEvent(e.type,{detail:e.detail}));return t||n},this.peerId=e.peerId,this.logger=e.logger??fg(),this.log=this.logger.forComponent("libp2p"),this.services={};const n=this.components=function(e={}){const t=new ay(e);return new Proxy(t,{get(e,r,n){if("string"==typeof r&&!ly.includes(r)){const e=t.components[r];if(null==e&&!cy.includes(r))throw new Gm(r+" not set");return e}return Reflect.get(e,r,n)},set(e,r,n){return"string"==typeof r?t.components[r]=n:Reflect.set(e,r,n),!0}})}({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:e.nodeInfo??{name:"libp2p",version:"2.1.8"},logger:this.logger,events:t,datastore:e.datastore??new zm,connectionGater:py(e.connectionGater),dns:e.dns});this.peerStore=this.configureComponent("peerStore",function(e,t={}){return new Om(e,t)}(n,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),null!=e.metrics&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),n.events.addEventListener("peer:update",(e=>{if(null==e.detail.previous){const t={id:e.detail.peer.id,multiaddrs:e.detail.peer.addresses.map((e=>e.multiaddr))};n.events.safeDispatchEvent("peer:discovery",{detail:t})}})),null!=e.connectionProtector&&this.configureComponent("connectionProtector",e.connectionProtector(n)),this.components.upgrader=new _b(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map(((e,t)=>this.configureComponent("connection-encryption-"+t,e(this.components)))),streamMuxers:(e.streamMuxers??[]).map(((e,t)=>this.configureComponent("stream-muxers-"+t,e(this.components)))),inboundUpgradeTimeout:e.connectionManager?.inboundUpgradeTimeout,outboundUpgradeTimeout:e.connectionManager?.outboundUpgradeTimeout}),this.configureComponent("transportManager",new fb(this.components,e.transportManager)),this.configureComponent("connectionManager",new eb(this.components,e.connectionManager)),!1!==e.connectionMonitor?.enabled&&this.configureComponent("connectionMonitor",new cb(this.components,e.connectionMonitor)),this.configureComponent("registrar",new db(this.components)),this.configureComponent("addressManager",new Hm(this.components,e.addresses));const s=(e.peerRouters??[]).map(((e,t)=>this.configureComponent("peer-router-"+t,e(this.components))));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new ub(this.components,{routers:s}));const o=(e.contentRouters??[]).map(((e,t)=>this.configureComponent("content-router-"+t,e(this.components))));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new lb(this.components,{routers:o})),this.configureComponent("randomWalk",new hb(this.components)),(e.peerDiscovery??[]).forEach(((e,t)=>{this.configureComponent("peer-discovery-"+t,e(this.components)).addEventListener("peer",(e=>{this.#N(e)}))})),e.transports?.forEach(((e,t)=>{this.components.transportManager.add(this.configureComponent("transport-"+t,e(this.components)))})),null!=e.services)for(const t of Object.keys(e.services)){const r=(0,e.services[t])(this.components);null!=r?(this.services[t]=r,this.configureComponent(t,r),null!=r[io]&&(this.log("registering service %s for content routing",t),o.push(r[io])),null!=r[uo]&&(this.log("registering service %s for peer routing",t),s.push(r[uo])),null!=r[ao]&&(this.log("registering service %s for peer discovery",t),r[ao].addEventListener?.("peer",(e=>{this.#N(e)})))):this.log.error("service factory %s returned null or undefined instance",t)}!function(e){const t={};for(const r of Object.values(e.components))for(const e of uy(r))t[e]=!0;for(const r of Object.values(e.components))for(const e of hy(r))if(!0!==t[e])throw new Wm(`Service "${dy(r)}" required capability "${e}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}(n)}configureComponent(e,t){return null==t&&this.log.error("component %s was null or undefined",e),this.components[e]=t,t}async start(){if("stopped"===this.status){this.status="starting",this.log("libp2p is starting");try{await(this.components.beforeStart?.()),await this.components.start(),await(this.components.afterStart?.()),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(e){throw this.log.error("An error occurred starting libp2p",e),this.status="started",await this.stop(),e}}}async stop(){"started"===this.status&&(this.log("libp2p is stopping"),this.status="stopping",await(this.components.beforeStop?.()),await this.components.stop(),await(this.components.afterStop?.()),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new vg;for(const t of this.components.connectionManager.getConnections())e.add(t.remotePeer);return Array.from(e)}async dial(e,t={}){return this.components.connectionManager.openConnection(e,{priority:75,...t})}async dialProtocol(e,t,r={}){if(null==t)throw new yo("no protocols were provided to open a stream");if(0===(t=Array.isArray(t)?t:[t]).length)throw new yo("no protocols were provided to open a stream");return(await this.dial(e,r)).newStream(t,r)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,t={}){_i(e)&&(e=pu(e.getPeerId()??"")),await this.components.connectionManager.closeConnections(e,t)}async getPublicKey(e,t={}){if(this.log("getPublicKey %p",e),null!=e.publicKey)return e.publicKey;try{const t=await this.peerStore.get(e);if(null!=t.id.publicKey)return t.id.publicKey}catch(e){if("NotFoundError"!==e.name)throw e}const r=Qn([tt("/pk/"),e.toMultihash().bytes]),n=ou(await this.contentRouting.get(r,t));return await this.peerStore.patch(e,{publicKey:n}),n}async handle(e,t,r){Array.isArray(e)||(e=[e]),await Promise.all(e.map((async e=>{await this.components.registrar.handle(e,t,r)})))}async unhandle(e){Array.isArray(e)||(e=[e]),await Promise.all(e.map((async e=>{await this.components.registrar.unhandle(e)})))}async register(e,t){return this.components.registrar.register(e,t)}unregister(e){this.components.registrar.unregister(e)}async isDialable(e,t={}){return this.components.connectionManager.isDialable(e,t)}#N(e){const{detail:t}=e;t.id.toString()!==this.peerId.toString()?this.components.peerStore.merge(t.id,{multiaddrs:t.multiaddrs}).catch((e=>{this.log.error(e)})):this.log.error("peer discovery mechanism discovered self")}}function Lb(){try{return!1}catch(e){return!1}}const Db="enrtree://AIRVQ5DDA4FFWLRBCHJWUWOO6X6S4ZTZ5B667LQ6AJU6PEYDLRD5O@sandbox.waku.nodes.status.im",Nb="bootstrap",Mb={store:1,filter:2,lightPush:2},Ob="Invalid record id";var Fb=Object.freeze({__proto__:null,default:{}});const Ub=BigInt(0),Bb=BigInt(1),qb=BigInt(2),$b=BigInt(3),zb=BigInt(8),Kb=Object.freeze({a:Ub,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:Bb,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")}),Vb=(e,t)=>(e+t/qb)/t,Hb={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(e){const{n:t}=Kb,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Bb*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=r,i=BigInt("0x100000000000000000000000000000000"),a=Vb(o*e,t),c=Vb(-n*e,t);let l=Ew(e-a*r-c*s,t),u=Ew(-a*n-c*o,t);const h=l>i,d=u>i;if(h&&(l=t-l),d&&(u=t-u),l>i||u>i)throw Error("splitScalarEndo: Endomorphism failed, k="+e);return{k1neg:h,k1:l,k2neg:d,k2:u}}},jb=32,Gb=32;function Wb(e){const{a:t,b:r}=Kb,n=Ew(e*e),s=Ew(n*e);return Ew(s+t*e+r)}const Xb=Kb.a===Ub;class Zb extends Error{constructor(e){super(e)}}function Yb(e){if(!(e instanceof Qb))throw new TypeError("JacobianPoint expected")}class Qb{constructor(e,t,r){this.x=e,this.y=t,this.z=r}static fromAffine(e){if(!(e instanceof tw))throw new TypeError("JacobianPoint#fromAffine: expected Point");return e.equals(tw.ZERO)?Qb.ZERO:new Qb(e.x,e.y,Bb)}static toAffineBatch(e){const t=function(e,t=Kb.P){const r=Array(e.length),n=Aw(e.reduce(((e,n,s)=>n===Ub?e:(r[s]=e,Ew(e*n,t))),Bb),t);return e.reduceRight(((e,n,s)=>n===Ub?e:(r[s]=Ew(e*r[s],t),Ew(e*n,t))),n),r}(e.map((e=>e.z)));return e.map(((e,r)=>e.toAffine(t[r])))}static normalizeZ(e){return Qb.toAffineBatch(e).map(Qb.fromAffine)}equals(e){Yb(e);const{x:t,y:r,z:n}=this,{x:s,y:o,z:i}=e,a=Ew(n*n),c=Ew(i*i),l=Ew(t*c),u=Ew(s*a),h=Ew(Ew(r*i)*c),d=Ew(Ew(o*n)*a);return l===u&&h===d}negate(){return new Qb(this.x,Ew(-this.y),this.z)}double(){const{x:e,y:t,z:r}=this,n=Ew(e*e),s=Ew(t*t),o=Ew(s*s),i=e+s,a=Ew(qb*(Ew(i*i)-n-o)),c=Ew($b*n),l=Ew(c*c),u=Ew(l-qb*a),h=Ew(c*(a-u)-zb*o),d=Ew(qb*t*r);return new Qb(u,h,d)}add(e){Yb(e);const{x:t,y:r,z:n}=this,{x:s,y:o,z:i}=e;if(s===Ub||o===Ub)return this;if(t===Ub||r===Ub)return e;const a=Ew(n*n),c=Ew(i*i),l=Ew(t*c),u=Ew(s*a),h=Ew(Ew(r*i)*c),d=Ew(Ew(o*n)*a),p=Ew(u-l),f=Ew(d-h);if(p===Ub)return f===Ub?this.double():Qb.ZERO;const g=Ew(p*p),m=Ew(p*g),y=Ew(l*g),b=Ew(f*f-m-qb*y),w=Ew(f*(y-b)-h*m),v=Ew(n*i*p);return new Qb(b,w,v)}subtract(e){return this.add(e.negate())}multiplyUnsafe(e){const t=Qb.ZERO;if("bigint"==typeof e&&e===Ub)return t;let r=vw(e);if(r===Bb)return this;if(!Xb){let e=t,n=this;for(;r>Ub;)r&Bb&&(e=e.add(n)),n=n.double(),r>>=Bb;return e}let{k1neg:n,k1:s,k2neg:o,k2:i}=Hb.splitScalar(r),a=t,c=t,l=this;for(;s>Ub||i>Ub;)s&Bb&&(a=a.add(l)),i&Bb&&(c=c.add(l)),l=l.double(),s>>=Bb,i>>=Bb;return n&&(a=a.negate()),o&&(c=c.negate()),c=new Qb(Ew(c.x*Hb.beta),c.y,c.z),a.add(c)}precomputeWindow(e){const t=Xb?128/e+1:256/e+1,r=[];let n=this,s=n;for(let o=0;o<t;o++){s=n,r.push(s);for(let t=1;t<2**(e-1);t++)s=s.add(n),r.push(s);n=s.double()}return r}wNAF(e,t){!t&&this.equals(Qb.BASE)&&(t=tw.BASE);const r=t&&t._WINDOW_SIZE||1;if(256%r)throw Error("Point#wNAF: Invalid precomputation window, must be power of 2");let n=t&&ew.get(t);n||(n=this.precomputeWindow(r),t&&1!==r&&(n=Qb.normalizeZ(n),ew.set(t,n)));let s=Qb.ZERO,o=Qb.BASE;const i=1+(Xb?128/r:256/r),a=2**(r-1),c=BigInt(2**r-1),l=2**r,u=BigInt(r);for(let t=0;t<i;t++){const r=t*a;let i=Number(e&c);e>>=u,i>a&&(i-=l,e+=Bb);const h=r,d=r+Math.abs(i)-1,p=t%2!=0,f=i<0;0===i?o=o.add(Jb(p,n[h])):s=s.add(Jb(f,n[d]))}return{p:s,f:o}}multiply(e,t){let r,n,s=vw(e);if(Xb){const{k1neg:e,k1:o,k2neg:i,k2:a}=Hb.splitScalar(s);let{p:c,f:l}=this.wNAF(o,t),{p:u,f:h}=this.wNAF(a,t);c=Jb(e,c),u=Jb(i,u),u=new Qb(Ew(u.x*Hb.beta),u.y,u.z),r=c.add(u),n=l.add(h)}else{const{p:e,f:o}=this.wNAF(s,t);r=e,n=o}return Qb.normalizeZ([r,n])[0]}toAffine(e){const{x:t,y:r,z:n}=this,s=this.equals(Qb.ZERO);null==e&&(e=s?zb:Aw(n));const o=e,i=Ew(o*o),a=Ew(i*o),c=Ew(t*i),l=Ew(r*a),u=Ew(n*o);if(s)return tw.ZERO;if(u!==Bb)throw Error("invZ was invalid");return new tw(c,l)}}function Jb(e,t){const r=t.negate();return e?r:t}Qb.BASE=new Qb(Kb.Gx,Kb.Gy,Bb),Qb.ZERO=new Qb(Ub,Bb,Ub);const ew=new WeakMap;class tw{constructor(e,t){this.x=e,this.y=t}_setWindowSize(e){this._WINDOW_SIZE=e,ew.delete(this)}hasEvenY(){return this.y%qb===Ub}static fromCompressedHex(e){const t=32===e.length,r=bw(t?e:e.subarray(1));if(!Tw(r))throw Error("Point is not on curve");let n=function(e){const{P:t}=Kb,r=BigInt(6),n=BigInt(11),s=BigInt(22),o=BigInt(23),i=BigInt(44),a=BigInt(88),c=e*e*e%t,l=c*c*e%t,u=Sw(l,$b)*l%t,h=Sw(u,$b)*l%t,d=Sw(h,qb)*c%t,p=Sw(d,n)*d%t,f=Sw(p,s)*p%t,g=Sw(f,i)*f%t,m=Sw(g,a)*g%t,y=Sw(m,i)*f%t,b=Sw(y,$b)*l%t,w=Sw(b,o)*p%t,v=Sw(w,r)*c%t,E=Sw(v,qb);if(E*E%t!==e)throw Error("Cannot find square root");return E}(Wb(r));const s=(n&Bb)===Bb;if(t)s&&(n=Ew(-n));else{!(1&~e[0])!==s&&(n=Ew(-n))}const o=new tw(r,n);return o.assertValidity(),o}static fromUncompressedHex(e){const t=bw(e.subarray(1,33)),r=bw(e.subarray(33,65)),n=new tw(t,r);return n.assertValidity(),n}static fromHex(e){const t=ww(e),r=t.length,n=t[0];if(r===jb)return this.fromCompressedHex(t);if(33===r&&(2===n||3===n))return this.fromCompressedHex(t);if(65===r&&4===n)return this.fromUncompressedHex(t);throw Error("Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not "+r)}static fromPrivateKey(e){return tw.BASE.multiply(Rw(e))}static fromSignature(e,t,r){const{r:n,s}=Lw(t);if(![0,1,2,3].includes(r))throw Error("Cannot recover: invalid recovery bit");const o=Cw(ww(e)),{n:i}=Kb,a=2===r||3===r?n+i:n,c=Aw(a,i),l=Ew(-o*c,i),u=Ew(s*c,i),h=1&r?"03":"02",d=tw.fromHex(h+fw(a)),p=tw.BASE.multiplyAndAddUnsafe(d,l,u);if(!p)throw Error("Cannot recover signature: point at infinify");return p.assertValidity(),p}toRawBytes(e=!1){return dw(this.toHex(e))}toHex(e=!1){const t=fw(this.x);if(e){return`${this.hasEvenY()?"02":"03"}${t}`}return`04${t}${fw(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const e="Point is not on elliptic curve",{x:t,y:r}=this;if(!Tw(t)||!Tw(r))throw Error(e);const n=Ew(r*r);if(Ew(n-Wb(t))!==Ub)throw Error(e)}equals(e){return this.x===e.x&&this.y===e.y}negate(){return new tw(this.x,Ew(-this.y))}double(){return Qb.fromAffine(this).double().toAffine()}add(e){return Qb.fromAffine(this).add(Qb.fromAffine(e)).toAffine()}subtract(e){return this.add(e.negate())}multiply(e){return Qb.fromAffine(this).multiply(e,this).toAffine()}multiplyAndAddUnsafe(e,t,r){const n=Qb.fromAffine(this),s=t===Ub||t===Bb||this!==tw.BASE?n.multiplyUnsafe(t):n.multiply(t),o=Qb.fromAffine(e).multiplyUnsafe(r),i=s.add(o);return i.equals(Qb.ZERO)?void 0:i.toAffine()}}function rw(e){return Number.parseInt(e[0],16)>=8?"00"+e:e}function nw(e){if(e.length<2||2!==e[0])throw Error("Invalid signature integer tag: "+lw(e));const t=e[1],r=e.subarray(2,t+2);if(!t||r.length!==t)throw Error("Invalid signature integer: wrong length");if(0===r[0]&&r[1]<=127)throw Error("Invalid signature integer: trailing length");return{data:bw(r),left:e.subarray(t+2)}}tw.BASE=new tw(Kb.Gx,Kb.Gy),tw.ZERO=new tw(Ub,Ub);class sw{constructor(e,t){this.r=e,this.s=t,this.assertValidity()}static fromCompact(e){const t=ow(e),r="Signature.fromCompact";if("string"!=typeof e&&!t)throw new TypeError(r+": Expected string or Uint8Array");const n=t?lw(e):e;if(128!==n.length)throw Error(r+": Expected 64-byte hex");return new sw(yw(n.slice(0,64)),yw(n.slice(64,128)))}static fromDER(e){const t=ow(e);if("string"!=typeof e&&!t)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r,s:n}=function(e){if(e.length<2||48!=e[0])throw Error("Invalid signature tag: "+lw(e));if(e[1]!==e.length-2)throw Error("Invalid signature: incorrect length");const{data:t,left:r}=nw(e.subarray(2)),{data:n,left:s}=nw(r);if(s.length)throw Error("Invalid signature: left bytes after parsing: "+lw(s));return{r:t,s:n}}(t?e:dw(e));return new sw(r,n)}static fromHex(e){return this.fromDER(e)}assertValidity(){const{r:e,s:t}=this;if(!Pw(e))throw Error("Invalid Signature: r must be 0 < r < n");if(!Pw(t))throw Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const e=Kb.n>>Bb;return this.s>e}normalizeS(){return this.hasHighS()?new sw(this.r,Ew(-this.s,Kb.n)):this}toDERRawBytes(){return dw(this.toDERHex())}toDERHex(){const e=rw(mw(this.s)),t=rw(mw(this.r)),r=e.length/2,n=t.length/2,s=mw(r),o=mw(n);return`30${mw(n+r+4)}02${o}${t}02${s}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return dw(this.toCompactHex())}toCompactHex(){return fw(this.r)+fw(this.s)}}function ow(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function iw(e){if(!ow(e))throw Error("Uint8Array expected")}function aw(...e){if(e.every(iw),1===e.length)return e[0];const t=e.reduce(((e,t)=>e+t.length),0),r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const s=e[t];r.set(s,n),n+=s.length}return r}const cw=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function lw(e){iw(e);let t="";for(let r=0;r<e.length;r++)t+=cw[e[r]];return t}const uw={_0:48,_9:57,A:65,F:70,a:97,f:102};function hw(e){return e>=uw._0&&e<=uw._9?e-uw._0:e>=uw.A&&e<=uw.F?e-(uw.A-10):e>=uw.a&&e<=uw.f?e-(uw.a-10):void 0}function dw(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);const t=e.length,r=t/2;if(t%2)throw Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let t=0,s=0;t<r;t++,s+=2){const r=hw(e.charCodeAt(s)),o=hw(e.charCodeAt(s+1));if(void 0===r||void 0===o){const t=e[s]+e[s+1];throw Error('hex string expected, got non-hex character "'+t+'" at index '+s)}n[t]=16*r+o}return n}const pw=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function fw(e){if("bigint"!=typeof e)throw Error("Expected bigint");if(!(Ub<=e&&e<pw))throw Error("Expected number 0 <= n < 2^256");return e.toString(16).padStart(64,"0")}function gw(e){const t=dw(fw(e));if(32!==t.length)throw Error("Error: expected 32 bytes");return t}function mw(e){const t=e.toString(16);return 1&t.length?"0"+t:t}function yw(e){if("string"!=typeof e)throw new TypeError("hexToNumber: expected string, got "+typeof e);return BigInt("0x"+e)}function bw(e){return yw(lw(e))}function ww(e){return ow(e)?Uint8Array.from(e):dw(e)}function vw(e){if("number"==typeof e&&Number.isSafeInteger(e)&&e>0)return BigInt(e);if("bigint"==typeof e&&Pw(e))return e;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function Ew(e,t=Kb.P){const r=e%t;return r>=Ub?r:t+r}function Sw(e,t){const{P:r}=Kb;let n=e;for(;t-- >Ub;)n*=n,n%=r;return n}function Aw(e,t=Kb.P){if(e===Ub||t<=Ub)throw Error(`invert: expected positive integers, got n=${e} mod=${t}`);let r=Ew(e,t),n=t,s=Ub,o=Bb;for(;r!==Ub;){const e=n%r,t=s-o*(n/r);n=r,r=e,s=o,o=t}if(n!==Bb)throw Error("invert: does not exist");return Ew(s,t)}function Cw(e,t=!1){const r=function(e){const t=8*e.length-256,r=bw(e);return t>0?r>>BigInt(t):r}(e);if(t)return r;const{n}=Kb;return r>=n?r-n:r}let Iw,xw;class kw{constructor(e,t){if(this.hashLen=e,this.qByteLen=t,"number"!=typeof e||e<2)throw Error("hashLen must be a number");if("number"!=typeof t||t<2)throw Error("qByteLen must be a number");this.v=new Uint8Array(e).fill(1),this.k=new Uint8Array(e).fill(0),this.counter=0}hmac(...e){return $w.hmacSha256(this.k,...e)}hmacSync(...e){return xw(this.k,...e)}checkSync(){if("function"!=typeof xw)throw new Zb("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(e=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),e),this.v=await this.hmac(this.v),0!==e.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),e),this.v=await this.hmac(this.v))}reseedSync(e=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),e),this.v=this.hmacSync(this.v),0!==e.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),e),this.v=this.hmacSync(this.v))}async generate(){this.incr();let e=0;const t=[];for(;e<this.qByteLen;){this.v=await this.hmac(this.v);const r=this.v.slice();t.push(r),e+=this.v.length}return aw(...t)}generateSync(){this.checkSync(),this.incr();let e=0;const t=[];for(;e<this.qByteLen;){this.v=this.hmacSync(this.v);const r=this.v.slice();t.push(r),e+=this.v.length}return aw(...t)}}function Pw(e){return Ub<e&&e<Kb.n}function Tw(e){return Ub<e&&e<Kb.P}function _w(e,t,r,n=!0){const{n:s}=Kb,o=Cw(e,!0);if(!Pw(o))return;const i=Aw(o,s),a=tw.BASE.multiply(o),c=Ew(a.x,s);if(c===Ub)return;const l=Ew(i*Ew(t+r*c,s),s);if(l===Ub)return;let u=new sw(c,l),h=(a.x===u.r?0:2)|Number(a.y&Bb);return n&&u.hasHighS()&&(u=u.normalizeS(),h^=1),{sig:u,recovery:h}}function Rw(e){let t;if("bigint"==typeof e)t=e;else if("number"==typeof e&&Number.isSafeInteger(e)&&e>0)t=BigInt(e);else if("string"==typeof e){if(64!==e.length)throw Error("Expected 32 bytes of private key");t=yw(e)}else{if(!ow(e))throw new TypeError("Expected valid private key");if(e.length!==Gb)throw Error("Expected 32 bytes of private key");t=bw(e)}if(!Pw(t))throw Error("Expected private key: 0 < key < n");return t}function Lw(e){if(e instanceof sw)return e.assertValidity(),e;try{return sw.fromDER(e)}catch(t){return sw.fromCompact(e)}}function Dw(e){return bw(e.length>jb?e.slice(0,jb):e)}function Nw(e){const t=Dw(e),r=Ew(t,Kb.n);return Mw(r<Ub?t:r)}function Mw(e){return gw(e)}async function Ow(e,t,r={}){const{seed:n,m:s,d:o}=function(e,t,r){if(null==e)throw Error(`sign: expected valid message hash, not "${e}"`);const n=ww(e),s=Rw(t),o=[Mw(s),Nw(n)];if(null!=r){!0===r&&(r=$w.randomBytes(jb));const e=ww(r);if(e.length!==jb)throw Error("sign: Expected 32 bytes of extra data");o.push(e)}return{seed:aw(...o),m:Dw(n),d:s}}(e,t,r.extraEntropy),i=new kw(32,Gb);let a;for(await i.reseed(n);!(a=_w(await i.generate(),s,o,r.canonical));)await i.reseed();return function(e,t){const{sig:r,recovery:n}=e,{der:s,recovered:o}=Object.assign({canonical:!0,der:!0},t),i=s?r.toDERRawBytes():r.toCompactRawBytes();return o?[i,n]:i}(a,r)}const Fw={strict:!0};function Uw(e,t,r,n=Fw){let s;try{s=Lw(e),t=ww(t)}catch(e){return!1}const{r:o,s:i}=s;if(n.strict&&s.hasHighS())return!1;const a=Cw(t);let c;try{c=function(e){return e instanceof tw?(e.assertValidity(),e):tw.fromHex(e)}(r)}catch(e){return!1}const{n:l}=Kb,u=Aw(i,l),h=Ew(a*u,l),d=Ew(o*u,l),p=tw.BASE.multiplyAndAddUnsafe(c,h,d);if(!p)return!1;return Ew(p.x,l)===o}tw.BASE._setWindowSize(8);const Bw={node:Fb,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},qw={},$w={bytesToHex:lw,hexToBytes:dw,concatBytes:aw,mod:Ew,invert:Aw,isValidPrivateKey(e){try{return Rw(e),!0}catch(e){return!1}},_bigintTo32Bytes:gw,_normalizePrivateKey:Rw,hashToPrivateKey(e){if((e=ww(e)).length<40||e.length>1024)throw Error("Expected valid bytes of private key as per FIPS 186");return gw(Ew(bw(e),Kb.n-Bb)+Bb)},randomBytes(e=32){if(Bw.web)return Bw.web.getRandomValues(new Uint8Array(e));if(Bw.node){const{randomBytes:t}=Bw.node;return Uint8Array.from(t(e))}throw Error("The environment doesn't have randomBytes function")},randomPrivateKey(){return $w.hashToPrivateKey($w.randomBytes(40))},precompute(e=8,t=tw.BASE){const r=t===tw.BASE?t:new tw(t.x,t.y);return r._setWindowSize(e),r.multiply($b),r},async sha256(...e){if(Bw.web){const t=await Bw.web.subtle.digest("SHA-256",aw(...e));return new Uint8Array(t)}if(Bw.node){const{createHash:t}=Bw.node,r=t("sha256");return e.forEach((e=>r.update(e))),Uint8Array.from(r.digest())}throw Error("The environment doesn't have sha256 function")},async hmacSha256(e,...t){if(Bw.web){const r=await Bw.web.subtle.importKey("raw",e,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),n=aw(...t),s=await Bw.web.subtle.sign("HMAC",r,n);return new Uint8Array(s)}if(Bw.node){const{createHmac:r}=Bw.node,n=r("sha256",e);return t.forEach((e=>n.update(e))),Uint8Array.from(n.digest())}throw Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,async taggedHash(e,...t){let r=qw[e];if(void 0===r){const t=await $w.sha256(Uint8Array.from(e,(e=>e.charCodeAt(0))));r=aw(t,t),qw[e]=r}return $w.sha256(r,...t)},taggedHashSync(e,...t){if("function"!=typeof Iw)throw new Zb("sha256Sync is undefined, you need to set it");let r=qw[e];if(void 0===r){const t=Iw(Uint8Array.from(e,(e=>e.charCodeAt(0))));r=aw(t,t),qw[e]=r}return Iw(r,...t)},_JacobianPoint:Qb};Object.defineProperties($w,{sha256Sync:{configurable:!1,get:()=>Iw,set(e){Iw||(Iw=e)}},hmacSha256Sync:{configurable:!1,get:()=>xw,set(e){xw||(xw=e)}}});var zw,Kw={exports:{}};var Vw,Hw=(zw||(zw=1,Vw=Kw,function(){var e="input is invalid type",t="object"==typeof window,r=t?window:{};r.JS_SHA3_NO_WINDOW&&(t=!1);var n=!t&&"object"==typeof self;!r.JS_SHA3_NO_NODE_JS&&"object"==typeof process&&process.versions&&process.versions.node?r=Rn:n&&(r=self);for(var s=!r.JS_SHA3_NO_COMMON_JS&&Vw.exports,o=!r.JS_SHA3_NO_ARRAY_BUFFER&&"undefined"!=typeof ArrayBuffer,i="0123456789abcdef".split(""),a=[4,1024,262144,67108864],c=[0,8,16,24],l=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648],u=[224,256,384,512],h=[128,256],d=["hex","buffer","arrayBuffer","array","digest"],p={128:168,256:136},f=r.JS_SHA3_NO_NODE_JS||!Array.isArray?e=>"[object Array]"==={}.toString.call(e):Array.isArray,g=!o||!r.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW&&ArrayBuffer.isView?ArrayBuffer.isView:e=>"object"==typeof e&&e.buffer&&e.buffer.constructor===ArrayBuffer,m=t=>{var r=typeof t;if("string"===r)return[t,!0];if("object"!==r||null===t)throw Error(e);if(o&&t.constructor===ArrayBuffer)return[new Uint8Array(t),!1];if(!f(t)&&!g(t))throw Error(e);return[t,!1]},y=e=>0===m(e)[0].length,b=e=>{for(var t=[],r=0;r<e.length;++r)t[r]=e[r];return t},w=(e,t,r)=>n=>new N(e,t,e).update(n)[r](),v=(e,t,r)=>(n,s)=>new N(e,t,s).update(n)[r](),E=(e,t,r)=>(t,n,s,o)=>x["cshake"+e].update(t,n,s,o)[r](),S=(e,t,r)=>(t,n,s,o)=>x["kmac"+e].update(t,n,s,o)[r](),A=(e,t,r,n)=>{for(var s=0;s<d.length;++s){var o=d[s];e[o]=t(r,n,o)}return e},C=(e,t)=>{var r=w(e,t,"hex");return r.create=()=>new N(e,t,e),r.update=e=>r.create().update(e),A(r,w,e,t)},I=[{name:"keccak",padding:[1,256,65536,16777216],bits:u,createMethod:C},{name:"sha3",padding:[6,1536,393216,100663296],bits:u,createMethod:C},{name:"shake",padding:[31,7936,2031616,520093696],bits:h,createMethod(e,t){var r=v(e,t,"hex");return r.create=r=>new N(e,t,r),r.update=(e,t)=>r.create(t).update(e),A(r,v,e,t)}},{name:"cshake",padding:a,bits:h,createMethod(e,t){var r=p[e],n=E(e,0,"hex");return n.create=(n,s,o)=>y(s)&&y(o)?x["shake"+e].create(n):new N(e,t,n).bytepad([s,o],r),n.update=(e,t,r,s)=>n.create(t,r,s).update(e),A(n,E,e,t)}},{name:"kmac",padding:a,bits:h,createMethod(e,t){var r=p[e],n=S(e,0,"hex");return n.create=(n,s,o)=>new M(e,t,s).bytepad(["KMAC",o],r).bytepad([n],r),n.update=(e,t,r,s)=>n.create(e,r,s).update(t),A(n,S,e,t)}}],x={},k=[],P=0;P<I.length;++P)for(var T=I[P],_=T.bits,R=0;R<_.length;++R){var L=T.name+"_"+_[R];if(k.push(L),x[L]=T.createMethod(_[R],T.padding),"sha3"!==T.name){var D=T.name+_[R];k.push(D),x[D]=x[L]}}function N(e,t,r){this.blocks=[],this.s=[],this.padding=t,this.outputBits=r,this.reset=!0,this.finalized=!1,this.block=0,this.start=0,this.blockCount=1600-(e<<1)>>5,this.byteCount=this.blockCount<<2,this.outputBlocks=r>>5,this.extraBytes=(31&r)>>3;for(var n=0;n<50;++n)this.s[n]=0}function M(e,t,r){N.call(this,e,t,r)}N.prototype.update=function(e){if(this.finalized)throw Error("finalize already called");var t=m(e);e=t[0];for(var r,n,s=t[1],o=this.blocks,i=this.byteCount,a=e.length,l=this.blockCount,u=0,h=this.s;u<a;){if(this.reset)for(this.reset=!1,o[0]=this.block,r=1;r<l+1;++r)o[r]=0;if(s)for(r=this.start;u<a&&r<i;++u)(n=e.charCodeAt(u))<128?o[r>>2]|=n<<c[3&r++]:n<2048?(o[r>>2]|=(192|n>>6)<<c[3&r++],o[r>>2]|=(128|63&n)<<c[3&r++]):n<55296||n>=57344?(o[r>>2]|=(224|n>>12)<<c[3&r++],o[r>>2]|=(128|n>>6&63)<<c[3&r++],o[r>>2]|=(128|63&n)<<c[3&r++]):(n=65536+((1023&n)<<10|1023&e.charCodeAt(++u)),o[r>>2]|=(240|n>>18)<<c[3&r++],o[r>>2]|=(128|n>>12&63)<<c[3&r++],o[r>>2]|=(128|n>>6&63)<<c[3&r++],o[r>>2]|=(128|63&n)<<c[3&r++]);else for(r=this.start;u<a&&r<i;++u)o[r>>2]|=e[u]<<c[3&r++];if(this.lastByteIndex=r,r>=i){for(this.start=r-i,this.block=o[l],r=0;r<l;++r)h[r]^=o[r];O(h),this.reset=!0}else this.start=r}return this},N.prototype.encode=function(e,t){var r=255&e,n=1,s=[r];for(r=255&(e>>=8);r>0;)s.unshift(r),r=255&(e>>=8),++n;return t?s.push(n):s.unshift(n),this.update(s),s.length},N.prototype.encodeString=function(e){var t=m(e);e=t[0];var r=t[1],n=0,s=e.length;if(r)for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);i<128?n+=1:i<2048?n+=2:i<55296||i>=57344?n+=3:(i=65536+((1023&i)<<10|1023&e.charCodeAt(++o)),n+=4)}else n=s;return n+=this.encode(8*n),this.update(e),n},N.prototype.bytepad=function(e,t){for(var r=this.encode(t),n=0;n<e.length;++n)r+=this.encodeString(e[n]);var s=(t-r%t)%t,o=[];return o.length=s,this.update(o),this},N.prototype.finalize=function(){if(!this.finalized){this.finalized=!0;var e=this.blocks,t=this.lastByteIndex,r=this.blockCount,n=this.s;if(e[t>>2]|=this.padding[3&t],this.lastByteIndex===this.byteCount)for(e[0]=e[r],t=1;t<r+1;++t)e[t]=0;for(e[r-1]|=2147483648,t=0;t<r;++t)n[t]^=e[t];O(n)}},N.prototype.toString=N.prototype.hex=function(){this.finalize();for(var e,t=this.blockCount,r=this.s,n=this.outputBlocks,s=this.extraBytes,o=0,a=0,c="";a<n;){for(o=0;o<t&&a<n;++o,++a)e=r[o],c+=i[e>>4&15]+i[15&e]+i[e>>12&15]+i[e>>8&15]+i[e>>20&15]+i[e>>16&15]+i[e>>28&15]+i[e>>24&15];a%t==0&&(r=b(r),O(r),o=0)}return s&&(e=r[o],c+=i[e>>4&15]+i[15&e],s>1&&(c+=i[e>>12&15]+i[e>>8&15]),s>2&&(c+=i[e>>20&15]+i[e>>16&15])),c},N.prototype.arrayBuffer=function(){this.finalize();var e,t=this.blockCount,r=this.s,n=this.outputBlocks,s=this.extraBytes,o=0,i=0,a=this.outputBits>>3;e=s?new ArrayBuffer(n+1<<2):new ArrayBuffer(a);for(var c=new Uint32Array(e);i<n;){for(o=0;o<t&&i<n;++o,++i)c[i]=r[o];i%t==0&&(r=b(r),O(r))}return s&&(c[i]=r[o],e=e.slice(0,a)),e},N.prototype.buffer=N.prototype.arrayBuffer,N.prototype.digest=N.prototype.array=function(){this.finalize();for(var e,t,r=this.blockCount,n=this.s,s=this.outputBlocks,o=this.extraBytes,i=0,a=0,c=[];a<s;){for(i=0;i<r&&a<s;++i,++a)e=a<<2,t=n[i],c[e]=255&t,c[e+1]=t>>8&255,c[e+2]=t>>16&255,c[e+3]=t>>24&255;a%r==0&&(n=b(n),O(n))}return o&&(e=a<<2,t=n[i],c[e]=255&t,o>1&&(c[e+1]=t>>8&255),o>2&&(c[e+2]=t>>16&255)),c},M.prototype=new N,M.prototype.finalize=function(){return this.encode(this.outputBits,!0),N.prototype.finalize.call(this)};var O=e=>{var t,r,n,s,o,i,a,c,u,h,d,p,f,g,m,y,b,w,v,E,S,A,C,I,x,k,P,T,_,R,L,D,N,M,O,F,U,B,q,$,z,K,V,H,j,G,W,X,Z,Y,Q,J,ee,te,re,ne,se,oe,ie,ae,ce,le,ue;for(n=0;n<48;n+=2)s=e[0]^e[10]^e[20]^e[30]^e[40],o=e[1]^e[11]^e[21]^e[31]^e[41],i=e[2]^e[12]^e[22]^e[32]^e[42],a=e[3]^e[13]^e[23]^e[33]^e[43],c=e[4]^e[14]^e[24]^e[34]^e[44],u=e[5]^e[15]^e[25]^e[35]^e[45],h=e[6]^e[16]^e[26]^e[36]^e[46],d=e[7]^e[17]^e[27]^e[37]^e[47],t=(p=e[8]^e[18]^e[28]^e[38]^e[48])^(i<<1|a>>>31),r=(f=e[9]^e[19]^e[29]^e[39]^e[49])^(a<<1|i>>>31),e[0]^=t,e[1]^=r,e[10]^=t,e[11]^=r,e[20]^=t,e[21]^=r,e[30]^=t,e[31]^=r,e[40]^=t,e[41]^=r,t=s^(c<<1|u>>>31),r=o^(u<<1|c>>>31),e[2]^=t,e[3]^=r,e[12]^=t,e[13]^=r,e[22]^=t,e[23]^=r,e[32]^=t,e[33]^=r,e[42]^=t,e[43]^=r,t=i^(h<<1|d>>>31),r=a^(d<<1|h>>>31),e[4]^=t,e[5]^=r,e[14]^=t,e[15]^=r,e[24]^=t,e[25]^=r,e[34]^=t,e[35]^=r,e[44]^=t,e[45]^=r,t=c^(p<<1|f>>>31),r=u^(f<<1|p>>>31),e[6]^=t,e[7]^=r,e[16]^=t,e[17]^=r,e[26]^=t,e[27]^=r,e[36]^=t,e[37]^=r,e[46]^=t,e[47]^=r,t=h^(s<<1|o>>>31),r=d^(o<<1|s>>>31),e[8]^=t,e[9]^=r,e[18]^=t,e[19]^=r,e[28]^=t,e[29]^=r,e[38]^=t,e[39]^=r,e[48]^=t,e[49]^=r,g=e[0],m=e[1],G=e[11]<<4|e[10]>>>28,W=e[10]<<4|e[11]>>>28,T=e[20]<<3|e[21]>>>29,_=e[21]<<3|e[20]>>>29,ae=e[31]<<9|e[30]>>>23,ce=e[30]<<9|e[31]>>>23,K=e[40]<<18|e[41]>>>14,V=e[41]<<18|e[40]>>>14,M=e[2]<<1|e[3]>>>31,O=e[3]<<1|e[2]>>>31,y=e[13]<<12|e[12]>>>20,b=e[12]<<12|e[13]>>>20,X=e[22]<<10|e[23]>>>22,Z=e[23]<<10|e[22]>>>22,R=e[33]<<13|e[32]>>>19,L=e[32]<<13|e[33]>>>19,le=e[42]<<2|e[43]>>>30,ue=e[43]<<2|e[42]>>>30,te=e[5]<<30|e[4]>>>2,re=e[4]<<30|e[5]>>>2,F=e[14]<<6|e[15]>>>26,U=e[15]<<6|e[14]>>>26,w=e[25]<<11|e[24]>>>21,v=e[24]<<11|e[25]>>>21,Y=e[34]<<15|e[35]>>>17,Q=e[35]<<15|e[34]>>>17,D=e[45]<<29|e[44]>>>3,N=e[44]<<29|e[45]>>>3,I=e[6]<<28|e[7]>>>4,x=e[7]<<28|e[6]>>>4,ne=e[17]<<23|e[16]>>>9,se=e[16]<<23|e[17]>>>9,B=e[26]<<25|e[27]>>>7,q=e[27]<<25|e[26]>>>7,E=e[36]<<21|e[37]>>>11,S=e[37]<<21|e[36]>>>11,J=e[47]<<24|e[46]>>>8,ee=e[46]<<24|e[47]>>>8,H=e[8]<<27|e[9]>>>5,j=e[9]<<27|e[8]>>>5,k=e[18]<<20|e[19]>>>12,P=e[19]<<20|e[18]>>>12,oe=e[29]<<7|e[28]>>>25,ie=e[28]<<7|e[29]>>>25,$=e[38]<<8|e[39]>>>24,z=e[39]<<8|e[38]>>>24,A=e[48]<<14|e[49]>>>18,C=e[49]<<14|e[48]>>>18,e[0]=g^~y&w,e[1]=m^~b&v,e[10]=I^~k&T,e[11]=x^~P&_,e[20]=M^~F&B,e[21]=O^~U&q,e[30]=H^~G&X,e[31]=j^~W&Z,e[40]=te^~ne&oe,e[41]=re^~se&ie,e[2]=y^~w&E,e[3]=b^~v&S,e[12]=k^~T&R,e[13]=P^~_&L,e[22]=F^~B&$,e[23]=U^~q&z,e[32]=G^~X&Y,e[33]=W^~Z&Q,e[42]=ne^~oe&ae,e[43]=se^~ie&ce,e[4]=w^~E&A,e[5]=v^~S&C,e[14]=T^~R&D,e[15]=_^~L&N,e[24]=B^~$&K,e[25]=q^~z&V,e[34]=X^~Y&J,e[35]=Z^~Q&ee,e[44]=oe^~ae&le,e[45]=ie^~ce&ue,e[6]=E^~A&g,e[7]=S^~C&m,e[16]=R^~D&I,e[17]=L^~N&x,e[26]=$^~K&M,e[27]=z^~V&O,e[36]=Y^~J&H,e[37]=Q^~ee&j,e[46]=ae^~le&te,e[47]=ce^~ue&re,e[8]=A^~g&y,e[9]=C^~m&b,e[18]=D^~I&k,e[19]=N^~x&P,e[28]=K^~M&F,e[29]=V^~O&U,e[38]=J^~H&G,e[39]=ee^~j&W,e[48]=le^~te&ne,e[49]=ue^~re&se,e[0]^=l[n],e[1]^=l[n+1]};if(s)Vw.exports=x;else for(P=0;P<k.length;++P)r[k[P]]=x[k[P]]}()),Kw.exports),jw=Ln(Hw);function Gw(e){return new Uint8Array(jw.keccak256.arrayBuffer(e))}function Ww(e,t,r){try{return Uw(sw.fromCompact(e.slice(0,64)),t,r)}catch{return!1}}function Xw(e,t){switch(t){case"udp":return Xw(e,"udp4")||Xw(e,"udp6");case"tcp":return Xw(e,"tcp4")||Xw(e,"tcp6")}const r=t.endsWith("6"),n=e.get(r?"ip6":"ip");if(!n)return;const s=t.slice(0,3);let o;switch(s){case"udp":o=r?e.get("udp6"):e.get("udp");break;case"tcp":o=r?e.get("tcp6"):e.get("tcp");break;default:return}return o?function(e,t,r,n){let s=Ri("/"+e+"/"+ki(e,r));return s=s.encapsulate(Ri("/"+t+"/"+ki(t,n))),s}(r?"ip6":"ip4",s,n,o):void 0}function Zw(e){const t=function(e){if(32===e.byteLength)return Sl(e);if(33===e.byteLength)return nu(e);const t=wa(e),r=t[1]?.[0];if("1.2.840.10045.3.1.7"===r||"1.3.132.0.34"===r||"1.3.132.0.35"===r)return Da(t);if("1.2.840.113549.1.1.1"===t[0]?.[0])return Rl(t,e);throw new yo("Could not extract public key from raw bytes")}(e);if("secp256k1"!==t.type)throw Error("Keypair type not implemented");return fu(t)}function Yw(e){const t=e.reduce(((e,t)=>e+2+t.bytes.length),0),r=new Uint8Array(t),n=new DataView(r.buffer);let s=0;return e.forEach((e=>{if(e.getPeerId())throw Error("`multiaddr` field MUST not contain peer id");n.setUint16(s,e.bytes.length),s+=2,r.set(e.bytes,s),s+=e.bytes.length})),r}function Qw(e){let t=0;return e.lightPush&&(t+=1),t<<=1,e.filter&&(t+=1),t<<=1,e.store&&(t+=1),t<<=1,e.relay&&(t+=1),t}class Jw extends Map{seq;signature;constructor(e={},t=BigInt(1),r){super(Object.entries(e)),this.seq=t,this.signature=r}set(e,t){return this.signature=void 0,this.seq++,super.set(e,t)}get id(){const e=this.get("id");if(!e)throw Error("id not found.");return wn(e)}get publicKey(){if("v4"===this.id)return this.get("secp256k1");throw Error(Ob)}get rs(){const e=this.get("rs");if(e)return Tn(e)}get rsv(){const e=this.get("rsv");if(e)return Tn(e)}get ip(){return ev(this,"ip","ip4")}set ip(e){rv(this,"ip","ip4",e)}get tcp(){return tv(this,"tcp","tcp")}set tcp(e){nv(this,"tcp","tcp",e)}get udp(){return tv(this,"udp","udp")}set udp(e){nv(this,"udp","udp",e)}get ip6(){return ev(this,"ip6","ip6")}set ip6(e){rv(this,"ip6","ip6",e)}get tcp6(){return tv(this,"tcp6","tcp")}set tcp6(e){nv(this,"tcp6","tcp",e)}get udp6(){return tv(this,"udp6","udp")}set udp6(e){nv(this,"udp6","udp",e)}get multiaddrs(){const e=this.get("multiaddrs");if(e)return function(e){const t=[];let r=0;for(;r<e.length;){const n=new DataView(e.buffer,r,2).getUint16(0);r+=2;const s=e.slice(r,r+n);r+=n,t.push(Ri(s))}return t}(e)}set multiaddrs(e){sv(this,"multiaddrs",e,Yw)}get waku2(){const e=this.get("waku2");if(e)return function(e){const t={relay:!1,store:!1,filter:!1,lightPush:!1};return e%2&&(t.relay=!0),(e>>=1)%2&&(t.store=!0),(e>>=1)%2&&(t.filter=!0),(e>>=1)%2&&(t.lightPush=!0),t}(e[0])}set waku2(e){sv(this,"waku2",e,(e=>new Uint8Array([Qw(e)])))}}function ev(e,t,r){const n=e.get(t);if(n)return ki(r,n)}function tv(e,t,r){const n=e.get(t);if(n)return Number(ki(r,n))}function rv(e,t,r,n){sv(e,t,n,Pi.bind({},r))}function nv(e,t,r,n){rv(e,t,r,n?.toString(10))}function sv(e,t,r,n){void 0!==r?e.set(t,n(r)):e.delete(t)}const ov=new Kn("enr");var iv,av;(e=>{e.TCP="tcp",e.UDP="udp"})(iv||(iv={})),(e=>{e.TCP4="tcp4",e.UDP4="udp4",e.TCP6="tcp6",e.UDP6="udp6"})(av||(av={}));class cv extends Jw{static RECORD_PREFIX="enr:";peerId;static create(e={},t=BigInt(1),r){const n=new cv(e,t,r);try{const e=n.publicKey;e&&(n.peerId=Zw(e))}catch(e){ov.error("Could not calculate peer id for ENR",e)}return n}get nodeId(){if("v4"===this.id)return this.publicKey?function(e){const t=tw.fromHex(e).toRawBytes(!1);return bn(Gw(t.slice(1)))}(this.publicKey):void 0;throw Error(Ob)}getLocationMultiaddr=Xw.bind({},this);get shardInfo(){return this.rs&&this.rsv&&ov.warn("ENR contains both `rs` and `rsv` fields."),this.rs||this.rsv}setLocationMultiaddr(e){const t=e.protoNames();if(2!==t.length&&"udp"!==t[1]&&"tcp"!==t[1])throw Error("Invalid multiaddr");const r=e.tuples();if(!r[0][1]||!r[1][1])throw Error("Invalid multiaddr");4===r[0][0]?(this.set("ip",r[0][1]),this.set(t[1],r[1][1])):(this.set("ip6",r[0][1]),this.set(t[1]+"6",r[1][1]))}getAllLocationMultiaddrs(){const e=[];for(const t of Object.values(av)){const r=this.getLocationMultiaddr(t);r&&e.push(r)}const t=this.multiaddrs??[];return e.concat(t).map((e=>this.peerId?e.encapsulate("/p2p/"+this.peerId.toString()):e))}get peerInfo(){const e=this.peerId;if(e)return{id:e,multiaddrs:this.getAllLocationMultiaddrs()}}getFullMultiaddr(e){if(this.peerId){const t=this.getLocationMultiaddr(e);if(t)return t.encapsulate("/p2p/"+this.peerId.toString())}}getFullMultiaddrs(){if(this.peerId&&this.multiaddrs){const e=this.peerId;return this.multiaddrs.map((t=>t.encapsulate("/p2p/"+e.toString())))}return[]}verify(e,t){if(!this.get("id")||"v4"!==this.id)throw Error(Ob);if(!this.publicKey)throw Error("Failed to verify ENR: No public key");return Ww(t,Gw(e),this.publicKey)}async sign(e,t){if("v4"!==this.id)throw Error(Ob);return this.signature=await async function(e,t){return Ow(Gw(t),e,{der:!1})}(t,e),this.signature}}let lv=!1,uv=!1;const hv={debug:1,default:2,info:2,warning:3,error:4,off:5};let dv=hv.default,pv=null;const fv=function(){try{const e=[];if(["NFD","NFC","NFKD","NFKC"].forEach((t=>{try{if("test"!=="test".normalize(t))throw Error("bad normalize")}catch(r){e.push(t)}})),e.length)throw Error("missing "+e.join(", "));0}catch(e){return e.message}return null}();var gv,mv;(e=>{e.DEBUG="DEBUG",e.INFO="INFO",e.WARNING="WARNING",e.ERROR="ERROR",e.OFF="OFF"})(gv||(gv={})),(e=>{e.UNKNOWN_ERROR="UNKNOWN_ERROR",e.NOT_IMPLEMENTED="NOT_IMPLEMENTED",e.UNSUPPORTED_OPERATION="UNSUPPORTED_OPERATION",e.NETWORK_ERROR="NETWORK_ERROR",e.SERVER_ERROR="SERVER_ERROR",e.TIMEOUT="TIMEOUT",e.BUFFER_OVERRUN="BUFFER_OVERRUN",e.NUMERIC_FAULT="NUMERIC_FAULT",e.MISSING_NEW="MISSING_NEW",e.INVALID_ARGUMENT="INVALID_ARGUMENT",e.MISSING_ARGUMENT="MISSING_ARGUMENT",e.UNEXPECTED_ARGUMENT="UNEXPECTED_ARGUMENT",e.CALL_EXCEPTION="CALL_EXCEPTION",e.INSUFFICIENT_FUNDS="INSUFFICIENT_FUNDS",e.NONCE_EXPIRED="NONCE_EXPIRED",e.REPLACEMENT_UNDERPRICED="REPLACEMENT_UNDERPRICED",e.UNPREDICTABLE_GAS_LIMIT="UNPREDICTABLE_GAS_LIMIT",e.TRANSACTION_REPLACED="TRANSACTION_REPLACED",e.ACTION_REJECTED="ACTION_REJECTED"})(mv||(mv={}));const yv="0123456789abcdef";class bv{constructor(e){Object.defineProperty(this,"version",{enumerable:!0,value:e,writable:!1})}_log(e,t){const r=e.toLowerCase();null==hv[r]&&this.throwArgumentError("invalid log level name","logLevel",e)}debug(...e){this._log(bv.levels.DEBUG,e)}info(...e){this._log(bv.levels.INFO,e)}warn(...e){this._log(bv.levels.WARNING,e)}makeError(e,t,r){if(uv)return this.makeError("censored error",t,{});t||(t=bv.errors.UNKNOWN_ERROR),r||(r={});const n=[];Object.keys(r).forEach((e=>{const t=r[e];try{if(t instanceof Uint8Array){let r="";for(let e=0;e<t.length;e++)r+=yv[t[e]>>4],r+=yv[15&t[e]];n.push(e+"=Uint8Array(0x"+r+")")}else n.push(e+"="+JSON.stringify(t))}catch(t){n.push(e+"="+JSON.stringify(r[e].toString()))}})),n.push("code="+t),n.push("version="+this.version);const s=e;let o="";switch(t){case mv.NUMERIC_FAULT:{o="NUMERIC_FAULT";const t=e;switch(t){case"overflow":case"underflow":case"division-by-zero":o+="-"+t;break;case"negative-power":case"negative-width":o+="-unsupported";break;case"unbound-bitwise-result":o+="-unbound-result"}break}case mv.CALL_EXCEPTION:case mv.INSUFFICIENT_FUNDS:case mv.MISSING_NEW:case mv.NONCE_EXPIRED:case mv.REPLACEMENT_UNDERPRICED:case mv.TRANSACTION_REPLACED:case mv.UNPREDICTABLE_GAS_LIMIT:o=t}o&&(e+=" [ See: https://links.ethers.org/v5-errors-"+o+" ]"),n.length&&(e+=" ("+n.join(", ")+")");const i=Error(e);return i.reason=s,i.code=t,Object.keys(r).forEach((e=>{i[e]=r[e]})),i}throwError(e,t,r){throw this.makeError(e,t,r)}throwArgumentError(e,t,r){return this.throwError(e,bv.errors.INVALID_ARGUMENT,{argument:t,value:r})}assert(e,t,r,n){e||this.throwError(t,r,n)}assertArgument(e,t,r,n){e||this.throwArgumentError(t,r,n)}checkNormalize(e){fv&&this.throwError("platform missing String.prototype.normalize",bv.errors.UNSUPPORTED_OPERATION,{operation:"String.prototype.normalize",form:fv})}checkSafeUint53(e,t){"number"==typeof e&&(null==t&&(t="value not safe"),(e<0||e>=9007199254740991)&&this.throwError(t,bv.errors.NUMERIC_FAULT,{operation:"checkSafeInteger",fault:"out-of-safe-range",value:e}),e%1&&this.throwError(t,bv.errors.NUMERIC_FAULT,{operation:"checkSafeInteger",fault:"non-integer",value:e}))}checkArgumentCount(e,t,r){r=r?": "+r:"",e<t&&this.throwError("missing argument"+r,bv.errors.MISSING_ARGUMENT,{count:e,expectedCount:t}),e>t&&this.throwError("too many arguments"+r,bv.errors.UNEXPECTED_ARGUMENT,{count:e,expectedCount:t})}checkNew(e,t){e!==Object&&null!=e||this.throwError("missing new",bv.errors.MISSING_NEW,{name:t.name})}checkAbstract(e,t){e===t?this.throwError("cannot instantiate abstract class "+JSON.stringify(t.name)+" directly; use a sub-class",bv.errors.UNSUPPORTED_OPERATION,{name:e.name,operation:"new"}):e!==Object&&null!=e||this.throwError("missing new",bv.errors.MISSING_NEW,{name:t.name})}static globalLogger(){return pv||(pv=new bv("logger/5.8.0")),pv}static setCensorship(e,t){if(!e&&t&&this.globalLogger().throwError("cannot permanently disable censorship",bv.errors.UNSUPPORTED_OPERATION,{operation:"setCensorship"}),lv){if(!e)return;this.globalLogger().throwError("error censorship permanent",bv.errors.UNSUPPORTED_OPERATION,{operation:"setCensorship"})}uv=!!e,lv=!!t}static setLogLevel(e){const t=hv[e.toLowerCase()];null!=t?dv=t:bv.globalLogger().warn("invalid log level - "+e)}static from(e){return new bv(e)}}bv.errors=mv,bv.levels=gv;const wv=new bv("bytes/5.8.0");function vv(e){return!!e.toHexString}function Ev(e){return e.slice||(e.slice=function(){const t=[].slice.call(arguments);return Ev(new Uint8Array([].slice.apply(e,t)))}),e}function Sv(e){return"number"==typeof e&&e==e&&e%1==0}function Av(e){if(null==e)return!1;if(e.constructor===Uint8Array)return!0;if("string"==typeof e)return!1;if(!Sv(e.length)||e.length<0)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(!Sv(r)||r<0||r>=256)return!1}return!0}function Cv(e,t){if(t||(t={}),"number"==typeof e){wv.checkSafeUint53(e,"invalid arrayify value");const t=[];for(;e;)t.unshift(255&e),e=parseInt(e/256+"");return 0===t.length&&t.push(0),Ev(new Uint8Array(t))}if(t.allowMissingPrefix&&"string"==typeof e&&"0x"!==e.substring(0,2)&&(e="0x"+e),vv(e)&&(e=e.toHexString()),Iv(e)){let r=e.substring(2);r.length%2&&("left"===t.hexPad?r="0"+r:"right"===t.hexPad?r+="0":wv.throwArgumentError("hex data is odd-length","value",e));const n=[];for(let e=0;e<r.length;e+=2)n.push(parseInt(r.substring(e,e+2),16));return Ev(new Uint8Array(n))}return Av(e)?Ev(new Uint8Array(e)):wv.throwArgumentError("invalid arrayify value","value",e)}function Iv(e){return!("string"!=typeof e||!e.match(/^0x[0-9A-Fa-f]*$/))}const xv="0123456789abcdef";function kv(e,t){if(t||(t={}),"number"==typeof e){wv.checkSafeUint53(e,"invalid hexlify value");let t="";for(;e;)t=xv[15&e]+t,e=Math.floor(e/16);return t.length?(t.length%2&&(t="0"+t),"0x"+t):"0x00"}if("bigint"==typeof e)return(e=e.toString(16)).length%2?"0x0"+e:"0x"+e;if(t.allowMissingPrefix&&"string"==typeof e&&"0x"!==e.substring(0,2)&&(e="0x"+e),vv(e))return e.toHexString();if(Iv(e))return e.length%2&&("left"===t.hexPad?e="0x0"+e.substring(2):"right"===t.hexPad?e+="0":wv.throwArgumentError("hex data is odd-length","value",e)),e.toLowerCase();if(Av(e)){let t="0x";for(let r=0;r<e.length;r++){let n=e[r];t+=xv[(240&n)>>4]+xv[15&n]}return t}return wv.throwArgumentError("invalid hexlify value","value",e)}const Pv=new bv("rlp/5.8.0");function Tv(e){const t=[];for(;e;)t.unshift(255&e),e>>=8;return t}function _v(e,t,r){let n=0;for(let s=0;s<r;s++)n=256*n+e[t+s];return n}function Rv(e){if(Array.isArray(e)){let t=[];if(e.forEach((e=>{t=t.concat(Rv(e))})),t.length<=55)return t.unshift(192+t.length),t;const r=Tv(t.length);return r.unshift(247+r.length),r.concat(t)}var t;Iv(t=e)&&!(t.length%2)||Av(t)||Pv.throwArgumentError("RLP object must be BytesLike","object",e);const r=[].slice.call(Cv(e));if(1===r.length&&r[0]<=127)return r;if(r.length<=55)return r.unshift(128+r.length),r;const n=Tv(r.length);return n.unshift(183+n.length),n.concat(r)}function Lv(e,t,r,n){const s=[];for(;r<t+1+n;){const o=Dv(e,r);s.push(o.result),(r+=o.consumed)>t+1+n&&Pv.throwError("child data too short",bv.errors.BUFFER_OVERRUN,{})}return{consumed:1+n,result:s}}function Dv(e,t){if(0===e.length&&Pv.throwError("data too short",bv.errors.BUFFER_OVERRUN,{}),e[t]>=248){const r=e[t]-247;t+1+r>e.length&&Pv.throwError("data short segment too short",bv.errors.BUFFER_OVERRUN,{});const n=_v(e,t+1,r);return t+1+r+n>e.length&&Pv.throwError("data long segment too short",bv.errors.BUFFER_OVERRUN,{}),Lv(e,t,t+1+r,r+n)}if(e[t]>=192){const r=e[t]-192;return t+1+r>e.length&&Pv.throwError("data array too short",bv.errors.BUFFER_OVERRUN,{}),Lv(e,t,t+1,r)}if(e[t]>=184){const r=e[t]-183;t+1+r>e.length&&Pv.throwError("data array too short",bv.errors.BUFFER_OVERRUN,{});const n=_v(e,t+1,r);t+1+r+n>e.length&&Pv.throwError("data array too short",bv.errors.BUFFER_OVERRUN,{});return{consumed:1+r+n,result:kv(e.slice(t+1+r,t+1+r+n))}}if(e[t]>=128){const r=e[t]-128;t+1+r>e.length&&Pv.throwError("data too short",bv.errors.BUFFER_OVERRUN,{});return{consumed:1+r,result:kv(e.slice(t+1,t+1+r))}}return{consumed:1,result:kv(e[t])}}const Nv=new Kn("enr:decoder");class Mv{static fromString(e){if(!e.startsWith(cv.RECORD_PREFIX))throw Error(`"string encoded ENR must start with '${cv.RECORD_PREFIX}'`);return Mv.fromRLP(tt(e.slice(4),"base64url"))}static fromRLP(e){const t=function(e){const t=Cv(e),r=Dv(t,0);return r.consumed!==t.length&&Pv.throwArgumentError("invalid rlp data","data",e),r.result}(e).map(yn);return async function(e){const{signature:t,seq:r,kvs:n}=function(e){if(!Array.isArray(e))throw Error("Decoded ENR must be an array");if(e.length%2!=0)throw Error("Decoded ENR must have an even number of elements");const[t,r,...n]=e;if(!t||Array.isArray(t))throw Error("Decoded ENR invalid signature: must be a byte array");if(!r||Array.isArray(r))throw Error("Decoded ENR invalid sequence number: must be a byte array");return{signature:t,seq:r,kvs:n}}(e),s={};for(let e=0;e<n.length;e+=2)try{s[wn(n[e])]=n[e+1]}catch(t){Nv.error("Failed to decode ENR key to UTF-8, skipping it",n[e],t)}const o=function(e){return e.length?BigInt("0x"+bn(e)):BigInt(0)}(r),i=cv.create(s,o,t);return function(e,t,r,n){const s=yn((o=[e,...t],kv(Rv(o))));var o;if(!r.verify(s,n))throw Error("Unable to verify ENR signature")}(r,n,i,t),i}(t)}}class Ov extends Map{#M=0;#O=new Map;#F=new Map;#U;#B;#q;constructor(e={}){if(super(),!(e.maxSize&&e.maxSize>0))throw new TypeError("`maxSize` must be a number greater than 0");if("number"==typeof e.maxAge&&0===e.maxAge)throw new TypeError("`maxAge` must be a number greater than 0");this.#U=e.maxSize,this.#B=e.maxAge||1/0,this.#q=e.onEviction}get __oldCache(){return this.#F}#$(e){if("function"==typeof this.#q)for(const[t,r]of e)this.#q(t,r.value)}#z(e,t){return"number"==typeof t.expiry&&t.expiry<=Date.now()&&("function"==typeof this.#q&&this.#q(e,t.value),this.delete(e))}#K(e,t){if(!1===this.#z(e,t))return t.value}#V(e,t){return t.expiry?this.#K(e,t):t.value}#H(e,t){const r=t.get(e);return this.#V(e,r)}#j(e,t){this.#O.set(e,t),this.#M++,this.#M>=this.#U&&(this.#M=0,this.#$(this.#F),this.#F=this.#O,this.#O=new Map)}#G(e,t){this.#F.delete(e),this.#j(e,t)}*#W(){for(const e of this.#F){const[t,r]=e;if(!this.#O.has(t)){!1===this.#z(t,r)&&(yield e)}}for(const e of this.#O){const[t,r]=e;!1===this.#z(t,r)&&(yield e)}}get(e){if(this.#O.has(e)){const t=this.#O.get(e);return this.#V(e,t)}if(this.#F.has(e)){const t=this.#F.get(e);if(!1===this.#z(e,t))return this.#G(e,t),t.value}}set(e,t,{maxAge:r=this.#B}={}){const n="number"==typeof r&&r!==1/0?Date.now()+r:void 0;return this.#O.has(e)?this.#O.set(e,{value:t,expiry:n}):this.#j(e,{value:t,expiry:n}),this}has(e){return this.#O.has(e)?!this.#z(e,this.#O.get(e)):!!this.#F.has(e)&&!this.#z(e,this.#F.get(e))}peek(e){return this.#O.has(e)?this.#H(e,this.#O):this.#F.has(e)?this.#H(e,this.#F):void 0}delete(e){const t=this.#O.delete(e);return t&&this.#M--,this.#F.delete(e)||t}clear(){this.#O.clear(),this.#F.clear(),this.#M=0}resize(e){if(!(e&&e>0))throw new TypeError("`maxSize` must be a number greater than 0");const t=[...this.#W()],r=t.length-e;r<0?(this.#O=new Map(t),this.#F=new Map,this.#M=t.length):(r>0&&this.#$(t.slice(0,r)),this.#F=new Map(t.slice(r)),this.#O=new Map,this.#M=0),this.#U=e}*keys(){for(const[e]of this)yield e}*values(){for(const[,e]of this)yield e}*[Symbol.iterator](){for(const e of this.#O){const[t,r]=e;!1===this.#z(t,r)&&(yield[t,r.value])}for(const e of this.#F){const[t,r]=e;if(!this.#O.has(t)){!1===this.#z(t,r)&&(yield[t,r.value])}}}*entriesDescending(){let e=[...this.#O];for(let t=e.length-1;t>=0;--t){const r=e[t],[n,s]=r;!1===this.#z(n,s)&&(yield[n,s.value])}e=[...this.#F];for(let t=e.length-1;t>=0;--t){const r=e[t],[n,s]=r;if(!this.#O.has(n)){!1===this.#z(n,s)&&(yield[n,s.value])}}}*entriesAscending(){for(const[e,t]of this.#W())yield[e,t.value]}get size(){if(!this.#M)return this.#F.size;let e=0;for(const t of this.#F.keys())this.#O.has(t)||e++;return Math.min(this.#M+e,this.#U)}get maxSize(){return this.#U}entries(){return this.entriesAscending()}forEach(e,t=this){for(const[r,n]of this.entriesAscending())e.call(t,n,r,this)}get[Symbol.toStringTag](){return"QuickLRU"}toString(){return`QuickLRU(${this.size}/${this.maxSize})`}[Symbol.for("nodejs.util.inspect.custom")](){return this.toString()}}function Fv(e,t,r){return`${e}?name=${t}&type=${r}`}async function Uv(e,t){const r=await fetch(e,{headers:new Headers({accept:"application/dns-json"}),signal:t});return await r.json()}function Bv(e,t){return`${t}_${e}`}const qv=Object.assign(pg("dns-over-http-resolver"),{error:pg("dns-over-http-resolver:error")});class $v{_cache;_TXTcache;_servers;_request;_abortControllers;constructor(e={}){this._cache=new Ov({maxSize:e?.maxCache??100}),this._TXTcache=new Ov({maxSize:e?.maxCache??100}),this._servers=["https://cloudflare-dns.com/dns-query","https://dns.google/resolve"],this._request=e.request??Uv,this._abortControllers=[]}cancel(){this._abortControllers.forEach((e=>{e.abort()}))}getServers(){return this._servers}_getShuffledServers(){const e=[...this._servers];for(let t=e.length-1;t>0;t--){const r=Math.floor(Math.random()*t),n=e[t];e[t]=e[r],e[r]=n}return e}setServers(e){this._servers=e}async resolve(e,t="A"){switch(t){case"A":return this.resolve4(e);case"AAAA":return this.resolve6(e);case"TXT":return this.resolveTxt(e);default:throw Error(t+" is not supported")}}async resolve4(e){const t="A",r=this._cache.get(Bv(e,t));if(null!=r)return r;let n=!1;for(const r of this._getShuffledServers()){const s=new AbortController;this._abortControllers.push(s);try{const n=await this._request(Fv(r,e,t),s.signal),o=n.Answer.map((e=>e.data)),i=Math.min(...n.Answer.map((e=>e.TTL)));return this._cache.set(Bv(e,t),o,{maxAge:i}),o}catch(o){s.signal.aborted&&(n=!0),qv.error(`${r} could not resolve ${e} record ${t}`)}finally{this._abortControllers=this._abortControllers.filter((e=>e!==s))}}if(n)throw Object.assign(Error("queryA ECANCELLED"),{code:"ECANCELLED"});throw Error(`Could not resolve ${e} record ${t}`)}async resolve6(e){const t="AAAA",r=this._cache.get(Bv(e,t));if(null!=r)return r;let n=!1;for(const r of this._getShuffledServers()){const s=new AbortController;this._abortControllers.push(s);try{const n=await this._request(Fv(r,e,t),s.signal),o=n.Answer.map((e=>e.data)),i=Math.min(...n.Answer.map((e=>e.TTL)));return this._cache.set(Bv(e,t),o,{maxAge:i}),o}catch(o){s.signal.aborted&&(n=!0),qv.error(`${r} could not resolve ${e} record ${t}`)}finally{this._abortControllers=this._abortControllers.filter((e=>e!==s))}}if(n)throw Object.assign(Error("queryAaaa ECANCELLED"),{code:"ECANCELLED"});throw Error(`Could not resolve ${e} record ${t}`)}async resolveTxt(e){const t="TXT",r=this._TXTcache.get(Bv(e,t));if(null!=r)return r;let n=!1;for(const r of this._getShuffledServers()){const s=new AbortController;this._abortControllers.push(s);try{const n=await this._request(Fv(r,e,t),s.signal),o=n.Answer.map((e=>[e.data.replace(/['"]+/g,"")])),i=Math.min(...n.Answer.map((e=>e.TTL)));return this._TXTcache.set(Bv(e,t),o,{maxAge:i}),o}catch(o){s.signal.aborted&&(n=!0),qv.error(`${r} could not resolve ${e} record ${t}`)}finally{this._abortControllers=this._abortControllers.filter((e=>e!==s))}}if(n)throw Object.assign(Error("queryTxt ECANCELLED"),{code:"ECANCELLED"});throw Error(`Could not resolve ${e} record ${t}`)}clearCache(){this._cache.clear(),this._TXTcache.clear()}}const zv=new Kn("dns-over-https");class Kv{resolver;static async create(){return new Kv}constructor(e=new $v){this.resolver=e}async resolveTXT(e){let t;try{t=await this.resolver.resolveTxt(e)}catch(e){throw zv.error("query failed: ",e),Error("DNS query failed")}if(!t)throw Error("Could not resolve "+e);const r=[];return t.forEach((e=>{"string"==typeof e?r.push(e):Array.isArray(e)?e.forEach((e=>{"string"==typeof e?r.push(e):r.push(wn(e))})):r.push(wn(e))})),r}}var Vv,Hv={exports:{}};var jv=(Vv||(Vv=1,(e=>{(()=>{var t="object"==typeof window?window:{};!t.HI_BASE32_NO_NODE_JS&&"object"==typeof process&&process.versions&&process.versions.node&&(t=Rn);var r=!t.HI_BASE32_NO_COMMON_JS&&e.exports,n="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split(""),s={A:0,B:1,C:2,D:3,E:4,F:5,G:6,H:7,I:8,J:9,K:10,L:11,M:12,N:13,O:14,P:15,Q:16,R:17,S:18,T:19,U:20,V:21,W:22,X:23,Y:24,Z:25,2:26,3:27,4:28,5:29,6:30,7:31},o=[0,0,0,0,0,0,0,0],i=(e,t)=>{t.length>10&&(t="..."+t.substr(-10));var r=Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading "+e+" bytes: "+t+" <-");throw r.position=e,r},a=e=>{if(""===e)return[];if(!/^[A-Z2-7=]+$/.test(e))throw Error("Invalid base32 characters");for(var t,r,n,o,i,a,c,l,u=[],h=0,d=(e=e.replace(/=/g,"")).length,p=0,f=d>>3<<3;p<f;)t=s[e.charAt(p++)],r=s[e.charAt(p++)],n=s[e.charAt(p++)],o=s[e.charAt(p++)],i=s[e.charAt(p++)],a=s[e.charAt(p++)],c=s[e.charAt(p++)],l=s[e.charAt(p++)],u[h++]=255&(t<<3|r>>>2),u[h++]=255&(r<<6|n<<1|o>>>4),u[h++]=255&(o<<4|i>>>1),u[h++]=255&(i<<7|a<<2|c>>>3),u[h++]=255&(c<<5|l);var g=d-f;return 2===g?(t=s[e.charAt(p++)],r=s[e.charAt(p++)],u[h++]=255&(t<<3|r>>>2)):4===g?(t=s[e.charAt(p++)],r=s[e.charAt(p++)],n=s[e.charAt(p++)],o=s[e.charAt(p++)],u[h++]=255&(t<<3|r>>>2),u[h++]=255&(r<<6|n<<1|o>>>4)):5===g?(t=s[e.charAt(p++)],r=s[e.charAt(p++)],n=s[e.charAt(p++)],o=s[e.charAt(p++)],i=s[e.charAt(p++)],u[h++]=255&(t<<3|r>>>2),u[h++]=255&(r<<6|n<<1|o>>>4),u[h++]=255&(o<<4|i>>>1)):7===g&&(t=s[e.charAt(p++)],r=s[e.charAt(p++)],n=s[e.charAt(p++)],o=s[e.charAt(p++)],i=s[e.charAt(p++)],a=s[e.charAt(p++)],c=s[e.charAt(p++)],u[h++]=255&(t<<3|r>>>2),u[h++]=255&(r<<6|n<<1|o>>>4),u[h++]=255&(o<<4|i>>>1),u[h++]=255&(i<<7|a<<2|c>>>3)),u},c=(e,t)=>{if(!t)return(e=>{for(var t,r,n="",s=e.length,o=0,a=0;o<s;)if((t=e[o++])<=127)n+=String.fromCharCode(t);else{t>191&&t<=223?(r=31&t,a=1):t<=239?(r=15&t,a=2):t<=247?(r=7&t,a=3):i(o,n);for(var c=0;c<a;++c)((t=e[o++])<128||t>191)&&i(o,n),r<<=6,r+=63&t;r>=55296&&r<=57343&&i(o,n),r>1114111&&i(o,n),r<=65535?n+=String.fromCharCode(r):(n+=String.fromCharCode(55296+((r-=65536)>>10)),n+=String.fromCharCode(56320+(1023&r)))}return n})(a(e));if(""===e)return"";if(!/^[A-Z2-7=]+$/.test(e))throw Error("Invalid base32 characters");var r,n,o,c,l,u,h,d,p="",f=e.indexOf("=");-1===f&&(f=e.length);for(var g=0,m=f>>3<<3;g<m;)r=s[e.charAt(g++)],n=s[e.charAt(g++)],o=s[e.charAt(g++)],c=s[e.charAt(g++)],l=s[e.charAt(g++)],u=s[e.charAt(g++)],h=s[e.charAt(g++)],d=s[e.charAt(g++)],p+=String.fromCharCode(255&(r<<3|n>>>2))+String.fromCharCode(255&(n<<6|o<<1|c>>>4))+String.fromCharCode(255&(c<<4|l>>>1))+String.fromCharCode(255&(l<<7|u<<2|h>>>3))+String.fromCharCode(255&(h<<5|d));var y=f-m;return 2===y?(r=s[e.charAt(g++)],n=s[e.charAt(g++)],p+=String.fromCharCode(255&(r<<3|n>>>2))):4===y?(r=s[e.charAt(g++)],n=s[e.charAt(g++)],o=s[e.charAt(g++)],c=s[e.charAt(g++)],p+=String.fromCharCode(255&(r<<3|n>>>2))+String.fromCharCode(255&(n<<6|o<<1|c>>>4))):5===y?(r=s[e.charAt(g++)],n=s[e.charAt(g++)],o=s[e.charAt(g++)],c=s[e.charAt(g++)],l=s[e.charAt(g++)],p+=String.fromCharCode(255&(r<<3|n>>>2))+String.fromCharCode(255&(n<<6|o<<1|c>>>4))+String.fromCharCode(255&(c<<4|l>>>1))):7===y&&(r=s[e.charAt(g++)],n=s[e.charAt(g++)],o=s[e.charAt(g++)],c=s[e.charAt(g++)],l=s[e.charAt(g++)],u=s[e.charAt(g++)],h=s[e.charAt(g++)],p+=String.fromCharCode(255&(r<<3|n>>>2))+String.fromCharCode(255&(n<<6|o<<1|c>>>4))+String.fromCharCode(255&(c<<4|l>>>1))+String.fromCharCode(255&(l<<7|u<<2|h>>>3))),p},l={encode(e,t){var r="string"!=typeof e;return r&&e.constructor===ArrayBuffer&&(e=new Uint8Array(e)),r?(e=>{for(var t,r,s,o,i,a="",c=e.length,l=0,u=5*parseInt(c/5);l<u;)t=e[l++],r=e[l++],s=e[l++],o=e[l++],i=e[l++],a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[31&(s<<1|o>>>7)]+n[o>>>2&31]+n[31&(o<<3|i>>>5)]+n[31&i];var h=c-u;return 1===h?(t=e[l],a+=n[t>>>3]+n[t<<2&31]+"======"):2===h?(t=e[l++],r=e[l],a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[r<<4&31]+"===="):3===h?(t=e[l++],r=e[l++],s=e[l],a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[s<<1&31]+"==="):4===h&&(t=e[l++],r=e[l++],s=e[l++],o=e[l],a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[31&(s<<1|o>>>7)]+n[o>>>2&31]+n[o<<3&31]+"="),a})(e):t?(e=>{for(var t,r,s,o,i,a="",c=e.length,l=0,u=5*parseInt(c/5);l<u;)t=e.charCodeAt(l++),r=e.charCodeAt(l++),s=e.charCodeAt(l++),o=e.charCodeAt(l++),i=e.charCodeAt(l++),a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[31&(s<<1|o>>>7)]+n[o>>>2&31]+n[31&(o<<3|i>>>5)]+n[31&i];var h=c-u;return 1===h?(t=e.charCodeAt(l),a+=n[t>>>3]+n[t<<2&31]+"======"):2===h?(t=e.charCodeAt(l++),r=e.charCodeAt(l),a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[r<<4&31]+"===="):3===h?(t=e.charCodeAt(l++),r=e.charCodeAt(l++),s=e.charCodeAt(l),a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[s<<1&31]+"==="):4===h&&(t=e.charCodeAt(l++),r=e.charCodeAt(l++),s=e.charCodeAt(l++),o=e.charCodeAt(l),a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[31&(s<<1|o>>>7)]+n[o>>>2&31]+n[o<<3&31]+"="),a})(e):(e=>{var t,r,s,i,a,c,l,u=!1,h="",d=0,p=0,f=e.length;if(""===e)return h;do{for(o[0]=o[5],o[1]=o[6],o[2]=o[7],l=p;d<f&&l<5;++d)(c=e.charCodeAt(d))<128?o[l++]=c:c<2048?(o[l++]=192|c>>6,o[l++]=128|63&c):c<55296||c>=57344?(o[l++]=224|c>>12,o[l++]=128|c>>6&63,o[l++]=128|63&c):(c=65536+((1023&c)<<10|1023&e.charCodeAt(++d)),o[l++]=240|c>>18,o[l++]=128|c>>12&63,o[l++]=128|c>>6&63,o[l++]=128|63&c);p=l-5,d===f&&++d,d>f&&l<6&&(u=!0),t=o[0],l>4?(r=o[1],s=o[2],i=o[3],a=o[4],h+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[31&(s<<1|i>>>7)]+n[i>>>2&31]+n[31&(i<<3|a>>>5)]+n[31&a]):1===l?h+=n[t>>>3]+n[t<<2&31]+"======":2===l?(r=o[1],h+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[r<<4&31]+"===="):3===l?(r=o[1],s=o[2],h+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[s<<1&31]+"==="):(r=o[1],s=o[2],i=o[3],h+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[31&(s<<1|i>>>7)]+n[i>>>2&31]+n[i<<3&31]+"=")}while(!u);return h})(e)},decode:c};c.asBytes=a,r?e.exports=l:t.base32=l})()})(Hv)),Hv.exports),Gv=Ln(jv);class Wv{static RECORD_PREFIX=cv.RECORD_PREFIX;static TREE_PREFIX="enrtree:";static BRANCH_PREFIX="enrtree-branch:";static ROOT_PREFIX="enrtree-root:";static parseAndVerifyRoot(e,t){if(!e.startsWith(this.ROOT_PREFIX))throw Error(`ENRTree root entry must start with '${this.ROOT_PREFIX}'`);const r=Wv.parseRootValues(e),n=Gv.decode.asBytes(t),s=e.split(" sig")[0],o=vn(s);if(!Ww(tt(r.signature,"base64url").slice(0,64),Gw(o),new Uint8Array(n)))throw Error("Unable to verify ENRTree root signature");return r.eRoot}static parseRootValues(e){const t=e.match(/^enrtree-root:v1 e=([^ ]+) l=([^ ]+) seq=(\d+) sig=([^ ]+)$/);if(!Array.isArray(t))throw Error("Could not parse ENRTree root entry");t.shift();const[r,n,s,o]=t;if(!r)throw Error("Could not parse 'e' value from ENRTree root entry");if(!n)throw Error("Could not parse 'l' value from ENRTree root entry");if(!s)throw Error("Could not parse 'seq' value from ENRTree root entry");if(!o)throw Error("Could not parse 'sig' value from ENRTree root entry");return{eRoot:r,lRoot:n,seq:Number(s),signature:o}}static parseTree(e){if(!e.startsWith(this.TREE_PREFIX))throw Error(`ENRTree tree entry must start with '${this.TREE_PREFIX}'`);const t=e.match(/^enrtree:\/\/([^@]+)@(.+)$/);if(!Array.isArray(t))throw Error("Could not parse ENRTree tree entry");t.shift();const[r,n]=t;if(!r)throw Error("Could not parse public key from ENRTree tree entry");if(!n)throw Error("Could not parse domain from ENRTree tree entry");return{publicKey:r,domain:n}}static parseBranch(e){if(!e.startsWith(this.BRANCH_PREFIX))throw Error(`ENRTree branch entry must start with '${this.BRANCH_PREFIX}'`);return e.split(this.BRANCH_PREFIX)[1].split(",")}}const Xv=new Kn("discovery:fetch_nodes");function Zv(e,t){return t.relay>=e.relay&&t.store>=e.store&&t.filter>=e.filter&&t.lightPush>=e.lightPush}function Yv(e,t){if(!e.nodeId)return!1;for(const r of t)if(e.nodeId===r.nodeId)return!1;return!0}function Qv(e,t){e.relay&&(t.relay+=1),e.store&&(t.store+=1),e.filter&&(t.filter+=1),e.lightPush&&(t.lightPush+=1)}function Jv(e,t,r){if(Zv(t,r))throw"Internal Error: Waku2 wanted capabilities are already fulfilled";const n=function(e,t){return{relay:t.relay<e.relay,store:t.store<e.store,filter:t.filter<e.filter,lightPush:t.lightPush<e.lightPush}}(t,r);return n.relay&&e.relay||n.store&&e.store||n.filter&&e.filter||n.lightPush&&e.lightPush}const eE=new Kn("discovery:dns");class tE{dns;_DNSTreeCache;_errorTolerance=10;static async dnsOverHttp(e){return e||(e=await Kv.create()),new tE(e)}async getPeers(e,t){const r=Math.floor(Math.random()*e.length),{publicKey:n,domain:s}=Wv.parseTree(e[r]),o={domain:s,publicKey:n,visits:{}},i=await async function(e,t,r){const n={relay:e.relay??0,store:e.store??0,filter:e.filter??0,lightPush:e.lightPush??0},s=n.relay+n.store+n.filter+n.lightPush,o={relay:0,store:0,filter:0,lightPush:0};let i=0;const a=[];for(;!Zv(n,o)&&i<s+t;){const e=await r();e&&Yv(e,a)&&(e.waku2&&Jv(e.waku2,n,o)&&(Qv(e.waku2,o),a.push(e)),Xv.info(`got new peer candidate from DNS address=${e.nodeId}@${e.ip}`)),i++}return a}(t,this._errorTolerance,(()=>this._search(s,o)));return eE.info("retrieved peers: ",i.map((e=>({id:e.peerId?.toString(),multiaddrs:e.multiaddrs?.map((e=>e.toString()))})))),i}constructor(e){this._DNSTreeCache={},this.dns=e}async*getNextPeer(e,t){const r=Math.floor(Math.random()*e.length),{publicKey:n,domain:s}=Wv.parseTree(e[r]),o={domain:s,publicKey:n,visits:{}};for await(const e of async function*(e,t,r){const n={relay:e.relay??0,store:e.store??0,filter:e.filter??0,lightPush:e.lightPush??0},s=n.relay+n.store+n.filter+n.lightPush,o={relay:0,store:0,filter:0,lightPush:0};let i=0;const a=new Set;for(;!Zv(n,o)&&i<s+t;){const e=await r();e&&e.nodeId&&!a.has(e.nodeId)&&(a.add(e.nodeId),e.waku2&&Jv(e.waku2,n,o)&&(Qv(e.waku2,o),yield e),Xv.info(`got new peer candidate from DNS address=${e.nodeId}@${e.ip}`)),i++}}(t,this._errorTolerance,(()=>this._search(s,o))))yield e}async _search(e,t){try{const r=await this._getTXTRecord(e,t);let n,s;t.visits[e]=!0;const o=function(e){return e.startsWith(Wv.ROOT_PREFIX)?Wv.ROOT_PREFIX:e.startsWith(Wv.BRANCH_PREFIX)?Wv.BRANCH_PREFIX:e.startsWith(Wv.RECORD_PREFIX)?Wv.RECORD_PREFIX:""}(r);try{switch(o){case Wv.ROOT_PREFIX:return n=Wv.parseAndVerifyRoot(r,t.publicKey),await this._search(n,t);case Wv.BRANCH_PREFIX:return s=Wv.parseBranch(r),n=function(e,t){const r={};for(const[n,s]of e.entries())t.visits[s]&&(r[n]=!0);if(Object.keys(r).length===e.length)throw Error("Unresolvable circular path detected");let n;do{n=Math.floor(Math.random()*e.length)}while(r[n]);return e[n]}(s,t),await this._search(n,t);case Wv.RECORD_PREFIX:return Mv.fromString(r);default:return null}}catch(t){return eE.error(`Failed to search DNS tree ${o} at subdomain ${e}: ${t}`),null}}catch(t){return eE.error(`Failed to retrieve TXT record at subdomain ${e}: ${t}`),null}}async _getTXTRecord(e,t){if(this._DNSTreeCache[e])return this._DNSTreeCache[e];const r=e!==t.domain?`${e}.${t.domain}`:t.domain,n=await this.dns.resolveTXT(r);if(!n.length)throw Error("Received empty result array while fetching TXT record");if(!n[0].length)throw Error("Received empty TXT record");const s=n.join("");return this._DNSTreeCache[e]=s,s}}const rE=new Kn("peer-discovery-dns");class nE extends qo{nextPeer;_started;_components;_options;constructor(e,t){super(),this._started=!1,this._components=e,this._options=t;const{enrUrls:r}=t;rE.info("Use following EIP-1459 ENR Tree URLs: ",r)}async start(){rE.info("Starting peer discovery via dns"),this._started=!0,await this.findPeers()}async findPeers(){if(!this.nextPeer){let{enrUrls:e}=this._options;Array.isArray(e)||(e=[e]);const{wantedNodeCapabilityCount:t}=this._options,r=await tE.dnsOverHttp();this.nextPeer=r.getNextPeer.bind(r,e,t)}for await(const e of this.nextPeer()){if(!this._started)return;const{peerInfo:t,shardInfo:r}=e;if(!t)continue;const n={[Nb]:{value:this._options.tagValue??50,ttl:this._options.tagTTL??1e8}};let s=!1;if(await this._components.peerStore.has(t.id)){(await this._components.peerStore.get(t.id)).tags.has(Nb)||(s=!0,await this._components.peerStore.merge(t.id,{tags:n}))}else s=!0,await this._components.peerStore.save(t.id,{tags:n,...r&&{metadata:{shardInfo:_n(r)}}});s&&this.dispatchEvent(new CustomEvent("peer",{detail:t}))}}stop(){this._started=!1}get[ao](){return!0}get[Symbol.toStringTag](){return dn}}function sE(e,t=Mb){return r=>new nE(r,{enrUrls:e,wantedNodeCapabilityCount:t})}function oE(e){return e.filter((e=>"open"===e.status)).sort(((e,t)=>t.timeline.open-e.timeline.open)).at(0)}const iE="consumed";class aE{multicodec;getConnections;addEventListener;log;ongoingCreation=new Set;streamPool=new Map;constructor(e,t,r){this.multicodec=e,this.getConnections=t,this.addEventListener=r,this.log=new Kn("stream-manager:"+e),this.addEventListener("peer:update",this.handlePeerUpdateStreamPool)}async getStream(e){const t=e.toString(),r=this.streamPool.get(t);r&&(this.streamPool.delete(t),await r);let n=this.getOpenStreamForCodec(e);return n?(this.log.info(`Found existing stream peerId=${t} multicodec=${this.multicodec}`),this.lockStream(t,n),n):(n=await this.createStream(e),this.lockStream(t,n),n)}async createStream(e,t=0){const r=oE(this.getConnections(e));if(!r)throw Error(`Failed to get a connection to the peer peerId=${e.toString()} multicodec=${this.multicodec}`);let n,s;for(let o=0;o<t+1;o++)try{this.log.info(`Attempting to create a stream for peerId=${e.toString()} multicodec=${this.multicodec}`),s=await r.newStream(this.multicodec),this.log.info(`Created stream for peerId=${e.toString()} multicodec=${this.multicodec}`);break}catch(e){n=e}if(!s)throw Error(`Failed to create a new stream for ${e.toString()} -- `+n);return s}async createStreamWithLock(e){const t=e.id.toString();if(this.ongoingCreation.has(t))this.log.info(`Skipping creation of a stream due to lock for peerId=${t} multicodec=${this.multicodec}`);else try{this.ongoingCreation.add(t),await this.createStream(e.id)}catch(e){this.log.error("Failed to createStreamWithLock:",e)}finally{this.ongoingCreation.delete(t)}}handlePeerUpdateStreamPool=e=>{const{peer:t}=e.detail;if(!t.protocols.includes(this.multicodec))return;this.getOpenStreamForCodec(t.id)||this.scheduleNewStream(t)};scheduleNewStream(e){this.log.info(`Scheduling creation of a stream for peerId=${e.id.toString()} multicodec=${this.multicodec}`),this.streamPool.has(e.id.toString())&&this.streamPool.delete(e.id.toString()),this.streamPool.set(e.id.toString(),this.createStreamWithLock(e))}getOpenStreamForCodec(e){const t=oE(this.getConnections(e));if(!t)return;const r=t.streams.find((e=>e.protocol===this.multicodec));if(!r)return;return["done","closed","closing"].includes(r.writeStatus||"")||this.isStreamLocked(r)?void 0:r}lockStream(e,t){this.log.info(`Locking stream for peerId:${e}\tstreamId:${t.id}`),t.metadata[iE]=!0}isStreamLocked(e){return!!e.metadata[iE]}}class cE{multicodec;components;pubsubTopics;addLibp2pEventListener;removeLibp2pEventListener;streamManager;constructor(e,t,r){this.multicodec=e,this.components=t,this.pubsubTopics=r,this.addLibp2pEventListener=t.events.addEventListener.bind(t.events),this.removeLibp2pEventListener=t.events.removeEventListener.bind(t.events),this.streamManager=new aE(e,t.connectionManager.getConnections.bind(t.connectionManager),this.addLibp2pEventListener)}async getStream(e){return this.streamManager.getStream(e)}}class lE{proto;constructor(e){this.proto=e}static createRequest(e){const{numPeers:t}=e;return new lE({query:{numPeers:t},response:void 0})}encode(){return Kt.encode(this.proto)}static decode(e){const t=Kt.decode(e);return new lE(t)}get query(){return this.proto.query}get response(){return this.proto.response}}const uE="/vac/waku/peer-exchange/2.0.0-alpha1",hE=new Kn("peer-exchange");class dE extends cE{constructor(e,t){super(uE,e,t)}async query(e){const{numPeers:t,peerId:r}=e,n=lE.createRequest({numPeers:BigInt(t)});if(!await this.components.peerStore.get(r))return{peerInfos:null,error:cn.NO_PEER_AVAILABLE};let s;try{s=await this.getStream(r)}catch(e){return hE.error("Failed to get stream",e),{peerInfos:null,error:cn.NO_STREAM_AVAILABLE}}const o=await Is([n.encode()],is,s,ps,(async e=>await Yn(e)));try{const e=new ns;o.forEach((t=>{e.append(t)}));const{response:t}=lE.decode(e);if(!t)return hE.error("PeerExchangeRPC message did not contains a `response` field"),{peerInfos:null,error:cn.EMPTY_PAYLOAD};return{peerInfos:await Promise.all(t.peerInfos.map((e=>e.enr)).filter(Jt).map((async e=>({ENR:await Mv.fromRLP(e)})))),error:null}}catch(e){return hE.error("Failed to decode push reply",e),{peerInfos:null,error:cn.DECODE_FAILED}}}}const pE=new Kn("peer-exchange-discovery"),fE=1e4,gE=3,mE=ln.PEER_EXCHANGE;class yE extends qo{components;peerExchange;options;isStarted;queryingPeers=new Set;queryAttempts=new Map;handleDiscoveredPeer=e=>{const{protocols:t,peerId:r}=e.detail;t.includes(uE)&&!this.queryingPeers.has(r.toString())&&(this.queryingPeers.add(r.toString()),this.startRecurringQueries(r).catch((e=>pE.error("Error querying peer "+e))))};constructor(e,t,r={}){super(),this.components=e,this.peerExchange=new dE(e,t),this.options=r,this.isStarted=!1}start(){this.isStarted||(this.dispatchEvent(new CustomEvent("waku:peer-exchange:started",{detail:!0})),pE.info("Starting peer exchange node discovery, discovering peers"),this.components.events.addEventListener("peer:identify",this.handleDiscoveredPeer))}stop(){this.isStarted&&(pE.info("Stopping peer exchange node discovery"),this.isStarted=!1,this.queryingPeers.clear(),this.components.events.removeEventListener("peer:identify",this.handleDiscoveredPeer))}get[ao](){return!0}get[Symbol.toStringTag](){return"@waku/peer-exchange"}startRecurringQueries=async e=>{const t=e.toString(),{queryInterval:r=fE,maxRetries:n=gE}=this.options;pE.info(`Querying peer: ${t} (attempt ${this.queryAttempts.get(t)??1})`),await this.query(e);const s=this.queryAttempts.get(t)??1;s>n?this.abortQueriesForPeer(t):setTimeout((()=>{this.queryAttempts.set(t,s+1),this.startRecurringQueries(e).catch((e=>{pE.error("Error in startRecurringQueries: "+e)}))}),r*s)};async query(e){const{error:t,peerInfos:r}=await this.peerExchange.query({numPeers:10,peerId:e});if(t)return pE.error("Peer exchange query failed",t),{error:t,peerInfos:null};for(const e of r){const{ENR:t}=e;if(!t){pE.warn("No ENR in peerInfo object, skipping");continue}const{peerId:r,peerInfo:n,shardInfo:s}=t;if(!r||!n)continue;if(await this.components.peerStore.has(r)){const{hasMultiaddrDiff:e,hasShardDiff:t}=await this.checkPeerInfoDiff(n,s);if(e||t){pE.info(`Peer ${r.toString()} has updated multiaddrs or shardInfo, updating`),e&&(pE.info(`Peer ${r.toString()} has updated multiaddrs, updating`),await this.components.peerStore.patch(r,{multiaddrs:n.multiaddrs})),t&&s&&(pE.info(`Peer ${r.toString()} has updated shardInfo, updating`),await this.components.peerStore.merge(r,{metadata:{shardInfo:_n(s)}}),this.dispatchEvent(new CustomEvent("peer",{detail:{id:r,multiaddrs:n.multiaddrs}})));continue}}await this.components.peerStore.save(r,{tags:{[mE]:{value:this.options.tagValue??50,ttl:this.options.tagTTL??1e8}},...s&&{metadata:{shardInfo:_n(s)}},...n.multiaddrs&&{multiaddrs:n.multiaddrs}}),pE.info("Discovered peer: "+r.toString()),this.dispatchEvent(new CustomEvent("peer",{detail:{id:r,multiaddrs:n.multiaddrs}}))}return{error:null,peerInfos:r}}abortQueriesForPeer(e){pE.info("Aborting queries for peer: "+e),this.queryingPeers.delete(e),this.queryAttempts.delete(e)}async checkPeerInfoDiff(e,t){const{id:r}=e,n=await this.components.peerStore.get(r),s=n.addresses.map((e=>e.multiaddr.toString())),o=e.multiaddrs.map((e=>e.toString())),i=s.some((e=>!o.includes(e)));let a=!1;const c=n.metadata.get("shardInfo");if(c){const e=Tn(c);(e||t)&&(a=e.clusterId!==t?.clusterId||e.shards.some((e=>!t?.shards.includes(e))))}return{hasMultiaddrDiff:i,hasShardDiff:a}}}function bE(e){return t=>new yE(t,e)}const wE=new Kn("peer-exchange-discovery"),vE=ln.LOCAL;class EE extends qo{components;options;isStarted;peers=[];constructor(e,t){super(),this.components=e,this.options=t,this.isStarted=!1,this.peers=this.getPeersFromLocalStorage()}get[Symbol.toStringTag](){return"@waku/local-peer-cache-discovery"}async start(){if(!this.isStarted){wE.info("Starting Local Storage Discovery"),this.components.events.addEventListener("peer:identify",this.handleNewPeers);for(const{id:e,address:t}of this.peers){const r=pu(e);await this.components.peerStore.has(r)||(await this.components.peerStore.save(r,{multiaddrs:[Ri(t)],tags:{[this.options?.tagName??vE]:{value:this.options?.tagValue??50,ttl:this.options?.tagTTL??1e8}}}),this.dispatchEvent(new CustomEvent("peer",{detail:{id:r,multiaddrs:[Ri(t)]}})))}wE.info(`Discovered ${this.peers.length} peers`),this.isStarted=!0}}stop(){this.isStarted&&(wE.info("Stopping Local Storage Discovery"),this.components.events.removeEventListener("peer:identify",this.handleNewPeers),this.isStarted=!1,this.savePeersToLocalStorage())}handleNewPeers=e=>{const{peerId:t,listenAddrs:r}=e.detail,n=function(e){const t=e.find((e=>e.toString().includes("ws")||e.toString().includes("wss")));if(!t)throw Error("No ws multiaddr found in the given addresses");return t}(r),s=this.getPeersFromLocalStorage(),o=s.findIndex((e=>e.id===t.toString()));o>=0?s[o].address=n.toString():s.push({id:t.toString(),address:n.toString()}),this.peers=s,this.savePeersToLocalStorage()};getPeersFromLocalStorage(){try{const e=localStorage.getItem("waku:peers");if(!e)return[];return JSON.parse(e).filter(SE)}catch(e){return wE.error("Error parsing peers from local storage:",e),[]}}savePeersToLocalStorage(){try{localStorage.setItem("waku:peers",JSON.stringify(this.peers))}catch(e){wE.error("Error saving peers to local storage:",e)}}}function SE(e){return e&&"object"==typeof e&&"string"==typeof e.id&&"string"==typeof e.address}const AE=new Kn("sdk:create");async function CE(e,t,r){!t?.hideWebSocketInfo&&Lb();const n=e?{metadata:qi(e)}:{};return async function(e={}){e.privateKey??=await su();const t=new Rb({...await rg(e),peerId:(r=e.privateKey,fu(r.publicKey))});var r;return!1!==e.start&&await t.start(),t}({transports:[Sf({filter:!1===t?.filterMultiaddrs||Lb()?wf:vf})],streamMuxers:[Wp()],connectionEncrypters:[Rh()],...t,services:{identify:Ep({agentVersion:r??"js-waku"}),ping:Yp({maxInboundStreams:t?.pingMaxInboundStreams??10}),...n,...t?.services}})}async function IE(e){const{networkConfig:t}=e,r=function(e){if("clusterId"in(t=e)&&"shards"in t&&!("contentTopics"in t)){if(0===e.shards.length)throw Error("Invalid shards configuration: please provide at least one shard");return Sn(e)}if((e=>"contentTopics"in e)(e)){if(0===e.contentTopics.length)throw Error("Invalid content topics configuration: please provide at least one content topic");return e.contentTopics.map((t=>kn(t,e.clusterId)))}throw Error("Unknown shard config. Please use ShardInfo or ContentTopicInfo");var t}(t??pn);AE.info("Creating Waku node with pubsub topics",r);const n=e?.libp2p??{},s=n.peerDiscovery??[];var o;e?.defaultBootstrap&&s.push(...function(e){return[sE([Db]),(e,t)=>new EE(e,t),bE(e)]}(r)),e?.bootstrapPeers&&s.push((o={list:e.bootstrapPeers},e=>new ud(e,o))),n.peerDiscovery=s;return{libp2p:await CE(r,n,e?.userAgent),pubsubTopics:r}}const{floor:xE,random:kE}=Math,PE="Trystero",TE=(e,t)=>Array(e).fill().map(t),_E="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",RE=TE(20,(()=>_E[xE(62*kE())])).join("");const LE=Promise.all.bind(Promise),DE="undefined"!=typeof window,{entries:NE,fromEntries:ME,keys:OE}=Object,FE=()=>{},UE=e=>Error(`${PE}: ${e}`),BE=new TextEncoder,qE=new TextDecoder,$E=e=>BE.encode(e),zE=e=>qE.decode(e),KE=(...e)=>e.join("@"),VE=JSON.stringify,HE=JSON.parse,jE="AES-GCM",GE={},WE=async e=>GE[e]||=Array.from(await(async(e,t)=>new Uint8Array(await crypto.subtle.digest(e,$E(t))))("SHA-1",e)).map((e=>e.toString(36))).join(""),XE=async(e,t)=>{const r=crypto.getRandomValues(new Uint8Array(16));return r.join(",")+"$"+(n=await crypto.subtle.encrypt({name:jE,iv:r},await e,$E(t)),btoa(String.fromCharCode.apply(null,new Uint8Array(n))));var n},ZE=async(e,t)=>{const[r,n]=t.split("$");return zE(await crypto.subtle.decrypt({name:jE,iv:new Uint8Array(r.split(","))},await e,(e=>{const t=atob(e);return new Uint8Array(t.length).map(((e,r)=>t.charCodeAt(r))).buffer})(n)))},YE="icegatheringstatechange",QE="offer";var JE=(e,{rtcConfig:t,rtcPolyfill:r,turnConfig:n})=>{const s=new(r||RTCPeerConnection)({iceServers:eS.concat(n||[]),...t}),o={};let i=!1,a=!1,c=null;const l=e=>{e.binaryType="arraybuffer",e.bufferedAmountLowThreshold=65535,e.onmessage=e=>o.data?.(e.data),e.onopen=()=>o.connect?.(),e.onclose=()=>o.close?.(),e.onerror=e=>o.error?.(e)},u=e=>Promise.race([new Promise((t=>{const r=()=>{"complete"===e.iceGatheringState&&(e.removeEventListener(YE,r),t())};e.addEventListener(YE,r),r()})),new Promise((e=>setTimeout(e,5e3)))]).then((()=>({type:e.localDescription.type,sdp:e.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")})));return e?(c=s.createDataChannel("data"),l(c)):s.ondatachannel=({channel:e})=>{c=e,l(e)},s.onnegotiationneeded=async()=>{try{i=!0,await s.setLocalDescription();const e=await u(s);o.signal?.(e)}catch(e){o.error?.(e)}finally{i=!1}},s.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(s.connectionState)&&o.close?.()},s.ontrack=e=>{o.track?.(e.track,e.streams[0]),o.stream?.(e.streams[0])},s.onremovestream=e=>o.stream?.(e.stream),e&&(s.canTrickleIceCandidates||s.onnegotiationneeded()),{created:Date.now(),connection:s,get channel(){return c},get isDead(){return"closed"===s.connectionState},async signal(t){if("open"!==c?.readyState||t.sdp?.includes("a=rtpmap"))try{if(t.type===QE){if(i||"stable"!==s.signalingState&&!a){if(e)return;await LE([s.setLocalDescription({type:"rollback"}),s.setRemoteDescription(t)])}else await s.setRemoteDescription(t);await s.setLocalDescription();const r=await u(s);return o.signal?.(r),r}if("answer"===t.type){a=!0;try{await s.setRemoteDescription(t)}finally{a=!1}}}catch(e){o.error?.(e)}},sendData(e){return c.send(e)},destroy(){c?.close(),s.close(),i=!1,a=!1},setHandlers(e){return Object.assign(o,e)},offerPromise:e?new Promise((e=>o.signal=t=>{t.type===QE&&e(t)})):Promise.resolve(),addStream(e){return e.getTracks().forEach((t=>s.addTrack(t,e)))},removeStream(e){return s.getSenders().filter((t=>e.getTracks().includes(t.track))).forEach((e=>s.removeTrack(e)))},addTrack(e,t){return s.addTrack(e,t)},removeTrack(e){const t=s.getSenders().find((t=>t.track===e));t&&s.removeTrack(t)},replaceTrack(e,t){const r=s.getSenders().find((t=>t.track===e));if(r)return r.replaceTrack(t)}}};const eS=[...TE(3,((e,t)=>`stun:stun${t||""}.l.google.com:19302`)),"stun:stun.cloudflare.com:3478"].map((e=>({urls:e}))),tS=Object.getPrototypeOf(Uint8Array),rS=16369,nS=255,sS="bufferedamountlow",oS=e=>"@_"+e;var iS=(e,t,r)=>{const n={},s={},o={},i={},a={},c={},l={},u={onPeerJoin:FE,onPeerLeave:FE,onPeerStream:FE,onPeerTrack:FE},h=(e,t)=>(e?Array.isArray(e)?e:[e]:OE(n)).flatMap((e=>{const r=n[e];return r?t(e,r):(console.warn(`${PE}: no peer with id ${e} found`),[])})),d=e=>{n[e]&&(n[e].destroy(),delete n[e],delete i[e],delete a[e],u.onPeerLeave(e),t(e))},p=e=>{if(s[e])return o[e];if(!e)throw UE("action type argument is required");const t=$E(e);if(t.byteLength>12)throw UE(`action type string "${e}" (${t.byteLength}b) exceeds byte limit (12). Hint: choose a shorter name.`);const r=new Uint8Array(12);r.set(t);let i=0;return s[e]={onComplete:FE,onProgress:FE,setOnComplete(t){return s[e]={...s[e],onComplete:t}},setOnProgress(t){return s[e]={...s[e],onProgress:t}},async send(e,t,s,o){if(s&&"object"!=typeof s)throw UE("action meta argument must be an object");const a=typeof e;if("undefined"===a)throw UE("action data cannot be undefined");const c="string"!==a,l=e instanceof Blob,u=l||e instanceof ArrayBuffer||e instanceof tS;if(s&&!u)throw UE("action meta argument can only be used with binary data");const d=u?new Uint8Array(l?await e.arrayBuffer():e):$E(c?VE(e):e),p=s?$E(VE(s)):null,f=Math.ceil(d.byteLength/rS)+(s?1:0)||1,g=TE(f,((e,t)=>{const n=t===f-1,o=s&&0===t,a=new Uint8Array(15+(o?p.byteLength:n?d.byteLength-rS*(f-(s?2:1)):rS));return a.set(r),a.set([i],12),a.set([n|o<<1|u<<2|c<<3],13),a.set([Math.round((t+1)/f*nS)],14),a.set(s?o?p:d.subarray((t-1)*rS,t*rS):d.subarray(t*rS,(t+1)*rS),15),a}));return i=i+1&nS,LE(h(t,(async(e,t)=>{const{channel:r}=t;let i=0;for(;i<f;){const a=g[i];if(r.bufferedAmount>r.bufferedAmountLowThreshold&&await new Promise((e=>{const t=()=>{r.removeEventListener(sS,t),e()};r.addEventListener(sS,t)})),!n[e])break;t.sendData(a),i++,o?.(a[14]/nS,e,s)}})))}},o[e]||=[s[e].send,s[e].setOnComplete,s[e].setOnProgress]},f=async()=>{await I(""),await new Promise((e=>setTimeout(e,99))),NE(n).forEach((([e,t])=>{t.destroy(),delete n[e]})),r()},[g,m]=p(oS("ping")),[y,b]=p(oS("pong")),[w,v]=p(oS("signal")),[E,S]=p(oS("stream")),[A,C]=p(oS("track")),[I,x]=p(oS("leave"));return e(((e,t)=>{n[t]||(n[t]=e,e.setHandlers({data(e){return((e,t)=>{const r=new Uint8Array(t),n=zE(r.subarray(0,12)).replaceAll("\0",""),[o]=r.subarray(12,13),[a]=r.subarray(13,14),[c]=r.subarray(14,15),l=r.subarray(15),u=!!(1&a),h=!!(2&a),d=!!(4&a),p=!!(8&a);if(!s[n])return void console.warn(`${PE}: received message with unregistered type (${n})`);i[e]||={},i[e][n]||={};const f=i[e][n][o]||={chunks:[]};if(h?f.meta=HE(zE(l)):f.chunks.push(l),s[n].onProgress(c/nS,e,f.meta),!u)return;const g=new Uint8Array(f.chunks.reduce(((e,t)=>e+t.byteLength),0));if(f.chunks.reduce(((e,t)=>(g.set(t,e),e+t.byteLength)),0),delete i[e][n][o],d)s[n].onComplete(g,e,f.meta);else{const t=zE(g);s[n].onComplete(p?HE(t):t,e)}})(t,e)},stream(e){u.onPeerStream(e,t,c[t]),delete c[t]},track(e,r){u.onPeerTrack(e,r,t,l[t]),delete l[t]},signal(e){return w(e,t)},close(){return d(t)},error(e){console.error(e),d(t)}}),u.onPeerJoin(t))})),m(((e,t)=>y("",t))),b(((e,t)=>{a[t]?.(),delete a[t]})),v(((e,t)=>n[t]?.signal(e))),S(((e,t)=>c[t]=e)),C(((e,t)=>l[t]=e)),x(((e,t)=>d(t))),DE&&addEventListener("beforeunload",f),{makeAction:p,leave:f,async ping(e){if(!e)throw UE("ping() must be called with target peer ID");const t=Date.now();return g("",e),await new Promise((t=>a[e]=t)),Date.now()-t},getPeers(){return ME(NE(n).map((([e,t])=>[e,t.connection])))},addStream(e,t,r){return h(t,(async(t,n)=>{r&&await E(r,t),n.addStream(e)}))},removeStream(e,t){return h(t,((t,r)=>r.removeStream(e)))},addTrack(e,t,r,n){return h(r,(async(r,s)=>{n&&await A(n,r),s.addTrack(e,t)}))},removeTrack(e,t){return h(t,((t,r)=>r.removeTrack(e)))},replaceTrack(e,t,r,n){return h(r,(async(r,s)=>{n&&await A(n,r),s.replaceTrack(e,t)}))},onPeerJoin(e){return u.onPeerJoin=e},onPeerLeave(e){return u.onPeerLeave=e},onPeerStream(e){return u.onPeerStream=e},onPeerTrack(e){return u.onPeerTrack=e}}};const aS="/waku/2/default-waku/proto",cS=e=>`/${PE}/0/${e}/json`,lS=(e,t,r)=>e.lightPush.send(Wn({pubsubTopic:aS,contentTopic:cS(t),ephemeral:!0}),{payload:$E(r)}),uS=(({init:e,subscribe:t,announce:r})=>{const n={};let s,o,i,a=!1;return(c,l,u)=>{const{appId:h}=c;if(n[h]?.[l])return n[h][l];const d={},p={},f=KE(PE,h,l),g=WE(f),m=WE(KE(f,RE)),y=(async(e,t,r)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},$E(`${e}:${t}:${r}`)),{name:jE},!1,["encrypt","decrypt"]))(c.password||"",h,l),b=e=>async t=>({type:t.type,sdp:await e(y,t.sdp)}),w=b(ZE),v=b(XE),E=()=>JE(!0,c),S=(e,t,r)=>{p[t]?p[t]!==e&&e.destroy():(p[t]=e,_(e,t),d[t]?.forEach(((e,t)=>{t!==r&&e.destroy()})),delete d[t])},A=(e,t)=>{p[t]===e&&delete p[t]},C=e=>(o.push(...TE(e,E)),LE(o.splice(0,e).map((e=>e.offerPromise.then(v).then((t=>({peer:e,offer:t}))))))),I=(e,t)=>u?.({error:`incorrect password (${c.password}) when decrypting ${t}`,appId:h,peerId:e,roomId:l}),x=e=>async(t,r,n)=>{const[s,o]=await LE([g,m]);if(t!==s&&t!==o)return;const{peerId:i,offer:a,answer:l,peer:u}="string"==typeof r?HE(r):r;if(i!==RE&&!p[i])if(!i||a||l){if(a){const t=d[i]?.[e];if(t&&RE>i)return;const r=JE(!1,c);let s;r.setHandlers({connect(){return S(r,i,e)},close(){return A(r,i)}});try{s=await w(a)}catch{return void I(i,"offer")}if(r.isDead)return;const[o,l]=await LE([WE(KE(f,i)),r.signal(s)]);n(o,VE({peerId:RE,answer:await v(l)}))}else if(l){let t;try{t=await w(l)}catch(e){return void I(i,"answer")}if(u)u.setHandlers({connect(){return S(u,i,e)},close(){return A(u,i)}}),u.signal(t);else{const r=d[i]?.[e];r&&!r.isDead&&r.signal(t)}}}else{if(d[i]?.[e])return;const[[{peer:t,offer:r}],s]=await LE([C(1),WE(KE(f,i))]);d[i]||=[],d[i][e]=t,setTimeout((()=>((e,t)=>{if(p[e])return;const r=d[e]?.[t];r&&(delete d[e][t],r.destroy())})(i,e)),.9*k[e]),t.setHandlers({connect(){return S(t,i,e)},close(){return A(t,i)}}),n(s,VE({peerId:RE,offer:r}))}};if(!c)throw UE("requires a config map as the first argument");if(!h&&!c.firebaseApp)throw UE("config map is missing appId field");if(!l)throw UE("roomId argument required");if(!a){const t=e(c);o=TE(20,E),s=Array.isArray(t)?t:[t],a=!0,i=setInterval((()=>o=o.filter((e=>{const t=Date.now()-e.created<57333;return t||e.destroy(),t}))),59052.99)}const k=s.map((()=>5333)),P=[],T=s.map((async(e,r)=>t(await e,await g,await m,x(r),C)));LE([g,m]).then((([e,t])=>{const n=async(s,o)=>{const i=await r(s,e,t);"number"==typeof i&&(k[o]=i),P[o]=setTimeout((()=>n(s,o)),k[o])};T.forEach((async(e,t)=>{await e,n(await s[t],t)}))}));let _=FE;return n[h]||={},n[h][l]=iS((e=>_=e),(e=>delete p[e]),(()=>{delete n[h][l],P.forEach(clearTimeout),T.forEach((async e=>(await e)())),clearInterval(i)}))}})({init(e){return async function(e={}){const{libp2p:t,pubsubTopics:r}=await IE(e),n=new fa(r,e,t,{store:!0,lightpush:!0,filter:!0});return!1!==e?.autoStart&&await n.start(),n}({defaultBootstrap:!1,pubsubTopics:[aS],bootstrapPeers:["/dns4/waku.myrandomdemos.online/tcp/8000/wss/p2p/16Uiu2HAmKfC2QUvMVyBsVjuEzdo1hVhRddZxo69YkBuXYvuZ83sc","/dns4/node-01.do-ams3.wakuv2.prod.status.im/tcp/8000/wss/p2p/16Uiu2HAmL5okWopX7NqZWBUKVqW8iUxCEmd5GMHLVPwCgzYzQv3e","/dns4/node-01.gc-us-central1-a.wakuv2.prod.statusim.net/tcp/8000/wss/p2p/16Uiu2HAmVkKntsECaYfefR1V2yCR79CegLATuTPE6B9TxgxBiiiA","/dns4/node-01.ac-cn-hongkong-c.wakuv2.prod.status.im/tcp/8000/wss/p2p/16Uiu2HAm4v86W3bmT1BiH6oSPzcsSr24iDQpSN5Qa992BCjjwgrD","/dns4/node-01.do-ams3.wakuv2.test.status.im/tcp/8000/wss/p2p/16Uiu2HAmPLe7Mzm8TsYUubgCAW1aJoeFScxrLj8ppHFivPo97bUZ"],libp2p:{peerDiscovery:[bE([aS])],hideWebSocketInfo:!0,...e.libp2pConfig}}).then((async e=>(await e.start(),await e.waitForPeers([an.LightPush,an.Filter]),e)))},async subscribe(e,t,r,n){const s=await LE([t,r].map((t=>e.filter.subscribe(Zn(cS(t),aS),(t=>r=>{r.payload&&n(t,zE(r.payload),((t,r)=>lS(e,t,r)))})(t)))));return()=>s.forEach((e=>e()))},announce(e,t){return lS(e,t,VE({peerId:RE}))}});export{uS as joinRoom,RE as selfId};