<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>LaTeX Lab</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🧪</text></svg>">

<!-- KaTeX -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

<!-- Computer Modern for Mixed mode text -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/cmu-serif.min.css" crossorigin="anonymous">

<!-- html2canvas and html-to-image for PNG export -->
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.min.js"></script>

<!-- KaTeX faces commonly used -->
<link rel="preload" as="font" type="font/woff2" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_Main-Regular.woff2" crossorigin>
<link rel="preload" as="font" type="font/woff2" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_Main-Italic.woff2" crossorigin>
<link rel="preload" as="font" type="font/woff2" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_Math-Italic.woff2" crossorigin>
<link rel="preload" as="font" type="font/woff2" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_AMS-Regular.woff2" crossorigin>
<link rel="preload" as="font" type="font/woff2" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_Size1-Regular.woff2" crossorigin>
<link rel="preload" as="font" type="font/woff2" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_Size2-Regular.woff2" crossorigin>

<!-- CMU Serif for Mixed-mode plain text -->
<link rel="preload" as="font" type="font/woff2"
      href="https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-500-roman.woff2" crossorigin>
<link rel="preload" as="font" type="font/woff2"
      href="https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-700-roman.woff2" crossorigin>

<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
@font-face{
  font-family:"CMU Serif";
  src:url("https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-500-roman.woff2") format("woff2");
  font-weight:500;
  font-style:normal;
  font-display:swap;
}
@font-face{
  font-family:"CMU Serif";
  src:url("https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-500-italic.woff2") format("woff2");
  font-weight:500;
  font-style:italic;
  font-display:swap;
}
@font-face{
  font-family:"CMU Serif";
  src:url("https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-700-roman.woff2") format("woff2");
  font-weight:700;
  font-style:normal;
  font-display:swap;
}
@font-face{
  font-family:"CMU Serif";
  src:url("https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-700-italic.woff2") format("woff2");
  font-weight:700;
  font-style:italic;
  font-display:swap;
}


:root{
  --bg:#ffffff; --text:#111; --gutter-bg:#f4f4f4; --gutter-text:#888;
  --stripe-light: rgba(0,0,0,.03);
  --border: rgba(0,0,0,.12);
}
body.dark{
  --bg:#121212; --text:#eee; --gutter-bg:#1f1f1f; --gutter-text:#aaa;
  --stripe-light: rgba(255,255,255,.04);
  --border: rgba(255,255,255,.14);
}

*{box-sizing:border-box}
html,body{height:100%;margin:0}
body{
  font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
  background:var(--bg); color:var(--text);
  display:flex; flex-direction:column;
  transition:background .18s,color .18s;
}

/* Toolbar */
.toolbar{
  border-bottom:1px solid var(--border);
  display:flex; align-items:center; gap:.5rem; padding:.5rem 1rem; flex-wrap:wrap;
}
.menu{position:relative; display:inline-block}
.menu-button, button{
  padding:.45em .7em; border-radius:6px; border:1px solid var(--border);
  background:rgba(255,255,255,.95); cursor:pointer; font-size:14px; color:inherit;
}
body.dark .menu-button, body.dark button{ background:linear-gradient(#222,#1b1b1b) }
.menu-button:active, button:active{transform:translateY(1px)}
.menu ul{
  position:absolute; z-index:10; min-width:220px; margin:.3rem 0 0; padding:.4rem 0;
  background:var(--bg); color:var(--text); list-style:none; border:1px solid var(--border); border-radius:8px;
  box-shadow:0 6px 24px rgba(0,0,0,.12); display:none;
}
.menu.open ul{display:block}
.menu ul li{padding:.45rem .75rem; cursor:pointer}
.menu ul li:hover{background:var(--stripe-light)}

/* Main split */
.container{flex:1; display:flex; min-height:0; overflow:hidden}
#leftPane{flex:0 0 50%; display:flex; min-width:260px; border-right:1px solid var(--border)}
#gutter{
  width:4.8em; padding-top:.6em; padding-bottom:.6em;
  background:var(--gutter-bg); color:var(--gutter-text);
  font-family:monospace; font-size:15px; text-align:right; user-select:none; overflow:hidden;
}
#gutter .ln{display:block; padding-right:.6em}
body:not(.dark) #gutter .ln:nth-child(odd){background-color:var(--stripe-light)}
body.dark #gutter .ln:nth-child(odd){background-color:var(--stripe-light)}

#editorWrap{position:relative; flex:1; overflow:hidden}
#overlay{ position:absolute; inset:0; pointer-events:none; overflow:hidden; }
#editor{
  position:relative; width:100%; height:100%;
  padding:.6em 1em .6em 1em;
  font-family:monospace; font-size:15px; line-height:1.5;
  border:none; outline:none; background:transparent; color:var(--text);
  resize:none; overflow:auto;
}

/* Divider */
#divider{
  width:12px; cursor:col-resize;
  background:
    radial-gradient(currentColor 22%, transparent 23%) center 14px/6px 10px no-repeat,
    radial-gradient(currentColor 22%, transparent 23%) center 28px/6px 10px no-repeat,
    linear-gradient(90deg, transparent, var(--border), transparent);
  color:#aaa;
}
#divider:hover{ color:#777 }
body.dark #divider{ color:#bbb }

/* Preview */
#preview{
  flex:1; padding:1.25rem; overflow:auto;
  background:var(--bg); color:var(--text);
  font-size:16px; line-height:1.6; white-space:pre-wrap;
}

/* Consistent tab rendering */
#editor, #preview { tab-size: 4; -moz-tab-size: 4; }

/* Bottom controls */
.controls{
  min-height:88px; border-top:1px solid var(--border);
  display:flex; align-items:center; justify-content:space-between;
  padding:.5rem 1rem 1rem; gap:1rem; background:linear-gradient(to top, rgba(0,0,0,.01), transparent);
}
.left-controls,.right-controls{display:flex; align-items:center; gap:1rem}

/* Mode slider (wide) */
.switch.mode{position:relative; width:120px; height:36px; display:inline-block}
.switch.mode input{display:none}
.switch.mode .track{
  position:absolute; inset:0; border-radius:999px; border:1px solid var(--border);
  background:transparent; display:flex; align-items:center; justify-content:space-between; padding:0 9px;
}
.switch.mode .thumb{
  position:absolute; top:50%; left:4px; width:60px; height:30px;
  background:#fff; border-radius:999px; box-shadow:0 2px 6px rgba(0,0,0,.22);
  transform:translate(0,-50%); transition:transform .18s;
}
body.dark .switch.mode .thumb{ background:#2a2a2a }
.stack{
  display:flex; flex-direction:column; align-items:center; line-height:1.0;
  font-size:10px; font-weight:700; opacity:.45; transition:opacity .18s; user-select:none;
}
.switch.mode .stack { transform: translateY(-0.5px); }
#modeToggle:checked + .track .stack.all{opacity:1}
#modeToggle:not(:checked) + .track .stack.some{opacity:1}
#modeToggle:not(:checked) + .track .thumb{transform:translate(50px,-50%)}

/* Dark slider (compact) */
.switch.dark{position:relative; width:64px; height:34px; display:inline-block}
.switch.dark input{display:none}
.switch.dark .track{
  position:absolute; inset:0; border-radius:999px; border:1px solid var(--border);
  background:transparent; display:flex; align-items:center; justify-content:space-between; padding:0 6px;
}
.switch.dark .thumb{
  position:absolute; top:50%; left:3px; width:28px; height:28px;
  background:#fff; border-radius:50%; box-shadow:0 2px 6px rgba(0,0,0,.22);
  transform:translate(0,-50%); transition:transform .18s;
}
body.dark .switch.dark .thumb{ background:#2a2a2a }
.emoji{font-size:16px; filter: drop-shadow(0 0 2px rgba(0,0,0,.35)); opacity:.45; transition:opacity .18s; user-select:none}
#darkToggle:not(:checked) + .track .sun{opacity:1}
#darkToggle:checked + .track .moon{opacity:1}
#darkToggle:checked + .track .thumb{transform:translate(28px,-50%)}

#modeLabel{font-weight:600; min-width:64px}
#modeDesc{font-size:12px; opacity:.8}

/* Modals */
.modal-backdrop{
  position:fixed; inset:0; background:rgba(0,0,0,.35);
  display:none; align-items:center; justify-content:center; z-index:9999;
}
.modal-backdrop.show{ display:flex }
.modal{
  width:min(540px,92vw); background:var(--bg); color:var(--text);
  border-radius:12px; padding:1rem; border:1px solid var(--border)
}
.modal h3{margin:.2rem 0 1rem 0}
.modal .row{display:flex; gap:.75rem; align-items:center; margin:.5rem 0; flex-wrap:wrap}
.modal label{min-width:4.5rem}
.modal input[type="number"], .modal select {width:100px; padding:.35rem .4rem}
.modal .preview{
  margin-top:.75rem; padding:.75rem; border-radius:8px; border:1px dashed var(--border);
  font-family:monospace; white-space:pre-wrap; max-height:240px; overflow:auto;
}
.modal .actions{display:flex; justify-content:flex-end; gap:.5rem; margin-top:1rem}

/* Mixed mode: plain text uses Computer Modern; KaTeX keeps its own fonts */
body.mixed #preview { font-family: "CMU Serif"; font-weight: 500;}
/* NOTE: intentionally NOT overriding .katex font-family */

/* Larger non-math font size in Mixed mode preview */
body.mixed #preview { font-size:20px; line-height:1.4; }

/* Make whole pill clickable and prevent the thumb from swallowing clicks */
.switch .track { cursor: pointer; }
.switch .thumb { pointer-events: none; }

/* Hidden DIV used for measuring wrap heights (Safari-friendly) */
#measure{
  position:absolute; visibility:hidden;
  top:-9999px; left:-9999px;
  box-sizing:content-box;
  padding:0; margin:0; border:0;
  white-space:pre-wrap; word-break:break-word; overflow-wrap:break-word;
}

#editorWrap { background: var(--bg); }
#overlay .row { width: 100%; margin: 0; }
#editorWrap { position:relative; }

#overlay{ position:absolute; inset:0; pointer-events:none; z-index:2; }
#editor{  position:relative; z-index:1; background: transparent; }

/* Welcome pop-under */
.welcome-pop {
  position: fixed;
  bottom: 1rem; right: 1rem;
  max-width: 360px;
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 10px;
  box-shadow: 0 6px 20px rgba(0,0,0,.25);
  padding: 1rem;
  z-index: 99999;
  display: none;
  animation: fadeInUp .35s ease;
}
.welcome-pop h3 { margin: 0 0 .5rem; }
.welcome-pop p  { font-size: 13px; line-height: 1.45; margin: 0 0 .75rem; }
.welcome-pop button {
  padding: .35em .7em; border-radius: 6px; border: 1px solid var(--border);
  background: rgba(255,255,255,.95); cursor: pointer; font-size: 13px;
}
body.dark .welcome-pop { background: #1e1e1e; }
@keyframes fadeInUp { from { opacity:0; transform:translateY(12px) } to { opacity:1; transform:translateY(0) } }
@media (max-width: 520px) { .welcome-pop { left: 1rem; right: 1rem; max-width: none; } }
</style>
</head>
<body>

<!-- Toolbar -->
<div class="toolbar">
  <div class="menu" id="snippetsMenu">
    <button class="menu-button" id="snippetsBtn">🔖 Insert ▾</button>
    <ul id="snippetsList">
      <li id="openMatrixGen">Matrix</li>
      <li id="openTableGen">Table</li>
      <li id="insertCases">Cases</li>
    </ul>
  </div>
  <button id="shareBtn" class="menu-button">🔗 Share link</button>
  <button id="macrosBtn" class="menu-button">⚡ Shortcuts</button>
</div>

<!-- Split -->
<div class="container">
  <section id="leftPane">
    <div id="gutter" aria-hidden="true"></div>
    <div id="editorWrap">
      <div id="overlay" aria-hidden="true"></div>
      <textarea id="editor" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"
        placeholder="Type text with $inline$ and $$display$$ math…"></textarea>
      <div id="measure" aria-hidden="true"></div>
    </div>
  </section>
  <div id="divider" role="separator" aria-orientation="vertical" aria-label="Resize panels"></div>
  <section id="preview" aria-live="polite"></section>
</div>

<!-- Controls -->
<div class="controls">
  <div class="left-controls">
    <!-- Mode slider -->
    <div class="mode" title="Mixed vs Classic rendering">
      <label class="switch mode" for="modeToggle">
        <input id="modeToggle" type="checkbox">
        <span class="track">
          <span class="stack some"><span>SOME</span><span>MATH</span></span>
          <span class="stack all"><span>ALL</span><span>MATH</span></span>
          <span class="thumb"></span>
        </span>
      </label>
      <div>
        <div id="modeLabel">Mixed</div>
        <div id="modeDesc">Mixed: type text with $inline$ and $$display$$ math.</div>
      </div>
    </div>
  </div>

  <div class="right-controls">
    <!-- Dark slider -->
    <div class="dark-switch" title="Light / Dark">
      <label class="switch dark" for="darkToggle">
        <input id="darkToggle" type="checkbox">
        <span class="track">
          <span class="emoji moon">🌙</span>
          <span class="emoji sun">🌞</span>
          <span class="thumb"></span>
        </span>
      </label>
    </div>

    <button id="pngBtn">🖼️ PNG</button>
    <!-- <button id="pdfBtn">📄 PDF</button> -->
    <button id="clearBtn" title="Clear editor and saved text">🧹 Clear</button>
  </div>
</div>

<!-- Matrix generator -->
<div class="modal-backdrop" id="matrixModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="matrixTitle">
    <h3 id="matrixTitle">Insert Matrix</h3>
    <div class="row">
      <label>Rows</label><input type="number" id="mRows" min="1" max="20" value="3">
      <label>Cols</label><input type="number" id="mCols" min="1" max="20" value="3">
      <label>Type</label>
      <select id="mType">
        <option value="pmatrix">pmatrix ( )</option>
        <option value="bmatrix">bmatrix [ ]</option>
        <option value="Bmatrix">Bmatrix { }</option>
        <option value="vmatrix">vmatrix | |</option>
        <option value="Vmatrix">Vmatrix || ||</option>
      </select>
    </div>
    <div class="preview" id="matrixPrev"></div>
    <div class="actions">
      <button class="menu-button" id="mCancel">Cancel</button>
      <button class="menu-button" id="mInsert">Insert</button>
    </div>
  </div>
</div>

<!-- Table generator (KaTeX-friendly via array) -->
<div class="modal-backdrop" id="tableModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="tableTitle">
    <h3 id="tableTitle">Insert Table</h3>
    <div class="row">
      <label>Rows</label><input type="number" id="tRows" min="1" max="40" value="3">
      <label>Cols</label><input type="number" id="tCols" min="1" max="20" value="3">
      <label>Align</label>
      <select id="tAlign">
        <option value="c">center</option>
        <option value="l">left</option>
        <option value="r">right</option>
      </select>
      <label>Borders</label>
      <select id="tBorders">
        <option value="none">none</option>
        <option value="outer">outer</option>
        <option value="all">all</option>
      </select>
    </div>
    <div class="preview" id="tablePrev"></div>
    <div class="actions">
      <button class="menu-button" id="tCancel">Cancel</button>
      <button class="menu-button" id="tInsert">Insert</button>
    </div>
  </div>
</div>

<!-- Macros editor -->
<div class="modal-backdrop" id="macrosModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="macrosTitle">
    <h3 id="macrosTitle">Shortcuts (\newcommand)</h3>
    <div class="row" style="flex-direction:column; align-items:stretch;">
      <textarea id="macrosText" style="width:100%;height:220px;font-family:monospace;"></textarea>
      <small style="opacity:.8;margin-top:.5rem;">
        Paste lines like: <code>\newcommand{\RR}{\mathbb{R}}</code> or <code>\newcommand{\vect}[1]{\mathbf{#1}}</code>
      </small>
    </div>
    <div class="actions">
      <button class="menu-button" id="macrosReset">Reset</button>
      <button class="menu-button" id="macrosCancel">Cancel</button>
      <button class="menu-button" id="macrosSave">Save</button>
    </div>
  </div>
</div>


<script>
/* ===== Config ===== */
const EXPORT_SCALE = 8; // PNG scale factor

/* ===== Elements ===== */
const editor   = document.getElementById('editor');
const gutter   = document.getElementById('gutter');
const overlay  = document.getElementById('overlay');
const preview  = document.getElementById('preview');
const divider  = document.getElementById('divider');

const modeToggle = document.getElementById('modeToggle');
const modeLabel  = document.getElementById('modeLabel');
const modeDesc   = document.getElementById('modeDesc');
const darkToggle = document.getElementById('darkToggle');

const pngBtn     = document.getElementById('pngBtn');
// const pdfBtn  = document.getElementById('pdfBtn'); // PDF disabled
const clearBtn   = document.getElementById('clearBtn');
const shareBtn   = document.getElementById('shareBtn');

const measure  = document.getElementById('measure');

const snippetsMenu = document.getElementById('snippetsMenu');
const snippetsBtn  = document.getElementById('snippetsBtn');
document.getElementById('openMatrixGen').addEventListener('click', ()=>{ snippetsMenu.classList.remove('open'); openMatrix(); });
document.getElementById('openTableGen').addEventListener('click', ()=>{ snippetsMenu.classList.remove('open'); openTable(); });

/* ===== Matrix modal wires ===== */
const matrixModal = document.getElementById('matrixModal');
const mRows=document.getElementById('mRows'), mCols=document.getElementById('mCols'), mType=document.getElementById('mType');
const matrixPrev=document.getElementById('matrixPrev');
document.getElementById('mCancel').addEventListener('click', ()=>matrixModal.classList.remove('show'));
document.getElementById('mInsert').addEventListener('click', insertMatrix);

/* ===== Table modal wires ===== */
const tableModal = document.getElementById('tableModal');
const tRows=document.getElementById('tRows'), tCols=document.getElementById('tCols'), tAlign=document.getElementById('tAlign'), tBorders=document.getElementById('tBorders');
const tablePrev=document.getElementById('tablePrev');
document.getElementById('tCancel').addEventListener('click', ()=>tableModal.classList.remove('show'));
document.getElementById('tInsert').addEventListener('click', insertTable);

/* ===== Shortcuts (macros) ===== */
const macrosBtn   = document.getElementById('macrosBtn');
const macrosModal = document.getElementById('macrosModal');
const macrosText  = document.getElementById('macrosText');
const macrosSave  = document.getElementById('macrosSave');
const macrosCancel= document.getElementById('macrosCancel');
const macrosReset = document.getElementById('macrosReset');

macrosBtn.addEventListener('click', () => {
  macrosText.value = serializeMacros(MACROS);
  macrosModal.classList.add('show');
});
macrosCancel.addEventListener('click', ()=> macrosModal.classList.remove('show'));
macrosReset.addEventListener('click', () => {
  MACROS = {...DEFAULT_MACROS};
  try { localStorage.setItem(LS_MACROS, JSON.stringify(MACROS)); } catch(e){}
  macrosText.value = serializeMacros(MACROS);
  render();
});

macrosSave.addEventListener('click', (e) => {
  e.preventDefault();
  try {
    const raw = macrosText.value;
    const parsed = parseNewcommands(stripLatexComments(raw));
    if (!parsed || Object.keys(parsed).length === 0) {
      alert('Nothing to save. Add lines like \\newcommand{\\SO}{\\operatorname{SO}}');
      return;
    }
    // Merge over the current set (update/extend)
    MACROS = { ...MACROS, ...parsed };
    try { localStorage.setItem(LS_MACROS, JSON.stringify(MACROS)); } catch (storageErr) {}
    try { macrosText.value = serializeMacros(MACROS); } catch (serr) {}
    render();
    requestAnimationFrame(() => macrosModal.classList.remove('show'));
  } catch (err) {
    console.error('Save handler error:', err);
    alert('Unexpected error while saving shortcuts. Check console for details.');
  }
});

// Close modals on backdrop/Esc
matrixModal.addEventListener('click', (e) => { if (e.target === matrixModal) matrixModal.classList.remove('show'); });
tableModal.addEventListener('click',  (e) => { if (e.target === tableModal)  tableModal.classList.remove('show'); });
macrosModal.addEventListener('click', (e) => { if (e.target === macrosModal) macrosModal.classList.remove('show'); });

window.addEventListener('keydown', (e) => {
  if (e.key !== 'Escape') return;
  if (matrixModal.classList.contains('show')) { matrixModal.classList.remove('show'); return; }
  if (tableModal.classList.contains('show'))  { tableModal.classList.remove('show');  return; }
  if (macrosModal.classList.contains('show'))  { macrosModal.classList.remove('show');  return; }
});

/* ===== Macros helpers ===== */
function serializeMacros(macros){
  const lines = [];
  for (const [name, body] of Object.entries(macros)){
    const n = maxArgCount(body);
    const arity = n>0 ? `[${n}]` : '';
    lines.push(`\\newcommand{${name}}${arity}{${body}}`);
  }
  return lines.join('\n');
}
function normalizeMacros(obj){
  const out = {};
  for (const [k,v] of Object.entries(obj || {})){
    out[k] = Array.isArray(v) ? String(v[0]) : String(v);
  }
  return out;
}
function maxArgCount(s){
  let m=0, r=/#([1-9])/g, a;
  while ((a=r.exec(s))!==null) m = Math.max(m, parseInt(a[1],10));
  return m;
}
function parseNewcommands(text){
  const out = {};
  const head = /(\\(?:re)?newcommand)\s*\{\s*(\\[A-Za-z@]+)\s*\}\s*(?:\[(\d)\])?\s*\{/g;
  let m, any = false;
  while ((m = head.exec(text)) !== null){
    const name = m[2];
    // parse body with brace-depth
    let i = head.lastIndex, depth = 1;
    while (i < text.length && depth > 0){
      const ch = text[i++];
      if (ch === '\\') { i++; continue; }
      if (ch === '{') depth++;
      else if (ch === '}') depth--;
    }
    const body = text.slice(head.lastIndex, i - 1).trim();
    out[name] = body; any = true; head.lastIndex = i;
  }
  return any ? out : null;
}
function stripLatexComments(s){ return s.replace(/(^|[^\\])%.*$/gm, '$1'); }

/* ===== State + storage ===== */
let mode = 'mixed';
const LS_CONTENT = 'latexlab.content.v5';
const LS_DARK    = 'latexlab.dark.v5';
const LS_SPLITPX = 'latexlab.splitpx.v5';
const LS_MODE    = 'latexlab.mode.v1';
const LS_MACROS  = 'latexlab.macros.v1';

const DEFAULT_MACROS = {
  "\\abs":  "\\left|#1\\right|",
  "\\norm": "\\left\\lVert#1\\right\\rVert",
};
let MACROS = {...DEFAULT_MACROS};

/* ===== Wrap guides (gutter/overlay) ===== */
function getPx(val){ return parseFloat(val) || 0; }
function lineHeightPx(){
  const cs = getComputedStyle(editor);
  if (cs.lineHeight.endsWith('px')) return parseFloat(cs.lineHeight);
  return getPx(cs.fontSize) * 1.5;
}
function syncOverlayAndMirror(){
  const cs = getComputedStyle(editor);
  overlay.style.paddingTop    = cs.paddingTop;
  overlay.style.paddingBottom = cs.paddingBottom;
  overlay.style.paddingLeft   = '0';
  overlay.style.paddingRight  = '0';
  measure.style.fontFamily    = cs.fontFamily;
  measure.style.fontSize      = cs.fontSize;
  measure.style.lineHeight    = cs.lineHeight;
  measure.style.letterSpacing = cs.letterSpacing;
  const innerW = editor.clientWidth - parseFloat(cs.paddingLeft||0) - parseFloat(cs.paddingRight||0);
  measure.style.width = innerW + 'px';
}
function visualLineHeightPx(){
  measure.textContent = 'M';
  let h = measure.getBoundingClientRect().height;
  measure.textContent = '';
  if (!h || h < 1) h = parseFloat(getComputedStyle(editor).lineHeight) || 20;
  return h;
}
function rebuildGuidesWrapping(){
  syncOverlayAndMirror();
  gutter.innerHTML = '';
  overlay.innerHTML = '';
  const lh = visualLineHeightPx();
  const lines = editor.value.split('\n');
  const stripeBG = getComputedStyle(document.body).getPropertyValue('--stripe-light');

  for (let i = 0; i < lines.length; i++){
    measure.textContent = lines[i] || ' ';
    const h = Math.max(lh, measure.getBoundingClientRect().height || lh);

    const gn = document.createElement('div');
    gn.className = 'ln';
    gn.textContent = i + 1;
    gn.style.height = h + 'px';
    gn.style.lineHeight = h + 'px';
    gutter.appendChild(gn);

    const rows = Math.max(1, Math.ceil(h / lh));
    const bg = (i % 2) ? stripeBG : 'transparent';
    for (let r = 0; r < rows; r++){
      const stripe = document.createElement('div');
      stripe.className = 'row';
      const last = (r === rows - 1);
      const stripeH = last ? (h - (rows - 1) * lh) : lh;
      stripe.style.height = stripeH + 'px';
      stripe.style.backgroundColor = bg;
      overlay.appendChild(stripe);
    }
  }
  measure.textContent = '';
}

/* ===== Rendering ===== */
function render(){
  preview.innerHTML = '';
  const lines = editor.value.split('\n');

  if (mode === 'classic'){
    for (const line of lines){
      if (line.trim() === '') { preview.appendChild(document.createElement('br')); continue; }
      const div = document.createElement('div');
      try { katex.render(line, div, {throwOnError:false, displayMode:true, macros: MACROS}); }
      catch (e){ div.textContent = e.message; }
      preview.appendChild(div);
    }
  } else {
    for (const line of lines){
      if (line.trim() === '') { preview.appendChild(document.createElement('br')); continue; }
      const wrap = document.createElement('div');
      wrap.textContent = line;
      renderMathInElement(wrap, {
        delimiters: [
          {left:"$$", right:"$$", display:true},
          {left:"$",  right:"$",  display:false}
        ],
        throwOnError:false,
        macros: MACROS
      });
      preview.appendChild(wrap);
    }
  }
  rebuildGuidesWrapping();
}

/* ===== Scroll sync (editor → preview) ===== */
editor.addEventListener('scroll', () => {
  const maxE = Math.max(1, editor.scrollHeight - editor.clientHeight);
  const ratio = editor.scrollTop / maxE;
  gutter.scrollTop  = editor.scrollTop;
  overlay.scrollTop = editor.scrollTop;
  preview.scrollTop = ratio * Math.max(0, (preview.scrollHeight - preview.clientHeight));
});

/* ===== Input / Mode / Dark ===== */
editor.addEventListener('input', () => {
  render();
  try { localStorage.setItem(LS_CONTENT, editor.value); } catch(e){}
});
modeToggle.addEventListener('change', () => {
  mode = modeToggle.checked ? 'classic' : 'mixed';
  modeLabel.textContent = (mode === 'classic') ? 'Classic' : 'Mixed';
  modeDesc.textContent  = (mode === 'classic')
    ? 'Classic: each new line is rendered as display math.'
    : 'Mixed: type text with $inline$ and $$display$$ math.';
  editor.placeholder = (mode === 'classic')
    ? 'Type lines of pure TeX; each line renders as display math'
    : 'Type text with $inline$ and $$display$$ math';
  document.body.classList.toggle('mixed',   mode === 'mixed');
  document.body.classList.toggle('classic', mode === 'classic');
  try { localStorage.setItem(LS_MODE, mode); } catch(e) {}
  render();
});
darkToggle.addEventListener('change', () => {
  const isDark = darkToggle.checked;
  document.body.classList.toggle('dark', isDark);
  try { localStorage.setItem(LS_DARK, isDark ? '1' : '0'); } catch(e) {}
  render();
});

/* ===== Tab indent/outdent in editor ===== */
editor.addEventListener('keydown', (e) => {
  if (e.key !== 'Tab') return;
  e.preventDefault();

  const start = editor.selectionStart, end = editor.selectionEnd;
  const val = editor.value;
  const lineStart = val.lastIndexOf('\n', start - 1) + 1;

  if (!e.shiftKey) {
    if (start === end) {
      editor.setRangeText('  ', start, end, 'end');
      editor.selectionStart = editor.selectionEnd = start + 2;
    } else {
      const block = val.slice(lineStart, end).replace(/^/gm, '  ');
      editor.setRangeText(block, lineStart, end, 'end');
      const delta = block.length - (end - lineStart);
      editor.selectionStart = start + 2;
      editor.selectionEnd = end + delta;
    }
  } else {
    const re = /^ {1,2}/gm;
    const before = val.slice(lineStart, end);
    const block = before.replace(re, '');
    const removed = (before.match(re) || []).reduce((a,s)=>a+s.length,0);
    editor.setRangeText(block, lineStart, end, 'end');
    editor.selectionStart = Math.max(lineStart, start - Math.min(2, removed));
    editor.selectionEnd   = Math.max(lineStart, end   - removed);
  }
  render();
  try { localStorage.setItem(LS_CONTENT, editor.value); } catch(e){}
});

function triggerDownload(url, filename){
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.rel = 'noopener';
  document.body.appendChild(a);
  a.click();
  a.remove();
}

function saveCanvasPNG(canvas, filename){
  return new Promise((resolve) => {
    if (canvas.toBlob) {
      canvas.toBlob((blob) => {
        if (!blob) { resolve(false); return; }
        const blobUrl = URL.createObjectURL(blob);
        triggerDownload(blobUrl, filename);
        setTimeout(() => URL.revokeObjectURL(blobUrl), 1500);
        resolve(true);
      }, 'image/png');
    } else {
      const dataUrl = canvas.toDataURL('image/png');
      triggerDownload(dataUrl, filename);
      resolve(true);
    }
  });
}

/* ===== Helpers ===== */
// Builds a <style> element with the font-face rules the snapshot needs.
function buildFontFaceStyleEl() {
  const css = [
    '@font-face{font-family:KaTeX_Main; src:url(https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_Main-Regular.woff2) format("woff2"); font-weight:400; font-style:normal; font-display:swap;}',
    '@font-face{font-family:KaTeX_Main; src:url(https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_Main-Italic.woff2) format("woff2"); font-weight:400; font-style:italic; font-display:swap;}',
    '@font-face{font-family:KaTeX_Math; src:url(https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_Math-Italic.woff2) format("woff2"); font-weight:400; font-style:italic; font-display:swap;}',
    '@font-face{font-family:KaTeX_AMS; src:url(https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_AMS-Regular.woff2) format("woff2"); font-weight:400; font-style:normal; font-display:swap;}',
    '@font-face{font-family:KaTeX_Size1; src:url(https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_Size1-Regular.woff2) format("woff2"); font-weight:400; font-style:normal; font-display:swap;}',
    '@font-face{font-family:KaTeX_Size2; src:url(https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_Size2-Regular.woff2) format("woff2"); font-weight:400; font-style:normal; font-display:swap;}',
    /* Computer Modern serif for Mixed-mode plain text */
    '@font-face{font-family:"CMU Serif"; src:url(https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-500-roman.woff2) format("woff2"); font-weight:500; font-style:normal; font-display:swap;}',
  ].join('\n');

  const el = document.createElement('style');
  el.type = 'text/css';
  el.appendChild(document.createTextNode(css));
  return el;
}

function isMeaningfulLine(el) {
  if (!el) return false;
  if (el.querySelector && el.querySelector('.katex')) return true;
  if ((el.textContent || '').trim().length > 0) return true;
  return false;
}
function trimLeadingTrailingBlanks(containerEl) {
  const kids = Array.from(containerEl.children);
  let i = 0, j = kids.length - 1;
  while (i <= j && !isMeaningfulLine(kids[i])) i++;
  while (j >= i && !isMeaningfulLine(kids[j])) j--;
  for (let k = 0; k < i; k++) containerEl.removeChild(kids[k]);
  for (let k = kids.length - 1; k > j; k--) containerEl.removeChild(kids[k]);
}

/* Preload critical fonts to keep html-to-image letter metrics correct */
async function preloadFonts() {
  const probe = document.createElement('div');
  Object.assign(probe.style, {
    position:'fixed', left:'-9999px', top:'0', opacity:'0', pointerEvents:'none'
  });
  const families = [
    '"CMU Serif"',
    'KaTeX_Main', 'KaTeX_Math', 'KaTeX_AMS', 'KaTeX_SansSerif',
    'KaTeX_Script', 'KaTeX_Fraktur', 'KaTeX_Typewriter', 'KaTeX_Caligraphic'
  ];
  probe.innerHTML = families.map(f => `<span style="font-family:${f};font-weight:400">A1</span>`).join('');
  document.body.appendChild(probe);
  try {
    if (document.fonts && document.fonts.ready) {
      await Promise.race([document.fonts.ready, new Promise(r=>setTimeout(r, 800))]);
    } else {
      await new Promise(r=>setTimeout(r, 300));
    }
  } catch {}
  probe.remove();
}

/* Convert data URL to Blob (Safari-friendly) */
function dataUrlToBlob(dataUrl) {
  const [meta, b64] = dataUrl.split(',');
  const mime = (meta.match(/data:([^;]+)/) || [, 'image/png'])[1];
  const bin = atob(b64);
  const u8  = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) u8[i] = bin.charCodeAt(i);
  return new Blob([u8], { type: mime });
}

const raf = () => new Promise(r => requestAnimationFrame(r));
async function settleLayout() {
  await raf(); await raf(); // two paints
  if (document.fonts && document.fonts.ready) {
    try { await Promise.race([document.fonts.ready, new Promise(r=>setTimeout(r, 500))]); } catch {}
  }
}

/* ===== PNG export (html-to-image primary, fonts preserved) ===== */
async function exportPNG() {
  const bg = getComputedStyle(preview).backgroundColor || getComputedStyle(document.body).backgroundColor;

  // Build sandbox ON viewport (opacity 0) to avoid WebKit blanking
  const sandbox = document.createElement('div');
  Object.assign(sandbox.style, {
    position: 'fixed',
    left: '0',
    top:  '0',
    opacity: '0',
    pointerEvents: 'none',
    display: 'inline-block',
    background: bg
  });

  // ⬇️ Inject @font-face rules so the snapshot can resolve KaTeX/CMU fonts
  sandbox.appendChild(buildFontFaceStyleEl());

  // ⬇️ Force WebKit to use currentColor for text during foreignObject render
  const webkitFillFix = document.createElement('style');
  webkitFillFix.textContent = `
    *, *::before, *::after { -webkit-text-fill-color: currentColor !important; }
  `;
  sandbox.appendChild(webkitFillFix);

  // Wrapper controls padding/crop
  const wrapper = document.createElement('div');
  wrapper.style.display = 'inline-block';
  wrapper.style.whiteSpace = 'pre-wrap';
  wrapper.style.tabSize = '4';

  // --- Bake DPI into typography (kerning-safe) ---
  {
    const cps = getComputedStyle(preview);

    // base metrics from preview
    const baseSizePx = parseFloat(cps.fontSize) || 16;
    const baseLHpx   = cps.lineHeight.endsWith('px')
      ? parseFloat(cps.lineHeight)
      : baseSizePx * 1.5;

    // scale we’ll bake into text metrics instead of device pixelRatio
    const SCALE = Math.max(1, EXPORT_SCALE | 0);

    // essential inherited styles
    wrapper.style.fontFamily          = cps.fontFamily;
    const textColor = cps.color || '#111';
    wrapper.style.color           = textColor;
    wrapper.style.webkitTextFillColor = textColor;   // <- Safari snapshot fix
    wrapper.style.backgroundColor     = cps.backgroundColor;  // ← add this
    // IMPORTANT: normalize whitespace so incidental spaces don’t balloon
    wrapper.style.whiteSpace          = 'normal';
    wrapper.style.tabSize             = '4';

    // kerning/shaping defaults
    wrapper.style.fontKerning         = 'normal';
    wrapper.style.fontFeatureSettings = '"kern" 1';
    wrapper.style.textRendering       = 'optimizeLegibility';

    // bake scale into metrics (this preserves kerning)
    wrapper.style.fontSize   = (baseSizePx * SCALE) + 'px';
    wrapper.style.lineHeight = (baseLHpx   * SCALE) + 'px';
  }

  // Padding around snapshot
  const isClassic = (mode === 'classic');
  const padTop    = isClassic ? 20 : 20;
  const padBottom = isClassic ? 20 : 20;
  const padSides  = 20;
  wrapper.style.padding = `${padTop}px ${padSides}px ${padBottom}px ${padSides}px`;

  // Clone preview children into wrapper
  const clone = preview.cloneNode(true);
  while (clone.firstChild) wrapper.appendChild(clone.firstChild);

  // Normalize KaTeX block spacing in snapshot
  wrapper.querySelectorAll('.katex-display').forEach(el => {
    el.style.marginTop = '0';
    el.style.marginBottom = '0';
  });
  wrapper.querySelectorAll('img, svg, canvas').forEach(el => {
    el.style.display = 'inline-block';
    el.style.verticalAlign = 'baseline';
  });

  // Trim leading/trailing blank lines
  trimLeadingTrailingBlanks(wrapper);

  // Bail if empty
  const meaningful = Array.from(wrapper.children).some(el =>
    (el.querySelector && el.querySelector('.katex')) || ((el.textContent || '').trim().length > 0)
  );
  if (!meaningful) { alert('Nothing to export yet — add some text or math first.'); return; }

  sandbox.appendChild(wrapper);
  document.body.appendChild(sandbox);

  try {
    await preloadFonts();
    await settleLayout();

    // Measure AFTER scaling font metrics
    const rect = wrapper.getBoundingClientRect();
    const w = Math.ceil(rect.width);
    const h = Math.ceil(rect.height);
    if (w <= 0 || h <= 0) throw new Error('zero-size after layout');

    if (window.htmlToImage?.toPng) {
      const url = await window.htmlToImage.toPng(wrapper, {
        pixelRatio: 2,             // render 1:1; we already scaled CSS text
        backgroundColor: bg,
        cacheBust: true,
        width:  w,
        height: h,
        fetchRequestInit: { mode: 'cors', credentials: 'omit' },
        style: { transform: 'none' }
      });
      const blobUrl = URL.createObjectURL(dataUrlToBlob(url));
      triggerDownload(blobUrl, stampName('png'));
      setTimeout(() => URL.revokeObjectURL(blobUrl), 1500);
      return;
    }

    // html2canvas fallback (also 1:1)
    const canvas = await html2canvas(wrapper, {
      backgroundColor: bg,
      scale: 1,                  // no device upscaling
      width: w,
      height: h,
      useCORS: true,
      foreignObjectRendering: false
    });
    await saveCanvasPNG(canvas, stampName('png'));
  } catch (err) {
    console.warn('Export failed, attempting html2canvas fallback:', err);
    try {
      const canvas = await html2canvas(sandbox, {
        backgroundColor: bg,
        scale: 1,
        useCORS: true,
        foreignObjectRendering: false
      });
      await saveCanvasPNG(canvas, stampName('png'));
    } catch (err2) {
      console.error('Fallback export failed:', err2);
      alert('PNG export failed. (See console for details.)');
    }
  } finally {
    document.body.removeChild(sandbox);
  }
}

/* ===== Common utils ===== */
function stampName(ext){
  const d = new Date();
  const pad = n => String(n).padStart(2,'0');
  return `latex-lab-${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}-${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}.${ext}`;
}

/* ===== Export buttons ===== */
pngBtn.addEventListener('click', exportPNG);

/* ===== Clear ===== */
clearBtn.addEventListener('click', () => {
  if (!confirm('Clear editor and saved text?')) return;
  editor.value = '';
  try { localStorage.removeItem(LS_CONTENT); } catch(e){}
  // also clear the state hash from the URL
  try { history.replaceState(null, '', location.pathname + location.search); } catch(e){}
  render();
});

/* ===== Resizable split (persisted) ===== */
(function makeResizable(){
  let dragging=false, startX=0, startLeft=0;
  const left = document.getElementById('leftPane');
  const container = document.querySelector('.container');

  divider.addEventListener('mousedown', (e) => {
    dragging = true; startX = e.clientX;
    startLeft = left.getBoundingClientRect().width;
    document.body.style.cursor = 'col-resize';
    e.preventDefault();
  });
  window.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    let newLeft = startLeft + (e.clientX - startX);
    const min = 240, max = container.clientWidth - 240;
    newLeft = Math.max(min, Math.min(max, newLeft));
    left.style.flex = `0 0 ${newLeft}px`;
    preview.style.flex = `1 1 auto`;
    try { localStorage.setItem(LS_SPLITPX, String(newLeft)); } catch(e){}
  });
  window.addEventListener('mouseup', () => { dragging=false; document.body.style.cursor=''; });

  try {
    const savedPx = parseFloat(localStorage.getItem(LS_SPLITPX));
    if (!Number.isNaN(savedPx)) {
      left.style.flex = `0 0 ${savedPx}px`; preview.style.flex = `1 1 auto`;
    }
  } catch(e){}
})();

// Double-click divider to reset split
divider.addEventListener('dblclick', () => {
  const cw = document.querySelector('.container').clientWidth;
  const left = document.getElementById('leftPane');
  const mid = Math.max(240, Math.min(cw - 240, cw / 2));
  left.style.flex = `0 0 ${mid}px`;
  preview.style.flex = `1 1 auto`;
  try { localStorage.setItem(LS_SPLITPX, String(mid)); } catch(e){}
});

/* ===== Snippets ===== */
function openMatrix(){ updateMatrixPreview(); matrixModal.classList.add('show'); }
function openTable(){ updateTablePreview(); tableModal.classList.add('show'); }

/* Matrix builder (single-line insert) */
function matrixPreviewText(r,c,type){
  const rows = Array.from({length:r},()=> Array.from({length:c},()=> '◻').join(' & ')).join(' \\\\ ');
  return `\\begin{${type}} ${rows} \\end{${type}}`;
}
function matrixInsertText(r,c,type){
  const rows = Array.from({length:r},()=> Array.from({length:c},()=> '').join(' & ')).join(' \\\\ ');
  return `\\begin{${type}} ${rows} \\end{${type}}`;
}
function updateMatrixPreview(){
  const r = clampInt(mRows.value,1,20), c = clampInt(mCols.value,1,20);
  matrixPrev.textContent = matrixPreviewText(r,c,mType.value);
}
function insertMatrix(){
  const r = clampInt(mRows.value,1,20), c = clampInt(mCols.value,1,20);
  const core = matrixInsertText(r,c,mType.value);
  const inMixed = document.body.classList.contains('mixed');
  const snippet = inMixed ? `$$${core}$$` : core;
  insertAtCursor(snippet);
  matrixModal.classList.remove('show');
}

/* Cases snippet */
document.getElementById('insertCases').addEventListener('click', insertCases);
function insertCases(){
  const core = '\\begin{cases}  &  \\\\  &  \\end{cases}';
  const inMixed = document.body.classList.contains('mixed');
  const snippet = inMixed ? `$$${core}$$` : core;
  insertAtCursor(snippet);
  snippetsMenu.classList.remove('open');
}
mRows.addEventListener('input', updateMatrixPreview);
mCols.addEventListener('input', updateMatrixPreview);
mType.addEventListener('change', updateMatrixPreview);

/* Table (KaTeX-friendly via array) */
function arrayColSpec(align, cols, borders){
  let spec = align.repeat(cols);
  if (borders === 'all')  spec = '|' + spec.split('').join('|') + '|';
  else if (borders === 'outer') spec = '|' + spec + '|';
  return spec;
}
function tablePreviewText(r,c,align,borders){
  const spec = arrayColSpec(align,c,borders);
  const row = () => Array.from({length:c},()=> '◻').join(' & ');
  const top = (borders==='none') ? '' : '\\hline ';
  const bot = (borders==='none') ? '' : '\\hline ';
  let body = '';
  for(let i=0;i<r;i++) body += row() + ' \\\\ ';
  return `\\begin{array}{${spec}} ${top}${body}${bot}\\end{array}`;
}
function tableInsertText(r,c,align,borders){
  const spec = arrayColSpec(align,c,borders);
  const row = () => Array.from({length:c},()=> '').join(' & ');
  const top = (borders==='none') ? '' : '\\hline ';
  const bot = (borders==='none') ? '' : '\\hline ';
  let body = '';
  for(let i=0;i<r;i++) body += row() + ' \\\\ ';
  return `\\begin{array}{${spec}} ${top}${body}${bot}\\end{array}`;
}
function updateTablePreview(){
  const r=clampInt(tRows.value,1,40), c=clampInt(tCols.value,1,20);
  tablePrev.textContent = tablePreviewText(r,c,tAlign.value,tBorders.value);
}
function insertTable(){
  const r=clampInt(tRows.value,1,40), c=clampInt(tCols.value,1,20);
  const core = tableInsertText(r,c,tAlign.value,tBorders.value);
  const inMixed = document.body.classList.contains('mixed');
  const snippet = inMixed ? `$$${core}$$` : core;
  insertAtCursor(snippet);
  tableModal.classList.remove('show');
}
tRows.addEventListener('input', updateTablePreview);
tCols.addEventListener('input', updateTablePreview);
tAlign.addEventListener('change', updateTablePreview);
tBorders.addEventListener('change', updateTablePreview);

/* Small utils */
function clampInt(v,min,max){ v=parseInt(v||min,10); return Math.max(min,Math.min(max,isNaN(v)?min:v)); }

/* Insert helper */
function insertAtCursor(text){
  const el = editor, start = el.selectionStart, end = el.selectionEnd;
  el.value = el.value.slice(0,start) + text + el.value.slice(end);
  el.selectionStart = el.selectionEnd = start + text.length;
  el.focus();
  render();
  try { localStorage.setItem(LS_CONTENT, el.value); } catch(e){}
}

/* ===== Share (URL hash) ===== */
function encodeStateToHash(){
  const leftPx = document.getElementById('leftPane').getBoundingClientRect().width;
  const state = { t: editor.value, m: (mode==='classic')?1:0, d: darkToggle.checked?1:0, s: leftPx, x: MACROS };
  const b64 = btoa(unescape(encodeURIComponent(JSON.stringify(state))));
  location.hash = 'state=' + b64;
  return location.href;
}
function tryLoadStateFromHash(){
  const m = location.hash.match(/state=([^&]+)/); if(!m) return false;
  try{
    const st = JSON.parse(decodeURIComponent(escape(atob(m[1]))));
    if (typeof st.t === 'string') editor.value = st.t;
    modeToggle.checked = (st.m===1); mode = modeToggle.checked ? 'classic' : 'mixed';
    document.body.classList.toggle('dark', st.d===1); darkToggle.checked = (st.d===1);
    if (typeof st.s === 'number' && !Number.isNaN(st.s)){
      const left = document.getElementById('leftPane');
      left.style.flex = `0 0 ${st.s}px`; preview.style.flex = `1 1 auto`;
      try { localStorage.setItem(LS_SPLITPX, String(st.s)); } catch(e){}
    }
    if (st.x && typeof st.x === 'object') {
      MACROS = normalizeMacros(st.x);
      try { localStorage.setItem(LS_MACROS, JSON.stringify(MACROS)); } catch(e){}
    }
    modeLabel.textContent = (mode === 'classic') ? 'Classic' : 'Mixed';
    modeDesc.textContent  = (mode === 'classic')
      ? 'Classic: each new line is rendered as display math.'
      : 'Mixed: type text with $inline$ and $$display$$ math.';
    editor.placeholder = (mode === 'classic')
      ? 'Type lines of pure TeX; each line renders as display math'
      : 'Type text with $inline$ and $$display$$ math';
    return true;
  }catch(e){ return false; }
}
shareBtn.addEventListener('click', async () => {
  const url = encodeStateToHash();
  try { await navigator.clipboard.writeText(url);
    shareBtn.textContent = '✅ Copied!'; setTimeout(()=> shareBtn.textContent = '🔗 Share link', 1200);
  } catch(e){ prompt('Copy this link:', url); }
});

/* Close Insert menu when clicking elsewhere */
snippetsBtn.addEventListener('click', () => snippetsMenu.classList.toggle('open'));
document.addEventListener('click', (e) => { if (!snippetsMenu.contains(e.target)) snippetsMenu.classList.remove('open'); });

/* ===== Init ===== */
window.addEventListener('load', () => {
  const loadedFromHash = tryLoadStateFromHash();

  if (!loadedFromHash){
    try { const saved = localStorage.getItem(LS_CONTENT); if (saved != null) editor.value = saved; } catch(e){}
    try { const dark = localStorage.getItem(LS_DARK)==='1'; darkToggle.checked=dark; document.body.classList.toggle('dark', dark);} catch(e){}
    try {
      const savedPx = parseFloat(localStorage.getItem(LS_SPLITPX));
      if (!Number.isNaN(savedPx)) {
        const left=document.getElementById('leftPane');
        left.style.flex=`0 0 ${savedPx}px`; preview.style.flex=`1 1 auto`;
      }
    } catch(e){}
    try {
      const savedMode = localStorage.getItem(LS_MODE);
      if (savedMode === 'classic' || savedMode === 'mixed')
        modeToggle.checked = (savedMode === 'classic');
    } catch(e){}
    try {
      const raw = localStorage.getItem(LS_MACROS);
      if (raw) {
        const obj = JSON.parse(raw);
        MACROS = normalizeMacros(obj);
      }
    } catch(e){}
  }

  mode = modeToggle.checked ? 'classic' : 'mixed';
  document.body.classList.toggle('mixed',   mode === 'mixed');
  document.body.classList.toggle('classic', mode === 'classic');

  modeLabel.textContent = (mode === 'classic') ? 'Classic' : 'Mixed';
  modeDesc.textContent  = (mode === 'classic')
    ? 'Classic: each new line is rendered as display math.'
    : 'Mixed: type text with $inline$ and $$display$$ math.';
  editor.placeholder = (mode === 'classic')
    ? 'Type lines of pure TeX; each line renders as display math'
    : 'Type text with $inline$ and $$display$$ math';

  syncOverlayAndMirror();
  render();
  editor.focus();
});
window.addEventListener('resize', () => { syncOverlayAndMirror(); rebuildGuidesWrapping(); });

/* ===== First-time Welcome Pop (with URL overrides) ===== */
(function setupWelcomePop() {
  const LS_WELCOME = 'latexlab.welcome.v1';
  function getQueryParam(name) { return new URLSearchParams(window.location.search).get(name); }
  function hashHasWelcome() { return /(^|[#&])welcome(=1|$)/i.test(location.hash); }
  function shouldForceShow() {
    const q = (getQueryParam('welcome') || '').toLowerCase();
    if (q === '1' || q === 'true' || q === 'show') return true;
    if (hashHasWelcome()) return true;
    return false;
  }
  function shouldResetFlag() {
    const q = (getQueryParam('welcome') || '').toLowerCase();
    return q === 'reset' || q === 'clear';
  }
  function safeGetItem(k) { try { return localStorage.getItem(k); } catch (e) { return null; } }
  function safeSetItem(k, v){ try { localStorage.setItem(k, v); } catch (e) {} }
  function safeRemoveItem(k){ try { localStorage.removeItem(k); } catch (e) {} }

  function showWelcome() {
    const el  = document.getElementById('welcomePop');
    const btn = document.getElementById('welcomeClose');
    if (!el || !btn) return;
    el.style.display = 'block';
    setTimeout(() => { try { btn.focus(); } catch(e){} }, 0);
    btn.addEventListener('click', () => {
      el.style.display = 'none';
      safeSetItem(LS_WELCOME, '1');
    }, { once: true });
  }

  function init() {
    if (shouldResetFlag()) safeRemoveItem(LS_WELCOME);
    const forced = shouldForceShow();
    const seen   = !!safeGetItem(LS_WELCOME);
    if (forced || !seen) {
      showWelcome();
      if (forced) return;
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init, { once: true });
  } else {
    init();
  }

  // Close welcome with Esc
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      const el = document.getElementById('welcomePop');
      if (el && el.style.display === 'block') {
        el.style.display = 'none';
        try { localStorage.setItem(LS_WELCOME, '1'); } catch(e){}
      }
    }
  });
})();

/* ===== IDE-like pair wrapping + smart skip over closers ===== */
editor.addEventListener('keydown', (e) => {
  const OPEN_TO_CLOSE = { '(': ')', '{': '}', '[': ']', '$': '$' };
  const CLOSERS = new Set(Object.values(OPEN_TO_CLOSE));

  const start = editor.selectionStart;
  const end   = editor.selectionEnd;
  const hasSel = start !== end;
  const nextChar = editor.value[end] || '';

  if (CLOSERS.has(e.key) && !hasSel && nextChar === e.key) {
    e.preventDefault();
    editor.selectionStart = editor.selectionEnd = end + 1;
    return;
  }

  if (e.key in OPEN_TO_CLOSE) {
    e.preventDefault();

    const open  = e.key;
    const close = OPEN_TO_CLOSE[open];

    if (!hasSel && nextChar === close && CLOSERS.has(e.key)) {
      editor.selectionStart = editor.selectionEnd = end + 1;
      return;
    }

    const before   = editor.value.slice(0, start);
    const selected = editor.value.slice(start, end);
    const after    = editor.value.slice(end);

    editor.value = before + open + selected + close + after;

    if (hasSel) {
      editor.selectionStart = start + 1;
      editor.selectionEnd   = end   + 1;
    } else {
      editor.selectionStart = editor.selectionEnd = start + 1;
    }

    render();
    try { localStorage.setItem(LS_CONTENT, editor.value); } catch (_) {}
    return;
  }
});
</script>

<!-- First-time pop-under -->
<div id="welcomePop" class="welcome-pop" role="dialog" aria-modal="false" aria-labelledby="welcomeTitle">
  <div class="welcome-content">
    <h3 id="welcomeTitle">👋 Welcome to LaTeX Lab</h3>
    <p>
      This is an in-browser LaTeX playground with live KaTeX rendering.
      Type plain text and math, switch between <b>Mixed</b> mode (text + $inline$ / $$display$$ math)
      or <b>Classic</b> mode (every line renders as math), and export high-resolution PNGs.
      Dark mode and custom shortcuts are supported too.
    </p>
    <button id="welcomeClose">Got it</button>
  </div>
</div>

</body>
</html>
