<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Charset early for correct decoding -->
  <meta charset="UTF-8" />
  <!-- Title + Favicon (SVG data URL) -->
  <title>LaTeX Lab</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🧪</text></svg>">


  <!-- KaTeX core CSS (pinned version) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
  <!-- KaTeX runtime JS (pinned version) -->
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" defer></script>
  <!-- KaTeX auto-render helper (pinned version) -->
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer></script>


  <!-- NOTE: We removed the external Computer Modern CSS to avoid conflicting font-family names. -->


  <!-- html2canvas and html-to-image (pinned); we keep both for fallback, primary is html-to-image -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.min.js" defer></script>


  <!-- Preload frequently used KaTeX font faces for better interactivity + export fidelity -->
  <link rel="preload" as="font" type="font/woff2" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_Main-Regular.woff2" crossorigin>
  <link rel="preload" as="font" type="font/woff2" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_Main-Italic.woff2" crossorigin>
  <link rel="preload" as="font" type="font/woff2" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_Math-Italic.woff2" crossorigin>
  <link rel="preload" as="font" type="font/woff2" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_AMS-Regular.woff2" crossorigin>
  <link rel="preload" as="font" type="font/woff2" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_Size1-Regular.woff2" crossorigin>
  <link rel="preload" as="font" type="font/woff2" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/KaTeX_Size2-Regular.woff2" crossorigin>


  <!-- Preload CMU Serif weights used for mixed-mode text -->
  <link rel="preload" as="font" type="font/woff2" href="https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-500-roman.woff2" crossorigin>
  <link rel="preload" as="font" type="font/woff2" href="https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-700-roman.woff2" crossorigin>


  <!-- Mobile-friendly viewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1">


  <style>
    /* =====================
       Fonts (single source)
       ===================== */
    /* We define CMU Serif here and DO NOT include the external CM stylesheet to avoid duplication. */
    @font-face{
      font-family:"CMU Serif";
      src:url("https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-500-roman.woff2") format("woff2");
      font-weight:500; font-style:normal; font-display:swap;
    }
    @font-face{
      font-family:"CMU Serif";
      src:url("https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-500-italic.woff2") format("woff2");
      font-weight:500; font-style:italic; font-display:swap;
    }
    @font-face{
      font-family:"CMU Serif";
      src:url("https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-700-roman.woff2") format("woff2");
      font-weight:700; font-style:normal; font-display:swap;
    }
    @font-face{
      font-family:"CMU Serif";
      src:url("https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-700-italic.woff2") format("woff2");
      font-weight:700; font-style:italic; font-display:swap;
    }


    /* =====================
       Theme tokens
       ===================== */
    :root{
      --bg:#ffffff; --text:#111; --gutter-bg:#f4f4f4; --gutter-text:#888;
      --stripe-light: rgba(0,0,0,.03);
      --border: rgba(0,0,0,.12);
    }
    body.dark{
      --bg:#121212; --text:#eee; --gutter-bg:#1f1f1f; --gutter-text:#aaa;
      --stripe-light: rgba(255,255,255,.04);
      --border: rgba(255,255,255,.14);
    }


    /* =====================
       Base layout
       ===================== */
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;overflow:hidden}
    body{
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
      background:var(--bg); color:var(--text);
      display:flex; flex-direction:column; transition:background .18s,color .18s;
    }


    /* =====================
       Toolbar
       ===================== */
    .toolbar{ border-bottom:1px solid var(--border); display:flex; align-items:center; gap:.5rem; padding:.5rem 1rem; flex-wrap:wrap; }
    .menu{ position:relative; display:inline-block }
    .menu-button, button{
      padding:.45em .7em; border-radius:6px; border:1px solid var(--border);
      background:rgba(255,255,255,.95); cursor:pointer; font-size:14px; color:inherit;
    }
    body.dark .menu-button, body.dark button{ background:linear-gradient(#222,#1b1b1b) }
    .menu-button:active, button:active{ transform:translateY(1px) }
    .menu ul{
      position:absolute; z-index:10; min-width:220px; margin:.3rem 0 0; padding:.4rem 0;
      background:var(--bg); color:var(--text); list-style:none; border:1px solid var(--border); border-radius:8px;
      box-shadow:0 6px 24px rgba(0,0,0,.12); display:none;
    }
    .menu.open ul{ display:block }
    .menu ul li{ padding:.45rem .75rem; cursor:pointer }
    .menu ul li:hover{ background:var(--stripe-light) }


    /* =====================
       Split panes
       ===================== */
    .container{ flex:1; display:flex; min-height:0; overflow:hidden }
    #leftPane{ flex:0 0 50%; display:flex; min-width:260px; border-right:1px solid var(--border); min-height:0 }
    #gutter{
      width:4.8em; padding-top:.6em; padding-bottom:.6em; background:var(--gutter-bg); color:var(--gutter-text);
      font-family:monospace; font-size:15px; text-align:right; user-select:none; overflow:hidden;
    }
    #gutter .ln{display:block; padding-right:.6em}
    /* Single rule handles both themes */
    #gutter .ln:nth-child(odd){ background-color:var(--stripe-light) }


    #editorWrap{ position:relative; flex:1; overflow:hidden; background: var(--bg); min-height:0 }
    /*#overlay{ position:absolute; inset:0; pointer-events:none; z-index:2; }*/
    #overlay{
      position:absolute; inset:0; pointer-events:none; z-index:2;
      overflow:auto;                 /* let the overlay content scroll */
      scrollbar-width: none;         /* hide in Firefox */
    }
    #overlay::-webkit-scrollbar{ display:none; }  /* hide in Chromium/WebKit */
    #editor{
      position:relative; width:100%; height:100%; padding:.6em 1em .6em 1em; font-family:monospace; font-size:15px; line-height:1.5;
      border:none; outline:none; background:transparent; color:var(--text); resize:none; overflow:auto;
    }


    /* Divider */
    #divider{
      width:12px; cursor:col-resize;
      background:
        radial-gradient(currentColor 22%, transparent 23%) center 14px/6px 10px no-repeat,
        radial-gradient(currentColor 22%, transparent 23%) center 28px/6px 10px no-repeat,
        linear-gradient(90deg, transparent, var(--border), transparent);
      color:#aaa;
    }
    #divider:hover{ color:#777 }
    body.dark #divider{ color:#bbb }


    /* Preview */
    #preview{ flex:1; padding:1.25rem; overflow:auto; background:var(--bg); color:var(--text); font-size:16px; line-height:1.6; white-space:pre-wrap; min-height:0 }


    /* Consistent tab rendering */
    #editor, #preview { tab-size: 4; -moz-tab-size: 4; }


    /* Controls */
    .controls{ min-height:88px; border-top:1px solid var(--border); display:flex; align-items:center; justify-content:space-between; padding:.5rem 1rem 1rem; gap:1rem; background:linear-gradient(to top, rgba(0,0,0,.01), transparent); }
    .left-controls,.right-controls{ display:flex; align-items:center; gap:1rem }


    /* Mode slider (wide) */
    .switch.mode{ position:relative; width:120px; height:36px; display:inline-block }
    .switch.mode input{ display:none }
    .switch.mode .track{ position:absolute; inset:0; border-radius:999px; border:1px solid var(--border); background:transparent; display:flex; align-items:center; justify-content:space-between; padding:0 9px; }
    .switch.mode .thumb{ position:absolute; top:50%; left:4px; width:60px; height:30px; background:#fff; border-radius:999px; box-shadow:0 2px 6px rgba(0,0,0,.22); transform:translate(0,-50%); transition:transform .18s; }
    body.dark .switch.mode .thumb{ background:#2a2a2a }
    .stack{ display:flex; flex-direction:column; align-items:center; line-height:1.0; font-size:10px; font-weight:700; opacity:.45; transition:opacity .18s; user-select:none; }
    .switch.mode .stack { transform: translateY(-0.5px); }
    #modeToggle:checked + .track .stack.all{ opacity:1 }
    #modeToggle:not(:checked) + .track .stack.some{ opacity:1 }
    #modeToggle:not(:checked) + .track .thumb{ transform:translate(50px,-50%) }


    /* Dark slider (compact) */
    .switch.dark{ position:relative; width:64px; height:34px; display:inline-block }
    .switch.dark input{ display:none }
    .switch.dark .track{ position:absolute; inset:0; border-radius:999px; border:1px solid var(--border); background:transparent; display:flex; align-items:center; justify-content:space-between; padding:0 6px; }
    .switch.dark .thumb{ position:absolute; top:50%; left:3px; width:28px; height:28px; background:#fff; border-radius:50%; box-shadow:0 2px 6px rgba(0,0,0,.22); transform:translate(0,-50%); transition:transform .18s; }
    body.dark .switch.dark .thumb{ background:#2a2a2a }
    .emoji{ font-size:16px; filter: drop-shadow(0 0 2px rgba(0,0,0,.35)); opacity:.45; transition:opacity .18s; user-select:none }
    #darkToggle:not(:checked) + .track .sun{ opacity:1 }
    #darkToggle:checked + .track .moon{ opacity:1 }
    #darkToggle:checked + .track .thumb{ transform:translate(28px,-50%) }


    /* Labels */
    #modeLabel{ font-weight:600; min-width:64px }
    #modeDesc{ font-size:12px; opacity:.8 }


    /* Modals */
    .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center; z-index:9999; }
    .modal-backdrop.show{ display:flex }
    .modal{ width:min(540px,92vw); background:var(--bg); color:var(--text); border-radius:12px; padding:1rem; border:1px solid var(--border) }
    .modal h3{ margin:.2rem 0 1rem 0 }
    .modal .row{ display:flex; gap:.75rem; align-items:center; margin:.5rem 0; flex-wrap:wrap }
    .modal label{ min-width:4.5rem }
    .modal input[type="number"], .modal select { width:100px; padding:.35rem .4rem }
    .modal .preview{ margin-top:.75rem; padding:.75rem; border-radius:8px; border:1px dashed var(--border); font-family:monospace; white-space:pre-wrap; max-height:240px; overflow:auto; }
    .modal .actions{ display:flex; justify-content:flex-end; gap:.5rem; margin-top:1rem }


    /* Mixed mode: use CMU Serif for plain text, let KaTeX keep its own fonts */
    body.mixed #preview { font-family: "CMU Serif"; font-weight: 500; font-size:20px; line-height:1.4; }


    /* Make entire pill clickable (bug fix: add missing dot on selector) */
    .switch .track { cursor: pointer; }


    /* Hidden measuring div to compute line wrap heights */
    #measure{ position:absolute; visibility:hidden; top:-9999px; left:-9999px; box-sizing:content-box; padding:0; margin:0; border:0; white-space:pre-wrap; word-break:break-word; overflow-wrap:break-word; }


    /* Welcome pop-under styling */
    .welcome-pop{ position: fixed; bottom: 1rem; right: 1rem; max-width: 360px; background: var(--bg); color: var(--text); border: 1px solid var(--border); border-radius: 10px; box-shadow: 0 6px 20px rgba(0,0,0,.25); padding: 1rem; z-index: 99999; display: none; animation: fadeInUp .35s ease; }
    .welcome-pop h3 { margin: 0 0 .5rem; }
    .welcome-pop p  { font-size: 13px; line-height: 1.45; margin: 0 0 .75rem; }
    .welcome-pop button { padding: .35em .7em; border-radius: 6px; border: 1px solid var(--border); background: rgba(255,255,255,.95); cursor: pointer; font-size: 13px; }
    body.dark .welcome-pop { background: #1e1e1e; }
    @keyframes fadeInUp { from { opacity:0; transform:translateY(12px) } to { opacity:1; transform:translateY(0) } }
    @media (max-width: 520px) { .welcome-pop { left: 1rem; right: 1rem; max-width: none; } }
  </style>
</head>
<body>
  <!-- ===================== Toolbar ===================== -->
  <div class="toolbar">
    <div class="menu" id="snippetsMenu">
      <button class="menu-button" id="snippetsBtn">🔖 Insert ▾</button>
      <ul id="snippetsList">
        <li id="openMatrixGen">Matrix</li>
        <li id="openTableGen">Table</li>
        <li id="insertCases">Cases</li>
      </ul>
    </div>
    <button id="shareBtn" class="menu-button">🔗 Share link</button>
    <button id="macrosBtn" class="menu-button">⚡ Shortcuts</button>
  </div>


  <!-- ===================== Split ===================== -->
  <div class="container">
    <section id="leftPane">
      <div id="gutter" aria-hidden="true"></div>
      <div id="editorWrap">
        <div id="overlay" aria-hidden="true"></div>
        <!-- Accessibility: add aria-label -->
        <textarea id="editor" aria-label="Editor" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Type text with $inline$ and $$display$$ math…"></textarea>
        <div id="measure" aria-hidden="true"></div>
      </div>
    </section>
    <div id="divider" role="separator" aria-orientation="vertical" aria-label="Resize panels"></div>
    <section id="preview" aria-live="polite"></section>
  </div>


  <!-- ===================== Controls ===================== -->
  <div class="controls">
    <div class="left-controls">
      <!-- Mode slider -->
      <div class="mode" title="Mixed vs Classic rendering">
        <label class="switch mode" for="modeToggle">
          <input id="modeToggle" type="checkbox">
          <span class="track">
            <span class="stack some"><span>SOME</span><span>MATH</span></span>
            <span class="stack all"><span>ALL</span><span>MATH</span></span>
            <span class="thumb"></span>
          </span>
        </label>
        <div>
          <div id="modeLabel">Mixed</div>
          <div id="modeDesc">Mixed: type text with $inline$ and $$display$$ math.</div>
        </div>
      </div>
    </div>


    <div class="right-controls">
      <!-- Dark slider -->
      <div class="dark-switch" title="Light / Dark">
        <label class="switch dark" for="darkToggle">
          <input id="darkToggle" type="checkbox">
          <span class="track">
            <span class="emoji moon">🌙</span>
            <span class="emoji sun">🌞</span>
            <span class="thumb"></span>
          </span>
        </label>
      </div>


      <button id="pngBtn">🖼️ PNG</button>
      <!-- <button id="pdfBtn">📄 PDF</button> -->
      <button id="clearBtn" title="Clear editor and saved text">🧹 Clear</button>
    </div>
  </div>


  <!-- ===================== Matrix Modal ===================== -->
  <div class="modal-backdrop" id="matrixModal">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="matrixTitle">
      <h3 id="matrixTitle">Insert Matrix</h3>
      <div class="row">
        <label>Rows</label><input type="number" id="mRows" min="1" max="20" value="3">
        <label>Cols</label><input type="number" id="mCols" min="1" max="20" value="3">
        <label>Type</label>
        <select id="mType">
          <option value="pmatrix">pmatrix ( )</option>
          <option value="bmatrix">bmatrix [ ]</option>
          <option value="Bmatrix">Bmatrix { }</option>
          <option value="vmatrix">vmatrix | |</option>
          <option value="Vmatrix">Vmatrix || ||</option>
        </select>
      </div>
      <div class="preview" id="matrixPrev"></div>
      <div class="actions">
        <button class="menu-button" id="mCancel">Cancel</button>
        <button class="menu-button" id="mInsert">Insert</button>
      </div>
    </div>
  </div>


  <!-- ===================== Table Modal ===================== -->
  <div class="modal-backdrop" id="tableModal">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="tableTitle">
      <h3 id="tableTitle">Insert Table</h3>
      <div class="row">
        <label>Rows</label><input type="number" id="tRows" min="1" max="40" value="3">
        <label>Cols</label><input type="number" id="tCols" min="1" max="20" value="3">
        <label>Align</label>
        <select id="tAlign">
          <option value="c">center</option>
          <option value="l">left</option>
          <option value="r">right</option>
        </select>
        <label>Borders</label>
        <select id="tBorders">
          <option value="none">none</option>
          <option value="outer">outer</option>
          <option value="all">all</option>
        </select>
      </div>
      <div class="preview" id="tablePrev"></div>
      <div class="actions">
        <button class="menu-button" id="tCancel">Cancel</button>
        <button class="menu-button" id="tInsert">Insert</button>
      </div>
    </div>
  </div>


  <!-- ===================== Macros Modal ===================== -->
  <div class="modal-backdrop" id="macrosModal">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="macrosTitle">
      <h3 id="macrosTitle">Shortcuts (\newcommand)</h3>
      <div class="row" style="flex-direction:column; align-items:stretch;">
        <textarea id="macrosText" style="width:100%;height:220px;font-family:monospace;"></textarea>
        <small style="opacity:.8;margin-top:.5rem;">
          Paste lines like: <code>\newcommand{\RR}{\mathbb{R}}</code> or <code>\newcommand{\vect}[1]{\mathbf{#1}}</code>
        </small>
      </div>
      <div class="actions">
        <button class="menu-button" id="macrosReset">Reset</button>
        <button class="menu-button" id="macrosCancel">Cancel</button>
        <button class="menu-button" id="macrosSave">Save</button>
      </div>
    </div>
  </div>


  <!-- ===================== App Script ===================== -->
  <script>
    /* =====================
       Config
       ===================== */
    const EXPORT_SCALE = 8;             // logical text scale baked into CSS metrics for export


    /* =====================
       Element refs
       ===================== */
    const editor   = document.getElementById('editor');
    const gutter   = document.getElementById('gutter');
    const overlay  = document.getElementById('overlay');
    const preview  = document.getElementById('preview');
    const divider  = document.getElementById('divider');


    const modeToggle = document.getElementById('modeToggle');
    const modeLabel  = document.getElementById('modeLabel');
    const modeDesc   = document.getElementById('modeDesc');
    const darkToggle = document.getElementById('darkToggle');


    const pngBtn     = document.getElementById('pngBtn');
    const clearBtn   = document.getElementById('clearBtn');
    const shareBtn   = document.getElementById('shareBtn');


    const measure  = document.getElementById('measure');


    const snippetsMenu = document.getElementById('snippetsMenu');
    const snippetsBtn  = document.getElementById('snippetsBtn');
    document.getElementById('openMatrixGen').addEventListener('click', ()=>{ snippetsMenu.classList.remove('open'); openMatrix(); });
    document.getElementById('openTableGen').addEventListener('click', ()=>{ snippetsMenu.classList.remove('open'); openTable(); });


    /* =====================
       Modals wiring
       ===================== */
    const matrixModal = document.getElementById('matrixModal');
    const mRows=document.getElementById('mRows'), mCols=document.getElementById('mCols'), mType=document.getElementById('mType');
    const matrixPrev=document.getElementById('matrixPrev');
    document.getElementById('mCancel').addEventListener('click', ()=>matrixModal.classList.remove('show'));
    document.getElementById('mInsert').addEventListener('click', insertMatrix);


    const tableModal = document.getElementById('tableModal');
    const tRows=document.getElementById('tRows'), tCols=document.getElementById('tCols'), tAlign=document.getElementById('tAlign'), tBorders=document.getElementById('tBorders');
    const tablePrev=document.getElementById('tablePrev');
    document.getElementById('tCancel').addEventListener('click', ()=>tableModal.classList.remove('show'));
    document.getElementById('tInsert').addEventListener('click', insertTable);


    const macrosBtn   = document.getElementById('macrosBtn');
    const macrosModal = document.getElementById('macrosModal');
    const macrosText  = document.getElementById('macrosText');
    const macrosSave  = document.getElementById('macrosSave');
    const macrosCancel= document.getElementById('macrosCancel');
    const macrosReset = document.getElementById('macrosReset');


    /* =====================
       Macros model
       ===================== */
    function serializeMacros(macros){
      const lines = [];
      for (const [name, body] of Object.entries(macros)){
        const n = maxArgCount(body);
        const arity = n>0 ? `[${n}]` : '';
        lines.push(`\\newcommand{${name}}${arity}{${body}}`);
      }
      return lines.join('\n');
    }
    function normalizeMacros(obj){
      const out = {}; for (const [k,v] of Object.entries(obj || {})){ out[k] = Array.isArray(v) ? String(v[0]) : String(v); } return out;
    }
    function maxArgCount(s){ let m=0, r=/#([1-9])/g, a; while ((a=r.exec(s))!==null) m=Math.max(m,parseInt(a[1],10)); return m; }
    function parseNewcommands(text){
      const out = {}; const head=/(\\(?:re)?newcommand)\s*\{\s*(\\[A-Za-z@]+)\s*\}\s*(?:\[\s*(\d+)\s*\])?\s*\{/g; /* arity parsed later via body */
      let m, any=false; while ((m=head.exec(text))!==null){ const name=m[2]; let i=head.lastIndex, depth=1; while(i<text.length && depth>0){ const ch=text[i++]; if(ch==='\\'){ i++; continue; } if(ch==='{') depth++; else if(ch==='}') depth--; } const body=text.slice(head.lastIndex, i-1).trim(); out[name]=body; any=true; head.lastIndex=i; }
      return any?out:null;
    }
    function stripLatexComments(s){ return s.replace(/(^|[^\\])%.*$/gm, '$1'); }


    /* =====================
       State + storage keys
       ===================== */
    let mode = 'mixed';
    const LS_CONTENT = 'latexlab.content.v6';
    const LS_DARK    = 'latexlab.dark.v6';
    const LS_SPLITPX = 'latexlab.splitpx.v6';
    const LS_MODE    = 'latexlab.mode.v2';
    const LS_MACROS  = 'latexlab.macros.v2';
    const LS_CURSOR  = 'latexlab.cursor.v1';
    const LS_SCROLL  = 'latexlab.scroll.v1';


    const DEFAULT_MACROS = { "\\abs":  "\\left|#1\\right|", "\\norm": "\\left\\lVert#1\\right\\rVert" };
    let MACROS = {...DEFAULT_MACROS};


    /* =====================
       Measuring helpers
       ===================== */
    function getPx(val){ return parseFloat(val) || 0; }
    function syncOverlayAndMirror(){ const cs=getComputedStyle(editor); overlay.style.paddingTop=cs.paddingTop; overlay.style.paddingBottom=cs.paddingBottom; overlay.style.paddingLeft='0'; overlay.style.paddingRight='0'; measure.style.fontFamily=cs.fontFamily; measure.style.fontSize=cs.fontSize; measure.style.lineHeight=cs.lineHeight; measure.style.letterSpacing=cs.letterSpacing; const innerW=editor.clientWidth - parseFloat(cs.paddingLeft||0) - parseFloat(cs.paddingRight||0); measure.style.width=innerW+'px'; }
    function visualLineHeightPx(){ measure.textContent='M'; let h=measure.getBoundingClientRect().height; measure.textContent=''; if(!h||h<1) h=parseFloat(getComputedStyle(editor).lineHeight)||20; return h; }


    /* =====================
       Gutter/overlay rebuild (throttled)
       ===================== */
    let rebuildRAF = null;
    function scheduleGuideRebuild(){
      if (rebuildRAF) return;                 // coalesce multiple calls this frame
      rebuildRAF = requestAnimationFrame(() => {
        rebuildRAF = null;
        rebuildGuidesWrapping();
      });
    }
    function rebuildGuidesWrapping(){
      // 🔒 Remember current scroll so we don't "jump" to numbers 1..N
      const keep = editor.scrollTop;


      syncOverlayAndMirror();


      // Rebuild
      gutter.innerHTML  = '';
      overlay.innerHTML = '';


      const lh = visualLineHeightPx();
      const lines = editor.value.split('\n');
      const stripeBG = getComputedStyle(document.body).getPropertyValue('--stripe-light');


      for (let i = 0; i < lines.length; i++){
        measure.textContent = lines[i] || ' ';
        const h = Math.max(lh, measure.getBoundingClientRect().height || lh);


        // One gutter line per logical line, height = wrapped height
        const gn = document.createElement('div');
        gn.className   = 'ln';
        gn.textContent = i + 1;                 // ✅ always sequential from 1..N
        gn.style.height     = h + 'px';
        gn.style.lineHeight = h + 'px';
        gutter.appendChild(gn);


        // Paint wrap stripes (purely visual)
        const rows = Math.max(1, Math.ceil(h / lh));
        const bg = (i % 2) ? stripeBG : 'transparent';
        for (let r = 0; r < rows; r++){
          const stripe = document.createElement('div');
          stripe.className = 'row';
          const last = (r === rows - 1);
          const stripeH = last ? (h - (rows - 1) * lh) : lh;
          stripe.style.height = stripeH + 'px';
          stripe.style.backgroundColor = bg;
          overlay.appendChild(stripe);
        }
      }
      measure.textContent = '';


      // 🔁 Restore scroll positions so the top visible number matches the scrolled line
      gutter.scrollTop  = keep;
      overlay.scrollTop = keep;
      // (We do NOT change editor.scrollTop here; we respect whatever it already is.)
    }
    /* =====================
       Render pipeline
       ===================== */
    function render(){
      preview.innerHTML = '';
      const lines = editor.value.split('\n');
      if (mode === 'classic'){
        for (const line of lines){
          if (line.trim() === '') { preview.appendChild(document.createElement('br')); continue; }
          const div = document.createElement('div');
          try { katex.render(line, div, {throwOnError:false, displayMode:true, macros: MACROS}); }
          catch (e){ div.textContent = e.message; }
          preview.appendChild(div);
        }
      } else {
        for (const line of lines){
          if (line.trim() === '') { preview.appendChild(document.createElement('br')); continue; }
          const wrap = document.createElement('div');
          wrap.textContent = line;
          renderMathInElement(wrap, { delimiters: [ {left:"$$", right:"$$", display:true}, {left:"$", right:"$", display:false} ], throwOnError:false, macros: MACROS });
          preview.appendChild(wrap);
        }
      }
      scheduleGuideRebuild();
    }


    /* =====================
       Scroll sync (editor → preview)
       ===================== */
    editor.addEventListener('scroll', () => {
      const maxE = Math.max(1, editor.scrollHeight - editor.clientHeight);
      const ratio = editor.scrollTop / maxE;
      gutter.scrollTop  = editor.scrollTop;
      overlay.scrollTop = editor.scrollTop;
      preview.scrollTop = ratio * Math.max(0, (preview.scrollHeight - preview.clientHeight));
    });


    /* =====================
       Mode / Theme toggles
       ===================== */
    editor.addEventListener('input', () => { render(); try { localStorage.setItem(LS_CONTENT, editor.value); } catch(e){} });


    modeToggle.addEventListener('change', () => {
      mode = modeToggle.checked ? 'classic' : 'mixed';
      modeLabel.textContent = (mode === 'classic') ? 'Classic' : 'Mixed';
      modeDesc.textContent  = (mode === 'classic') ? 'Classic: each new line is rendered as display math.' : 'Mixed: type text with $inline$ and $$display$$ math.';
      editor.placeholder = (mode === 'classic') ? 'Type lines of pure TeX; each line renders as display math' : 'Type text with $inline$ and $$display$$ math';
      document.body.classList.toggle('mixed',   mode === 'mixed');
      document.body.classList.toggle('classic', mode === 'classic');
      try { localStorage.setItem(LS_MODE, mode); } catch(e) {}
      render();
    });


    darkToggle.addEventListener('change', () => {
      const isDark = darkToggle.checked;
      document.body.classList.toggle('dark', isDark);
      try { localStorage.setItem(LS_DARK, isDark ? '1' : '0'); } catch(e) {}
      render();
    });


    /* =====================
       Tab indent/outdent
       ===================== */
    editor.addEventListener('keydown', (e) => {
      if (e.key !== 'Tab') return;
      e.preventDefault();
      const start = editor.selectionStart, end = editor.selectionEnd;
      const val = editor.value; const lineStart = val.lastIndexOf('\n', start - 1) + 1;
      if (!e.shiftKey) {
        if (start === end) { editor.setRangeText('  ', start, end, 'end'); editor.selectionStart = editor.selectionEnd = start + 2; }
        else { const block = val.slice(lineStart, end).replace(/^/gm, '  '); editor.setRangeText(block, lineStart, end, 'end'); const delta = block.length - (end - lineStart); editor.selectionStart = start + 2; editor.selectionEnd = end + delta; }
      } else {
        const re = /^ {1,2}/gm; const before = val.slice(lineStart, end); const block = before.replace(re, ''); const removed = (before.match(re) || []).reduce((a,s)=>a+s.length,0);
        editor.setRangeText(block, lineStart, end, 'end'); editor.selectionStart = Math.max(lineStart, start - Math.min(2, removed)); editor.selectionEnd = Math.max(lineStart, end - removed);
      }
      render(); try { localStorage.setItem(LS_CONTENT, editor.value); } catch(e){}
    });


    /* =====================
       File download helpers
       ===================== */
    function triggerDownload(url, filename){ const a=document.createElement('a'); a.href=url; a.download=filename; a.rel='noopener'; document.body.appendChild(a); a.click(); a.remove(); }
    function saveCanvasPNG(canvas, filename){ return new Promise((resolve) => { if (canvas.toBlob) { canvas.toBlob((blob) => { if (!blob) { resolve(false); return; } const blobUrl = URL.createObjectURL(blob); triggerDownload(blobUrl, filename); setTimeout(() => URL.revokeObjectURL(blobUrl), 1500); resolve(true); }, 'image/png'); } else { const dataUrl = canvas.toDataURL('image/png'); triggerDownload(dataUrl, filename); resolve(true); } }); }


    /* =====================
       Export helpers (fonts + layout)
       ===================== */
    function ff(family, file, weight=400, style='normal'){
      return `@font-face{font-family:${family};src:url(https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/fonts/${file}.woff2) format("woff2");font-weight:${weight};font-style:${style};font-display:swap;}`;
    }
    function buildFontFaceStyleEl(){
      const css = [
        ff('KaTeX_Main','KaTeX_Main-Regular',400,'normal'),
        ff('KaTeX_Main','KaTeX_Main-Italic', 400,'italic'),
        ff('KaTeX_Main','KaTeX_Main-Bold',   700,'normal'),
        ff('KaTeX_Main','KaTeX_Main-BoldItalic',700,'italic'),
        ff('KaTeX_Math','KaTeX_Math-Italic', 400,'italic'),
        ff('KaTeX_Math','KaTeX_Math-BoldItalic',700,'italic'),
        ff('KaTeX_AMS','KaTeX_AMS-Regular'),
        ff('KaTeX_Caligraphic','KaTeX_Caligraphic-Regular'),
        ff('KaTeX_Caligraphic','KaTeX_Caligraphic-Bold',700),
        ff('KaTeX_Fraktur','KaTeX_Fraktur-Regular'),
        ff('KaTeX_SansSerif','KaTeX_SansSerif-Regular'),
        ff('KaTeX_SansSerif','KaTeX_SansSerif-Bold',700),
        ff('KaTeX_SansSerif','KaTeX_SansSerif-Italic',400,'italic'),
        ff('KaTeX_Script','KaTeX_Script-Regular'),
        ff('KaTeX_Typewriter','KaTeX_Typewriter-Regular'),
        ff('KaTeX_Size1','KaTeX_Size1-Regular'),
        ff('KaTeX_Size2','KaTeX_Size2-Regular'),
        ff('KaTeX_Size3','KaTeX_Size3-Regular'),
        ff('KaTeX_Size4','KaTeX_Size4-Regular'),
        '@font-face{font-family:"CMU Serif"; src:url(https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-500-roman.woff2) format("woff2"); font-weight:500; font-style:normal; font-display:swap;}',
        '@font-face{font-family:"CMU Serif"; src:url(https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-500-italic.woff2) format("woff2"); font-weight:500; font-style:italic; font-display:swap;}',
        '@font-face{font-family:"CMU Serif"; src:url(https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-700-roman.woff2) format("woff2"); font-weight:700; font-style:normal; font-display:swap;}',
        '@font-face{font-family:"CMU Serif"; src:url(https://cdn.jsdelivr.net/npm/computer-modern@0.1.3/fonts/cmu-serif-700-italic.woff2) format("woff2"); font-weight:700; font-style:italic; font-display:swap;}',
      ].join('\n');
      const el = document.createElement('style'); el.type='text/css'; el.appendChild(document.createTextNode(css)); return el;
    }


    function isMeaningfulLine(el){ if(!el) return false; if(el.querySelector && el.querySelector('.katex')) return true; if((el.textContent||'').trim().length>0) return true; return false; }
    function trimLeadingTrailingBlanks(containerEl){ const kids = Array.from(containerEl.children); let i=0, j=kids.length-1; while(i<=j && !isMeaningfulLine(kids[i])) i++; while(j>=i && !isMeaningfulLine(kids[j])) j--; for(let k=0;k<i;k++) containerEl.removeChild(kids[k]); for(let k=kids.length-1;k>j;k--) containerEl.removeChild(kids[k]); }


    async function preloadFonts(){
      const probe = document.createElement('div'); Object.assign(probe.style,{ position:'fixed', left:'-9999px', top:'0', opacity:'0', pointerEvents:'none' });
      const families = [ '"CMU Serif"', 'KaTeX_Main','KaTeX_Math','KaTeX_AMS','KaTeX_SansSerif','KaTeX_Script','KaTeX_Fraktur','KaTeX_Typewriter','KaTeX_Caligraphic' ];
      probe.innerHTML = families.map(f => `<span style="font-family:${f};font-weight:400">A1</span>`).join(''); document.body.appendChild(probe);
      try { if (document.fonts && document.fonts.ready) { await Promise.race([document.fonts.ready, new Promise(r=>setTimeout(r, 800))]); } else { await new Promise(r=>setTimeout(r, 300)); } } catch {}
      probe.remove();
    }


    function dataUrlToBlob(dataUrl){ const [meta,b64]=dataUrl.split(','); const mime=(meta.match(/data:([^;]+)/)||[, 'image/png'])[1]; const bin=atob(b64); const u8=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i); return new Blob([u8],{type:mime}); }


    const raf = () => new Promise(r => requestAnimationFrame(r));
    async function settleLayout(){ await raf(); await raf(); if (document.fonts && document.fonts.ready) { try { await Promise.race([document.fonts.ready, new Promise(r=>setTimeout(r, 500))]); } catch {} } }


    /* =====================
       PNG export (scoped fixes + 1:1 pixel ratio)
       ===================== */
    async function exportPNG(){
      const bg = getComputedStyle(preview).backgroundColor || getComputedStyle(document.body).backgroundColor;
      const sandbox = document.createElement('div'); Object.assign(sandbox.style,{ position:'fixed', left:'0', top:'0', opacity:'0', pointerEvents:'none', display:'inline-block', background:bg });
      sandbox.appendChild(buildFontFaceStyleEl());
      // Scope the Safari text-fill fix only to our export DOM
      const webkitFillFix = document.createElement('style'); webkitFillFix.textContent = `.export-scope, .export-scope * { -webkit-text-fill-color: currentColor !important; }`; sandbox.appendChild(webkitFillFix);
      const wrapper = document.createElement('div'); wrapper.className = 'export-scope'; wrapper.style.display='inline-block'; wrapper.style.whiteSpace='pre-wrap'; wrapper.style.tabSize='4';
      // Bake DPI into typography (preserves kerning) and avoid extra pixelRatio scaling
      {
        const cps = getComputedStyle(preview);
        const baseSizePx = parseFloat(cps.fontSize) || 16;
        const baseLHpx   = cps.lineHeight.endsWith('px') ? parseFloat(cps.lineHeight) : baseSizePx * 1.5;
        const SCALE = Math.max(1, EXPORT_SCALE|0);
        wrapper.style.fontFamily = cps.fontFamily;
        const textColor = cps.color || '#111';
        wrapper.style.color = textColor; wrapper.style.webkitTextFillColor = textColor; wrapper.style.backgroundColor = cps.backgroundColor;
        wrapper.style.whiteSpace='pre-wrap'; wrapper.style.tabSize='4'; wrapper.style.fontKerning='normal'; wrapper.style.fontFeatureSettings='"kern" 1'; wrapper.style.textRendering='optimizeLegibility';
        wrapper.style.fontSize = (baseSizePx * SCALE) + 'px';
        wrapper.style.lineHeight = (baseLHpx * SCALE) + 'px';
      }
      const padTop=20, padBottom=20, padSides=20; wrapper.style.padding = `${padTop}px ${padSides}px ${padBottom}px ${padSides}px`;
      const clone = preview.cloneNode(true); while (clone.firstChild) wrapper.appendChild(clone.firstChild);
      wrapper.querySelectorAll('.katex-display').forEach(el => { el.style.marginTop='0'; el.style.marginBottom='0'; });
      // wrapper.querySelectorAll('img, svg, canvas').forEach(el => { el.style.display='inline-block'; el.style.verticalAlign='baseline'; });
      wrapper.querySelectorAll('img, canvas').forEach(el => {
        el.style.display = 'inline-block';
        el.style.verticalAlign = 'baseline';
      });
      trimLeadingTrailingBlanks(wrapper);
      const meaningful = Array.from(wrapper.children).some(el => (el.querySelector && el.querySelector('.katex')) || ((el.textContent||'').trim().length>0));
      if (!meaningful) { alert('Nothing to export yet — add some text or math first.'); return; }
      sandbox.appendChild(wrapper); document.body.appendChild(sandbox);
      try {
        await preloadFonts(); await settleLayout();
        const rect = wrapper.getBoundingClientRect(); const w=Math.ceil(rect.width), h=Math.ceil(rect.height); if (w<=0||h<=0) throw new Error('zero-size after layout');
        if (window.htmlToImage?.toPng) {
          const url = await window.htmlToImage.toPng(wrapper, { pixelRatio: 1, backgroundColor: bg, cacheBust: true, width: w, height: h, fetchRequestInit: { mode: 'cors', credentials: 'omit' }, style: { transform: 'none' } });
          const blobUrl = URL.createObjectURL(dataUrlToBlob(url)); triggerDownload(blobUrl, stampName('png')); setTimeout(() => URL.revokeObjectURL(blobUrl), 1500); return;
        }
        const canvas = await html2canvas(wrapper, { backgroundColor: bg, scale: 1, width: w, height: h, useCORS: true, foreignObjectRendering: false });
        await saveCanvasPNG(canvas, stampName('png'));
      } catch (err) {
        console.warn('Export failed, attempting html2canvas fallback:', err);
        try {
          const canvas = await html2canvas(sandbox, { backgroundColor: bg, scale: 1, useCORS: true, foreignObjectRendering: false });
          await saveCanvasPNG(canvas, stampName('png'));
        } catch (err2) {
          console.error('Fallback export failed:', err2);
          alert('PNG export failed. (See console for details.)');
        }
      } finally { document.body.removeChild(sandbox); }
    }


    /* =====================
       Common utils
       ===================== */
    function stampName(ext){ const d=new Date(); const pad=n=>String(n).padStart(2,'0'); return `latex-lab-${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}-${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}.${ext}`; }


    /* =====================
       Export button
       ===================== */
    pngBtn.addEventListener('click', exportPNG);


    /* =====================
       Clear
       ===================== */
    clearBtn.addEventListener('click', () => { if (!confirm('Clear editor and saved text?')) return; editor.value=''; try { localStorage.removeItem(LS_CONTENT); } catch(e){} try { history.replaceState(null, '', location.pathname + location.search); } catch(e){} render(); });


    /* =====================
       Resizable split (persisted)
       ===================== */
    (function makeResizable(){ let dragging=false, startX=0, startLeft=0; const left=document.getElementById('leftPane'); const container=document.querySelector('.container');
      divider.addEventListener('mousedown', (e) => { dragging=true; startX=e.clientX; startLeft=left.getBoundingClientRect().width; document.body.style.cursor='col-resize'; e.preventDefault(); });
      window.addEventListener('mousemove', (e) => { if(!dragging) return; let newLeft=startLeft+(e.clientX-startX); const min=240, max=container.clientWidth-240; newLeft=Math.max(min, Math.min(max, newLeft)); left.style.flex=`0 0 ${newLeft}px`; preview.style.flex='1 1 auto'; try { localStorage.setItem(LS_SPLITPX, String(newLeft)); } catch(e){} });
      window.addEventListener('mouseup', () => { dragging=false; document.body.style.cursor=''; });
      try { const savedPx=parseFloat(localStorage.getItem(LS_SPLITPX)); if(!Number.isNaN(savedPx)) { left.style.flex=`0 0 ${savedPx}px`; preview.style.flex=`1 1 auto`; } } catch(e){}
    })();


    divider.addEventListener('dblclick', () => { const cw=document.querySelector('.container').clientWidth; const left=document.getElementById('leftPane'); const mid=Math.max(240, Math.min(cw-240, cw/2)); left.style.flex=`0 0 ${mid}px`; preview.style.flex=`1 1 auto`; try { localStorage.setItem(LS_SPLITPX, String(mid)); } catch(e){} });


    /* =====================
       Snippets (matrix / table / cases)
       ===================== */
    function openMatrix(){ updateMatrixPreview(); matrixModal.classList.add('show'); }
    function openTable(){ updateTablePreview(); tableModal.classList.add('show'); }


    function matrixPreviewText(r,c,type){ const rows=Array.from({length:r},()=> Array.from({length:c},()=> '◻').join(' & ')).join(' \\ '); return `\\begin{${type}} ${rows} \\end{${type}}`; }
    function matrixInsertText(r,c,type){ const rows=Array.from({length:r},()=> Array.from({length:c},()=> '').join(' & ')).join(' \\ '); return `\\begin{${type}} ${rows} \\end{${type}}`; }
    function updateMatrixPreview(){ const r=clampInt(mRows.value,1,20), c=clampInt(mCols.value,1,20); matrixPrev.textContent = matrixPreviewText(r,c,mType.value); }
    function insertMatrix(){ const r=clampInt(mRows.value,1,20), c=clampInt(mCols.value,1,20); const core = matrixInsertText(r,c,mType.value); const inMixed = document.body.classList.contains('mixed'); const snippet = inMixed ? `$$${core}$$` : core; insertAtCursor(snippet); matrixModal.classList.remove('show'); }


    document.getElementById('insertCases').addEventListener('click', insertCases);
    function insertCases(){ const core='\\begin{cases}  &  \\\\  &  \\end{cases}'; const inMixed=document.body.classList.contains('mixed'); const snippet=inMixed?`$$${core}$$`:core; insertAtCursor(snippet); snippetsMenu.classList.remove('open'); }
    mRows.addEventListener('input', updateMatrixPreview); mCols.addEventListener('input', updateMatrixPreview); mType.addEventListener('change', updateMatrixPreview);


    function arrayColSpec(align, cols, borders){ let spec=align.repeat(cols); if (borders==='all') spec='|'+spec.split('').join('|')+'|'; else if (borders==='outer') spec='|'+spec+'|'; return spec; }
    function tablePreviewText(r,c,align,borders){ const spec=arrayColSpec(align,c,borders); const cells=Array.from({length:c},()=> '◻').join(' & '); const rows=Array.from({length:r},()=> cells); const joiner = borders==='all' ? ' \\ \\hline ' : ' \\ '; const top=(borders==='none')?'':'\\hline '; const bottom=(borders==='none')?'':'\\hline '; return `\\begin{array}{${spec}} ${top}${rows.join(joiner)}${bottom}\\end{array}`; }
    function tableInsertText(r,c,align,borders){ const spec=arrayColSpec(align,c,borders); const cells=Array.from({length:c},()=> '').join(' & '); const rows=Array.from({length:r},()=> cells); const joiner = borders==='all' ? ' \\ \\hline ' : ' \\ '; const top=(borders==='none')?'':'\\hline '; const bottom=(borders==='none')?'':'\\hline '; return `\\begin{array}{${spec}} ${top}${rows.join(joiner)}${bottom}\\end{array}`; }
    function updateTablePreview(){ const r=clampInt(tRows.value,1,40), c=clampInt(tCols.value,1,20); tablePrev.textContent = tablePreviewText(r,c,tAlign.value,tBorders.value); }
    function insertTable(){ const r=clampInt(tRows.value,1,40), c=clampInt(tCols.value,1,20); const core = tableInsertText(r,c,tAlign.value,tBorders.value); const inMixed=document.body.classList.contains('mixed'); const snippet=inMixed?`$$${core}$$`:core; insertAtCursor(snippet); tableModal.classList.remove('show'); }
    tRows.addEventListener('input', updateTablePreview); tCols.addEventListener('input', updateTablePreview); tAlign.addEventListener('change', updateTablePreview); tBorders.addEventListener('change', updateTablePreview);


    function clampInt(v,min,max){ v=parseInt(v||min,10); return Math.max(min,Math.min(max,isNaN(v)?min:v)); }
    function insertAtCursor(text){ const el=editor, start=el.selectionStart, end=el.selectionEnd; el.value = el.value.slice(0,start) + text + el.value.slice(end); el.selectionStart = el.selectionEnd = start + text.length; el.focus(); render(); try { localStorage.setItem(LS_CONTENT, el.value); } catch(e){} }


    /* =====================
       Share (URL hash) with safe base64 (no escape/unescape)
       ===================== */
    function b64encode(str){ const bytes = new TextEncoder().encode(str); let bin=''; bytes.forEach(b => bin += String.fromCharCode(b)); return btoa(bin); }
    function b64decode(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }


    function encodeStateToHash(){ const leftPx=document.getElementById('leftPane').getBoundingClientRect().width; const state={ t: editor.value, m: (mode==='classic')?1:0, d: darkToggle.checked?1:0, s: leftPx, x: MACROS }; const b64=b64encode(JSON.stringify(state)); location.hash='state='+b64; return location.href; }
    function tryLoadStateFromHash(){ const m=location.hash.match(/state=([^&]+)/); if(!m) return false; try { const st=JSON.parse(b64decode(m[1])); if (typeof st.t === 'string') editor.value = st.t; modeToggle.checked = (st.m===1); mode = modeToggle.checked ? 'classic' : 'mixed'; document.body.classList.toggle('dark', st.d===1); darkToggle.checked = (st.d===1); if (typeof st.s === 'number' && !Number.isNaN(st.s)){ const left=document.getElementById('leftPane'); left.style.flex=`0 0 ${st.s}px`; preview.style.flex=`1 1 auto`; try { localStorage.setItem(LS_SPLITPX, String(st.s)); } catch(e){} } if (st.x && typeof st.x === 'object') { MACROS = normalizeMacros(st.x); try { localStorage.setItem(LS_MACROS, JSON.stringify(MACROS)); } catch(e){} } modeLabel.textContent = (mode === 'classic') ? 'Classic' : 'Mixed'; modeDesc.textContent  = (mode === 'classic') ? 'Classic: each new line is rendered as display math.' : 'Mixed: type text with $inline$ and $$display$$ math.'; editor.placeholder = (mode === 'classic') ? 'Type lines of pure TeX; each line renders as display math' : 'Type text with $inline$ and $$display$$ math'; return true; } catch(e){ return false; } }


    shareBtn.addEventListener('click', async () => { const url = encodeStateToHash(); try { await navigator.clipboard.writeText(url); shareBtn.textContent = '✅ Copied!'; setTimeout(()=> shareBtn.textContent = '🔗 Share link', 1200); } catch(e){ prompt('Copy this link:', url); } });


    /* Close Insert menu on outside click */
    snippetsBtn.addEventListener('click', () => snippetsMenu.classList.toggle('open'));
    document.addEventListener('click', (e) => { if (!snippetsMenu.contains(e.target)) snippetsMenu.classList.remove('open'); });


    /* =====================
       Welcome pop (first-time)
       ===================== */
    (function setupWelcomePop() {
      const LS_WELCOME='latexlab.welcome.v1';
      function getQueryParam(name){ return new URLSearchParams(window.location.search).get(name); }
      function hashHasWelcome(){ return /(^|[#&])welcome(=1|$)/i.test(location.hash); }
      function shouldForceShow(){ const q=(getQueryParam('welcome')||'').toLowerCase(); if (q==='1'||q==='true'||q==='show') return true; if (hashHasWelcome()) return true; return false; }
      function shouldResetFlag(){ const q=(getQueryParam('welcome')||'').toLowerCase(); return q==='reset'||q==='clear'; }
      function safeGetItem(k){ try { return localStorage.getItem(k); } catch(e) { return null; } }
      function safeSetItem(k,v){ try { localStorage.setItem(k,v); } catch(e){} }
      function safeRemoveItem(k){ try { localStorage.removeItem(k); } catch(e){} }
      function showWelcome(){ const el=document.getElementById('welcomePop'); const btn=document.getElementById('welcomeClose'); if(!el||!btn) return; el.style.display='block'; setTimeout(()=>{ try { btn.focus(); } catch(e){} },0); btn.addEventListener('click', () => { el.style.display='none'; safeSetItem(LS_WELCOME,'1'); }, { once:true }); }
      function init(){ if(shouldResetFlag()) safeRemoveItem(LS_WELCOME); const forced=shouldForceShow(); const seen=!!safeGetItem(LS_WELCOME); if (forced || !seen) { showWelcome(); if(forced) return; } }
      if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init, { once:true }); } else { init(); }
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') { const el=document.getElementById('welcomePop'); if (el && el.style.display==='block') { el.style.display='none'; try { localStorage.setItem(LS_WELCOME,'1'); } catch(e){} } } });
    })();


    /* =====================
       IDE-like pairing (improved $ logic)
       ===================== */
    editor.addEventListener('keydown', (e) => {
      const OPEN_TO_CLOSE = { '(': ')', '{': '}', '[': ']', '$': '$' };
      const CLOSERS = new Set(Object.values(OPEN_TO_CLOSE));
      const start = editor.selectionStart; const end = editor.selectionEnd; const hasSel = start !== end; const nextChar = editor.value[end] || '';


      // Skip over existing closer when appropriate (not for openers—we rely on explicit logic below)
      if (CLOSERS.has(e.key) && !hasSel && nextChar === e.key) {
        e.preventDefault(); editor.selectionStart = editor.selectionEnd = end + 1; return;
      }


      // Dollar handling (single vs double) — more predictable typing for $ and $$
      if (e.key === '$') {
        e.preventDefault();


        const start = editor.selectionStart, end = editor.selectionEnd;
        const hasSel = start !== end;
        const sel = editor.value.slice(start, end);
        const next = editor.value[end] || '';


        // If caret is just before a $, skip over it (no selection)
        if (!hasSel && next === '$') {
          editor.selectionStart = editor.selectionEnd = end + 1;
          return;
        }


        // With a selection: default to single-$ wrap (use $$ only for multi-line)
        const pair = (hasSel && sel.includes('\n')) ? '$$' : '$';


        const before = editor.value.slice(0, start);
        const after  = editor.value.slice(end);
        editor.value = before + pair + sel + pair + after;


        if (hasSel) {
          // ✅ Keep the original inner text selected after wrapping
          editor.selectionStart = start + pair.length;
          editor.selectionEnd   = end   + pair.length;
        } else {
          // No selection: place caret between the inserted pair
          editor.selectionStart = editor.selectionEnd = start + pair.length;
        }


        render();
        try { localStorage.setItem(LS_CONTENT, editor.value); } catch {}
        return;
      }


      // Generic openers ( (), {}, [] )
      if (e.key in OPEN_TO_CLOSE && e.key !== '$') {
        e.preventDefault();
        const open = e.key; const close = OPEN_TO_CLOSE[open];
        const before = editor.value.slice(0, start); const selected = editor.value.slice(start, end); const after = editor.value.slice(end);
        editor.value = before + open + selected + close + after;
        if (hasSel) { editor.selectionStart = start + 1; editor.selectionEnd = end + 1; } else { editor.selectionStart = editor.selectionEnd = start + 1; }
        render(); try { localStorage.setItem(LS_CONTENT, editor.value); } catch {}
        return;
      }
    });
    // Save caret position when selection changes
    editor.addEventListener('keyup', saveCursorAndScroll);
    editor.addEventListener('click', saveCursorAndScroll);
    editor.addEventListener('input', saveCursorAndScroll);


    function saveCursorAndScroll() {
      try {
        // Cursor (caret) index
        localStorage.setItem(LS_CURSOR, String(editor.selectionStart));


        // Scroll position (vertical only; horizontal if you want)
        localStorage.setItem(LS_SCROLL, String(editor.scrollTop));
      } catch(e) {}
    }




    /* =====================
       Init sequence
       ===================== */
    window.addEventListener('load', () => {
      const loadedFromHash = tryLoadStateFromHash();
      if (!loadedFromHash){
        try { const saved = localStorage.getItem(LS_CONTENT); if (saved != null) editor.value = saved; } catch(e){}
        try { const dark = localStorage.getItem(LS_DARK)==='1'; darkToggle.checked=dark; document.body.classList.toggle('dark', dark);} catch(e){}
        try { const savedPx = parseFloat(localStorage.getItem(LS_SPLITPX)); if (!Number.isNaN(savedPx)) { const left=document.getElementById('leftPane'); left.style.flex=`0 0 ${savedPx}px`; preview.style.flex=`1 1 auto`; } } catch(e){}
        try { const savedMode = localStorage.getItem(LS_MODE); if (savedMode === 'classic' || savedMode === 'mixed') modeToggle.checked = (savedMode === 'classic'); } catch(e){}
        try { const raw = localStorage.getItem(LS_MACROS); if (raw) { const obj = JSON.parse(raw); MACROS = normalizeMacros(obj); } } catch(e){}
        // Restore cursor and scroll
        try {
          const cursor = parseInt(localStorage.getItem(LS_CURSOR), 10);
          if (!isNaN(cursor)) {
            editor.selectionStart = editor.selectionEnd = cursor;
          }


          const scroll = parseInt(localStorage.getItem(LS_SCROLL), 10);
          if (!isNaN(scroll)) {
            // Wait a frame so content/overlay are laid out
            requestAnimationFrame(() => {
              editor.scrollTop = scroll;
              gutter.scrollTop = scroll;
              overlay.scrollTop = scroll;
            });
          }
        } catch(e) {}
      }
      mode = modeToggle.checked ? 'classic' : 'mixed';
      document.body.classList.toggle('mixed',   mode === 'mixed');
      document.body.classList.toggle('classic', mode === 'classic');
      modeLabel.textContent = (mode === 'classic') ? 'Classic' : 'Mixed';
      modeDesc.textContent  = (mode === 'classic') ? 'Classic: each new line is rendered as display math.' : 'Mixed: type text with $inline$ and $$display$$ math.';
      editor.placeholder    = (mode === 'classic') ? 'Type lines of pure TeX; each line renders as display math' : 'Type text with $inline$ and $$display$$ math';
      syncOverlayAndMirror();
      render();
      // Ensure the very first rebuild happens before we restore scroll
      requestAnimationFrame(() => {
        // Optional: force a rebuild once after initial layout (handles font/width settles)
        scheduleGuideRebuild();


        // Then, one more frame later, apply the saved scroll
        requestAnimationFrame(() => {
          try {
            const saved = parseInt(localStorage.getItem(LS_SCROLL), 10);
            if (!isNaN(saved)) {
              editor.scrollTop  = saved;
              gutter.scrollTop  = saved;  // keep things in lockstep
              overlay.scrollTop = saved;
            }
          } catch {}
        });
      });
      editor.focus();
    });
    window.addEventListener('resize', () => { syncOverlayAndMirror(); scheduleGuideRebuild(); });


    /* =====================
       Modal close behaviors
       ===================== */
    matrixModal.addEventListener('click', (e) => { if (e.target === matrixModal) matrixModal.classList.remove('show'); });
    tableModal.addEventListener('click',  (e) => { if (e.target === tableModal)  tableModal.classList.remove('show');  });
    macrosModal.addEventListener('click', (e) => { if (e.target === macrosModal) macrosModal.classList.remove('show'); });


    window.addEventListener('keydown', (e) => {
      if (e.key !== 'Escape') return;
      if (matrixModal.classList.contains('show')) { matrixModal.classList.remove('show'); return; }
      if (tableModal .classList.contains('show')) { tableModal .classList.remove('show'); return; }
      if (macrosModal.classList.contains('show')) { macrosModal.classList.remove('show'); return; }
    });


    /* =====================
       Macros modal actions
       ===================== */
    macrosBtn.addEventListener('click', () => { macrosText.value = serializeMacros(MACROS); macrosModal.classList.add('show'); });
    macrosCancel.addEventListener('click', ()=> macrosModal.classList.remove('show'));
    macrosReset.addEventListener('click', () => { MACROS = {...DEFAULT_MACROS}; try { localStorage.setItem(LS_MACROS, JSON.stringify(MACROS)); } catch(e){} macrosText.value = serializeMacros(MACROS); render(); });
    macrosSave.addEventListener('click', (e) => {
      e.preventDefault();
      try {
        const raw = macrosText.value; const parsed = parseNewcommands(stripLatexComments(raw));
        if (!parsed || Object.keys(parsed).length === 0) { alert('Nothing to save. Add lines like \\newcommand{\\SO}{\\operatorname{SO}}'); return; }
        MACROS = { ...MACROS, ...parsed };
        try { localStorage.setItem(LS_MACROS, JSON.stringify(MACROS)); } catch (storageErr) {}
        try { macrosText.value = serializeMacros(MACROS); } catch (serr) {}
        render(); requestAnimationFrame(() => macrosModal.classList.remove('show'));
      } catch (err) { console.error('Save handler error:', err); alert('Unexpected error while saving shortcuts. Check console for details.'); }
    });
  </script>


  <!-- ===================== Welcome pop-under ===================== -->
  <div id="welcomePop" class="welcome-pop" role="dialog" aria-modal="false" aria-labelledby="welcomeTitle">
    <div class="welcome-content">
      <h3 id="welcomeTitle">👋 Welcome to LaTeX Lab</h3>
      <p>
        This is an in-browser LaTeX playground with live KaTeX rendering.
        Type plain text and math, switch between <b>Mixed</b> mode (text + $inline$ / $$display$$ math)
        or <b>Classic</b> mode (every line renders as math), and export high-resolution PNGs.
        Dark mode and custom shortcuts are supported too.
      </p>
      <button id="welcomeClose">Got it</button>
    </div>
  </div>
</body>
</html>