const e={p:0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,n:0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,h:1n,a:0n,b:7n,Gx:0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,Gy:0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n},{p:t,n,Gx:r,Gy:a,b:o}=e,s=32,i={publicKey:33,publicKeyUncompressed:65,seed:48},c=(e="")=>{const t=Error(e);throw((...e)=>{"captureStackTrace"in Error&&"function"==typeof Error.captureStackTrace&&Error.captureStackTrace(...e)})(t,c),t},f=(e,t,n="")=>{const r=(a=e)instanceof Uint8Array||ArrayBuffer.isView(a)&&"Uint8Array"===a.constructor.name;var a;const o=e?.length,s=void 0!==t;if(!r||s&&o!==t){c((n&&`"${n}" `)+"expected Uint8Array"+(s?" of length "+t:"")+", got "+(r?"length="+o:"type="+typeof e))}return e},l=e=>new Uint8Array(e),d=(e,t)=>e.toString(16).padStart(t,"0"),u=e=>Array.from(f(e)).map((e=>d(e,2))).join(""),y=48,p=57,m=65,h=70,w=97,g=102,b=e=>e>=y&&e<=p?e-y:e>=m&&e<=h?e-(m-10):e>=w&&e<=g?e-(w-10):void 0,v=e=>{const t="hex invalid";if("string"!=typeof e)return c(t);const n=e.length,r=n/2;if(n%2)return c(t);const a=l(r);for(let n=0,o=0;n<r;n++,o+=2){const r=b(e.charCodeAt(o)),s=b(e.charCodeAt(o+1));if(void 0===r||void 0===s)return c(t);a[n]=16*r+s}return a},A=()=>globalThis?.crypto,k=()=>A()?.subtle??c("crypto.subtle must be defined, consider polyfill"),x=(...e)=>{const t=l(e.reduce(((e,t)=>e+f(t).length),0));let n=0;return e.forEach((e=>{t.set(e,n),n+=e.length})),t},S=(e=s)=>A().getRandomValues(l(e)),P=BigInt,T=(e,t,n,r="bad number: out of range")=>(e=>"bigint"==typeof e)(e)&&t<=e&&e<n?e:c(r),E=(e,n=t)=>{const r=e%n;return r>=0n?r:n+r},C=e=>E(e,n),U=e=>e instanceof K?e:c("Point expected"),L=e=>E(E(e*e)*e+o),D=e=>T(e,0n,t),I=e=>T(e,1n,t),$=e=>0n===(1n&e),O=e=>Uint8Array.of(e),H=e=>{const n=L(I(e));let r=1n;for(let e=n,a=(t+1n)/4n;a>0n;a>>=1n)1n&a&&(r=r*e%t),e=e*e%t;return E(r*r)===n?r:c("sqrt invalid")};class K{static BASE;static ZERO;X;Y;Z;constructor(e,t,n){this.X=D(e),this.Y=I(t),this.Z=D(n),Object.freeze(this)}static CURVE(){return e}static fromAffine(e){const{x:t,y:n}=e;return 0n===t&&0n===n?R:new K(t,n,1n)}static fromBytes(e){f(e);const{publicKey:t,publicKeyUncompressed:n}=i;let r;const a=e.length,o=e[0],l=e.subarray(1),d=V(l,0,s);if(a===t&&(2===o||3===o)){let e=H(d);const t=$(e);$(P(o))!==t&&(e=E(-e)),r=new K(d,e,1n)}return a===n&&4===o&&(r=new K(d,V(l,s,64),1n)),r?r.assertValidity():c("bad point: not on curve")}static fromHex(e){return K.fromBytes(v(e))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}equals(e){const{X:t,Y:n,Z:r}=this,{X:a,Y:o,Z:s}=U(e),i=E(t*s),c=E(a*r),f=E(n*s),l=E(o*r);return i===c&&f===l}is0(){return this.equals(R)}negate(){return new K(this.X,E(-this.Y),this.Z)}double(){return this.add(this)}add(e){const{X:t,Y:n,Z:r}=this,{X:a,Y:s,Z:i}=U(e);let c=0n,f=0n,l=0n;const d=E(3n*o);let u=E(t*a),y=E(n*s),p=E(r*i),m=E(t+n),h=E(a+s);m=E(m*h),h=E(u+y),m=E(m-h),h=E(t+r);let w=E(a+i);return h=E(h*w),w=E(u+p),h=E(h-w),w=E(n+r),c=E(s+i),w=E(w*c),c=E(y+p),w=E(w-c),l=E(0n*h),c=E(d*p),l=E(c+l),c=E(y-l),l=E(y+l),f=E(c*l),y=E(u+u),y=E(y+u),p=E(0n*p),h=E(d*h),y=E(y+p),p=E(u-p),p=E(0n*p),h=E(h+p),u=E(y*h),f=E(f+u),u=E(w*h),c=E(m*c),c=E(c-u),u=E(m*y),l=E(w*l),l=E(l+u),new K(c,f,l)}subtract(e){return this.add(U(e).negate())}multiply(e,t=!0){if(!t&&0n===e)return R;if((e=>{T(e,1n,n)})(e),1n===e)return this;if(this.equals(B))return ye(e).p;let r=R,a=B;for(let n=this;e>0n;n=n.double(),e>>=1n)1n&e?r=r.add(n):t&&(a=a.add(n));return r}multiplyUnsafe(e){return this.multiply(e,!1)}toAffine(){const{X:e,Y:n,Z:r}=this;if(this.equals(R))return{x:0n,y:0n};if(1n===r)return{x:e,y:n};const a=((e,t)=>{(0n===e||t<=0n)&&c("no inverse n="+e+" mod="+t);let n=E(e,t),r=t,a=0n,o=1n;for(;0n!==n;){const e=r%n,t=a-o*(r/n);r=n,n=e,a=o,o=t}return 1n===r?E(a,t):c("no inverse")})(r,t);return 1n!==E(r*a)&&c("inverse invalid"),{x:E(e*a),y:E(n*a)}}assertValidity(){const{x:e,y:t}=this.toAffine();return I(e),I(t),E(t*t)===L(e)?this:c("bad point: not on curve")}toBytes(e=!0){const{x:t,y:n}=this.assertValidity().toAffine(),r=M(t);return e?x((e=>O($(e)?2:3))(n),r):x(O(4),r,M(n))}toHex(e){return u(this.toBytes(e))}}const B=new K(r,a,1n),R=new K(0n,1n,0n);K.BASE=B,K.ZERO=R;const j=e=>P("0x"+(u(e)||"0")),V=(e,t,n)=>j(e.subarray(t,n)),Z=2n**256n,M=e=>v(d(T(e,0n,Z),64)),X="SHA-256",q={async hmacSha256Async(e,t){const n=k(),r="HMAC",a=await n.importKey("raw",e,{name:r,hash:{name:X}},!1,["sign"]);return l(await n.sign(r,a,t))},hmacSha256:void 0,async sha256Async(e){return l(await k().digest(X,e))},sha256:void 0},Y=e=>Uint8Array.from("BIP0340/"+e,(e=>e.charCodeAt(0))),G="nonce",N="challenge",J=(e,...t)=>{const n=(e=>{const t=q[e];return"function"!=typeof t&&c("hashes."+e+" not set"),t})("sha256"),r=n(Y(e));return n(x(r,r,...t))},_=async(e,...t)=>{const n=q.sha256Async,r=await n(Y(e));return await n(x(r,r,...t))},z=e=>{const t=(e=>{const t=j(f(e,s,"secret key"));return T(t,1n,n,"invalid secret key: outside of range")})(e),r=B.multiply(t),{x:a,y:o}=r.assertValidity().toAffine();return{d:$(o)?t:C(-t),px:M(a)}},F=e=>C(j(e)),Q=(...e)=>F(J(N,...e)),W=async(...e)=>F(await _(N,...e)),ee=e=>z(e).px,te=(ne=ee,e=>{const t=((e=S(i.seed))=>{f(e),(e.length<i.seed||e.length>1024)&&c("expected 40-1024b");const t=E(j(e),n-1n);return M(t+1n)})(e);return{secretKey:t,publicKey:ne(t)}});var ne;const re=(e,t,n)=>{const{px:r,d:a}=z(t);return{m:f(e),px:r,d:a,a:f(n,s)}},ae=e=>{const t=F(e);0n===t&&c("sign failed: k is zero");const{px:n,d:r}=z(M(t));return{rx:n,k:r}},oe=(e,t,n,r)=>x(t,M(C(e+n*r))),se="invalid signature produced",ie=(e,r,a,o)=>{const i=f(e,64,"signature"),c=f(r,void 0,"message"),l=f(a,s,"publicKey");try{const e=j(l),r=H(e),a=$(r)?r:E(-r),f=new K(e,a,1n).assertValidity(),y=M(f.toAffine().x),p=V(i,0,s);T(p,1n,t);const m=V(i,s,64);T(m,1n,n);const h=x(M(p),y,c);return d=o(h),u=e=>{const{x:t,y:n}=(r=f,a=m,o=C(-e),B.multiply(a,!1).add(r.multiply(o,!1)).assertValidity()).toAffine();var r,a,o;return!(!$(n)||t!==p)},d instanceof Promise?d.then(u):u(d)}catch(e){return!1}var d,u},ce=(e,t,n)=>ie(e,t,n,Q),fe=async(e,t,n)=>ie(e,t,n,W),le={keygen:te,getPublicKey:ee,sign(e,t,n=S(s)){const{m:r,px:a,d:o,a:i}=re(e,t,n),f=J("aux",i),l=M(o^j(f)),d=J(G,l,a,r),{rx:u,k:y}=ae(d),p=Q(u,a,r),m=oe(y,u,p,o);return ce(m,r,a)||c(se),m},verify:ce,async signAsync(e,t,n=S(s)){const{m:r,px:a,d:o,a:i}=re(e,t,n),f=await _("aux",i),l=M(o^j(f)),d=await _(G,l,a,r),{rx:u,k:y}=ae(d),p=await W(u,a,r),m=oe(y,u,p,o);return await fe(m,r,a)||c(se),m},verifyAsync:fe};let de;const ue=(e,t)=>{const n=t.negate();return e?n:t},ye=e=>{const t=de||(de=(()=>{const e=[];let t=B,n=t;for(let r=0;r<33;r++){n=t,e.push(n);for(let r=1;r<128;r++)n=n.add(t),e.push(n);t=n.double()}return e})());let n=R,r=B;const a=P(255),o=P(8);for(let s=0;s<33;s++){let i=Number(e&a);e>>=o,i>128&&(i-=256,e+=1n);const c=128*s,f=c,l=c+Math.abs(i)-1,d=s%2!=0,u=i<0;0===i?r=r.add(ue(d,t[f])):n=n.add(ue(u,t[l]))}return 0n!==e&&c("invalid wnaf"),{p:n,f:r}},{floor:pe,random:me,sin:he}=Math,we="Trystero",ge=(e,t)=>Array(e).fill().map(t),be="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",ve=e=>ge(e,(()=>be[pe(62*me())])).join(""),Ae=ve(20),ke=Promise.all.bind(Promise),xe="undefined"!=typeof window,{entries:Se,fromEntries:Pe,keys:Te}=Object,Ee=()=>{},Ce=e=>Error(`${we}: ${e}`),Ue=new TextEncoder,Le=new TextDecoder,De=e=>Ue.encode(e),Ie=e=>Le.decode(e),$e=e=>e.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),""),Oe=(...e)=>e.join("@"),He=(e,t,n)=>(e.relayUrls||((e,t)=>{const n=[...e],r=()=>{const e=1e4*he(t++);return e-pe(e)};let a=n.length;for(;a;){const e=pe(r()*a--);[n[a],n[e]]=[n[e],n[a]]}return n})(t,Re(e.appId))).slice(0,e.relayUrls?e.relayUrls.length:e.relayRedundancy||n),Ke=JSON.stringify,Be=JSON.parse,Re=(e,t=Number.MAX_SAFE_INTEGER)=>e.split("").reduce(((e,t)=>e+t.charCodeAt(0)),0)%t,je={},Ve="AES-GCM",Ze={},Me=async(e,t)=>new Uint8Array(await crypto.subtle.digest(e,De(t))),Xe=async e=>Ze[e]||=Array.from(await Me("SHA-1",e)).map((e=>e.toString(36))).join(""),qe=async(e,t)=>{const n=crypto.getRandomValues(new Uint8Array(16));return n.join(",")+"$"+(r=await crypto.subtle.encrypt({name:Ve,iv:n},await e,De(t)),btoa(String.fromCharCode.apply(null,new Uint8Array(r))));var r},Ye=async(e,t)=>{const[n,r]=t.split("$");return Ie(await crypto.subtle.decrypt({name:Ve,iv:new Uint8Array(n.split(","))},await e,(e=>{const t=atob(e);return new Uint8Array(t.length).map(((e,n)=>t.charCodeAt(n))).buffer})(r)))},Ge="icegatheringstatechange",Ne="offer";var Je=(e,{rtcConfig:t,rtcPolyfill:n,turnConfig:r})=>{const a=new(n||RTCPeerConnection)({iceServers:_e.concat(r||[]),...t}),o={};let s=!1,i=!1,c=null;const f=e=>{e.binaryType="arraybuffer",e.bufferedAmountLowThreshold=65535,e.onmessage=e=>o.data?.(e.data),e.onopen=()=>o.connect?.(),e.onclose=()=>o.close?.(),e.onerror=e=>o.error?.(e)},l=e=>Promise.race([new Promise((t=>{const n=()=>{"complete"===e.iceGatheringState&&(e.removeEventListener(Ge,n),t())};e.addEventListener(Ge,n),n()})),new Promise((e=>setTimeout(e,5e3)))]).then((()=>({type:e.localDescription.type,sdp:e.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")})));return e?(c=a.createDataChannel("data"),f(c)):a.ondatachannel=({channel:e})=>{c=e,f(e)},a.onnegotiationneeded=async()=>{try{s=!0,await a.setLocalDescription();const e=await l(a);o.signal?.(e)}catch(e){o.error?.(e)}finally{s=!1}},a.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(a.connectionState)&&o.close?.()},a.ontrack=e=>{o.track?.(e.track,e.streams[0]),o.stream?.(e.streams[0])},a.onremovestream=e=>o.stream?.(e.stream),e&&(a.canTrickleIceCandidates||a.onnegotiationneeded()),{created:Date.now(),connection:a,get channel(){return c},get isDead(){return"closed"===a.connectionState},async signal(t){if("open"!==c?.readyState||t.sdp?.includes("a=rtpmap"))try{if(t.type===Ne){if(s||"stable"!==a.signalingState&&!i){if(e)return;await ke([a.setLocalDescription({type:"rollback"}),a.setRemoteDescription(t)])}else await a.setRemoteDescription(t);await a.setLocalDescription();const n=await l(a);return o.signal?.(n),n}if("answer"===t.type){i=!0;try{await a.setRemoteDescription(t)}finally{i=!1}}}catch(e){o.error?.(e)}},sendData(e){return c.send(e)},destroy(){c?.close(),a.close(),s=!1,i=!1},setHandlers(e){return Object.assign(o,e)},offerPromise:e?new Promise((e=>o.signal=t=>{t.type===Ne&&e(t)})):Promise.resolve(),addStream(e){return e.getTracks().forEach((t=>a.addTrack(t,e)))},removeStream(e){return a.getSenders().filter((t=>e.getTracks().includes(t.track))).forEach((e=>a.removeTrack(e)))},addTrack(e,t){return a.addTrack(e,t)},removeTrack(e){const t=a.getSenders().find((t=>t.track===e));t&&a.removeTrack(t)},replaceTrack(e,t){const n=a.getSenders().find((t=>t.track===e));if(n)return n.replaceTrack(t)}}};const _e=[...ge(3,((e,t)=>`stun:stun${t||""}.l.google.com:19302`)),"stun:stun.cloudflare.com:3478"].map((e=>({urls:e}))),ze=Object.getPrototypeOf(Uint8Array),Fe=16369,Qe=255,We="bufferedamountlow",et=e=>"@_"+e;var tt=(e,t,n)=>{const r={},a={},o={},s={},i={},c={},f={},l={onPeerJoin:Ee,onPeerLeave:Ee,onPeerStream:Ee,onPeerTrack:Ee},d=(e,t)=>(e?Array.isArray(e)?e:[e]:Te(r)).flatMap((e=>{const n=r[e];return n?t(e,n):(console.warn(`${we}: no peer with id ${e} found`),[])})),u=e=>{r[e]&&(r[e].destroy(),delete r[e],delete s[e],delete i[e],l.onPeerLeave(e),t(e))},y=e=>{if(a[e])return o[e];if(!e)throw Ce("action type argument is required");const t=De(e);if(t.byteLength>12)throw Ce(`action type string "${e}" (${t.byteLength}b) exceeds byte limit (12). Hint: choose a shorter name.`);const n=new Uint8Array(12);n.set(t);let s=0;return a[e]={onComplete:Ee,onProgress:Ee,setOnComplete(t){return a[e]={...a[e],onComplete:t}},setOnProgress(t){return a[e]={...a[e],onProgress:t}},async send(e,t,a,o){if(a&&"object"!=typeof a)throw Ce("action meta argument must be an object");const i=typeof e;if("undefined"===i)throw Ce("action data cannot be undefined");const c="string"!==i,f=e instanceof Blob,l=f||e instanceof ArrayBuffer||e instanceof ze;if(a&&!l)throw Ce("action meta argument can only be used with binary data");const u=l?new Uint8Array(f?await e.arrayBuffer():e):De(c?Ke(e):e),y=a?De(Ke(a)):null,p=Math.ceil(u.byteLength/Fe)+(a?1:0)||1,m=ge(p,((e,t)=>{const r=t===p-1,o=a&&0===t,i=new Uint8Array(15+(o?y.byteLength:r?u.byteLength-Fe*(p-(a?2:1)):Fe));return i.set(n),i.set([s],12),i.set([r|o<<1|l<<2|c<<3],13),i.set([Math.round((t+1)/p*Qe)],14),i.set(a?o?y:u.subarray((t-1)*Fe,t*Fe):u.subarray(t*Fe,(t+1)*Fe),15),i}));return s=s+1&Qe,ke(d(t,(async(e,t)=>{const{channel:n}=t;let s=0;for(;s<p;){const i=m[s];if(n.bufferedAmount>n.bufferedAmountLowThreshold&&await new Promise((e=>{const t=()=>{n.removeEventListener(We,t),e()};n.addEventListener(We,t)})),!r[e])break;t.sendData(i),s++,o?.(i[14]/Qe,e,a)}})))}},o[e]||=[a[e].send,a[e].setOnComplete,a[e].setOnProgress]},p=async()=>{await P(""),await new Promise((e=>setTimeout(e,99))),Se(r).forEach((([e,t])=>{t.destroy(),delete r[e]})),n()},[m,h]=y(et("ping")),[w,g]=y(et("pong")),[b,v]=y(et("signal")),[A,k]=y(et("stream")),[x,S]=y(et("track")),[P,T]=y(et("leave"));return e(((e,t)=>{r[t]||(r[t]=e,e.setHandlers({data(e){return((e,t)=>{const n=new Uint8Array(t),r=Ie(n.subarray(0,12)).replaceAll("\0",""),[o]=n.subarray(12,13),[i]=n.subarray(13,14),[c]=n.subarray(14,15),f=n.subarray(15),l=!!(1&i),d=!!(2&i),u=!!(4&i),y=!!(8&i);if(!a[r])return void console.warn(`${we}: received message with unregistered type (${r})`);s[e]||={},s[e][r]||={};const p=s[e][r][o]||={chunks:[]};if(d?p.meta=Be(Ie(f)):p.chunks.push(f),a[r].onProgress(c/Qe,e,p.meta),!l)return;const m=new Uint8Array(p.chunks.reduce(((e,t)=>e+t.byteLength),0));if(p.chunks.reduce(((e,t)=>(m.set(t,e),e+t.byteLength)),0),delete s[e][r][o],u)a[r].onComplete(m,e,p.meta);else{const t=Ie(m);a[r].onComplete(y?Be(t):t,e)}})(t,e)},stream(e){l.onPeerStream(e,t,c[t]),delete c[t]},track(e,n){l.onPeerTrack(e,n,t,f[t]),delete f[t]},signal(e){return b(e,t)},close(){return u(t)},error(e){console.error(e),u(t)}}),l.onPeerJoin(t))})),h(((e,t)=>w("",t))),g(((e,t)=>{i[t]?.(),delete i[t]})),v(((e,t)=>r[t]?.signal(e))),k(((e,t)=>c[t]=e)),S(((e,t)=>f[t]=e)),T(((e,t)=>u(t))),xe&&addEventListener("beforeunload",p),{makeAction:y,leave:p,async ping(e){if(!e)throw Ce("ping() must be called with target peer ID");const t=Date.now();return m("",e),await new Promise((t=>i[e]=t)),Date.now()-t},getPeers(){return Pe(Se(r).map((([e,t])=>[e,t.connection])))},addStream(e,t,n){return d(t,(async(t,r)=>{n&&await A(n,t),r.addStream(e)}))},removeStream(e,t){return d(t,((t,n)=>n.removeStream(e)))},addTrack(e,t,n,r){return d(n,(async(n,a)=>{r&&await x(r,n),a.addTrack(e,t)}))},removeTrack(e,t){return d(t,((t,n)=>n.removeTrack(e)))},replaceTrack(e,t,n,r){return d(n,(async(n,a)=>{r&&await x(r,n),a.replaceTrack(e,t)}))},onPeerJoin(e){return l.onPeerJoin=e},onPeerLeave(e){return l.onPeerLeave=e},onPeerStream(e){return l.onPeerStream=e},onPeerTrack(e){return l.onPeerTrack=e}}};const nt={},rt="EVENT",{secretKey:at,publicKey:ot}=le.keygen(),st=$e(ot),it={},ct={},ft={},lt=()=>Math.floor(Date.now()/1e3),dt=e=>ft[e]??=Re(e,1e4)+2e4,ut=async(e,t)=>{const n={kind:dt(e),tags:[["x",e]],created_at:lt(),content:t,pubkey:st},r=await Me("SHA-256",Ke([0,n.pubkey,n.created_at,n.kind,n.tags,n.content]));return Ke([rt,{...n,id:$e(r),sig:$e(await le.signAsync(r,at))}])},yt=(e,t)=>(it[e]=t,Ke(["REQ",e,{kinds:[dt(t)],since:lt(),"#x":[t]}])),pt=e=>(delete it[e],Ke(["CLOSE",e])),mt=(({init:e,subscribe:t,announce:n})=>{const r={};let a,o,s,i=!1;return(c,f,l)=>{const{appId:d}=c;if(r[d]?.[f])return r[d][f];const u={},y={},p=Oe(we,d,f),m=Xe(p),h=Xe(Oe(p,Ae)),w=(async(e,t,n)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},De(`${e}:${t}:${n}`)),{name:Ve},!1,["encrypt","decrypt"]))(c.password||"",d,f),g=e=>async t=>({type:t.type,sdp:await e(w,t.sdp)}),b=g(Ye),v=g(qe),A=()=>Je(!0,c),k=(e,t,n)=>{y[t]?y[t]!==e&&e.destroy():(y[t]=e,L(e,t),u[t]?.forEach(((e,t)=>{t!==n&&e.destroy()})),delete u[t])},x=(e,t)=>{y[t]===e&&delete y[t]},S=e=>(o.push(...ge(e,A)),ke(o.splice(0,e).map((e=>e.offerPromise.then(v).then((t=>({peer:e,offer:t}))))))),P=(e,t)=>l?.({error:`incorrect password (${c.password}) when decrypting ${t}`,appId:d,peerId:e,roomId:f}),T=e=>async(t,n,r)=>{const[a,o]=await ke([m,h]);if(t!==a&&t!==o)return;const{peerId:s,offer:i,answer:f,peer:l}="string"==typeof n?Be(n):n;if(s!==Ae&&!y[s])if(!s||i||f){if(i){const t=u[s]?.[e];if(t&&Ae>s)return;const n=Je(!1,c);let a;n.setHandlers({connect(){return k(n,s,e)},close(){return x(n,s)}});try{a=await b(i)}catch{return void P(s,"offer")}if(n.isDead)return;const[o,f]=await ke([Xe(Oe(p,s)),n.signal(a)]);r(o,Ke({peerId:Ae,answer:await v(f)}))}else if(f){let t;try{t=await b(f)}catch(e){return void P(s,"answer")}if(l)l.setHandlers({connect(){return k(l,s,e)},close(){return x(l,s)}}),l.signal(t);else{const n=u[s]?.[e];n&&!n.isDead&&n.signal(t)}}}else{if(u[s]?.[e])return;const[[{peer:t,offer:n}],a]=await ke([S(1),Xe(Oe(p,s))]);u[s]||=[],u[s][e]=t,setTimeout((()=>((e,t)=>{if(y[e])return;const n=u[e]?.[t];n&&(delete u[e][t],n.destroy())})(s,e)),.9*E[e]),t.setHandlers({connect(){return k(t,s,e)},close(){return x(t,s)}}),r(a,Ke({peerId:Ae,offer:n}))}};if(!c)throw Ce("requires a config map as the first argument");if(!d&&!c.firebaseApp)throw Ce("config map is missing appId field");if(!f)throw Ce("roomId argument required");if(!i){const t=e(c);o=ge(20,A),a=Array.isArray(t)?t:[t],i=!0,s=setInterval((()=>o=o.filter((e=>{const t=Date.now()-e.created<57333;return t||e.destroy(),t}))),59052.99)}const E=a.map((()=>5333)),C=[],U=a.map((async(e,n)=>t(await e,await m,await h,T(n),S)));ke([m,h]).then((([e,t])=>{const r=async(a,o)=>{const s=await n(a,e,t);"number"==typeof s&&(E[o]=s),C[o]=setTimeout((()=>r(a,o)),E[o])};U.forEach((async(e,t)=>{await e,r(await a[t],t)}))}));let L=Ee;return r[d]||={},r[d][f]=tt((e=>L=e),(e=>delete y[e]),(()=>{delete r[d][f],C.forEach(clearTimeout),U.forEach((async e=>(await e)())),clearInterval(s)}))}})({init(e){return He(e,gt,5).map((e=>{const t=((e,t)=>{const n={},r=()=>{const a=new WebSocket(e);a.onclose=()=>{je[e]??=3333,setTimeout(r,je[e]),je[e]*=2},a.onmessage=e=>t(e.data),n.socket=a,n.url=a.url,n.ready=new Promise((t=>a.onopen=()=>{t(n),je[e]=3333})),n.send=e=>{1===a.readyState&&a.send(e)}};return r(),n})(e,(e=>{const[n,r,a,o]=Be(e);if(n===rt)ct[r]?.(it[r],a.content);else{const e=`${we}: relay failure from ${t.url} - `;"NOTICE"===n?console.warn(e+r):"OK"!==n||a||console.warn(e+o)}}));return nt[e]=t,t.ready}))},subscribe(e,t,n,r){const a=ve(64),o=ve(64);return ct[a]=ct[o]=(t,n)=>r(t,n,(async(t,n)=>e.send(await ut(t,n)))),e.send(yt(a,t)),e.send(yt(o,n)),()=>{e.send(pt(a)),e.send(pt(o)),delete ct[a],delete ct[o]}},async announce(e,t){return e.send(await ut(t,Ke({peerId:Ae})))}}),ht=(wt=nt,()=>Pe(Se(wt).map((([e,t])=>[e,t.socket]))));var wt;const gt=["black.nostrcity.club","ftp.halifax.rwth-aachen.de/nostr","nos.lol","nostr.cool110.xyz","nostr.data.haus","nostr.sathoarder.com","nostr.vulpem.com","relay.agorist.space","relay.binaryrobot.com","relay.damus.io","relay.fountain.fm","relay.mostro.network","relay.nostraddress.com","relay.nostrdice.com","relay.nostromo.social","relay.oldenburg.cool","relay.verified-nostr.com","yabu.me/v2"].map((e=>"wss://"+e));export{ut as createEvent,gt as defaultRelayUrls,ht as getRelaySockets,mt as joinRoom,Ae as selfId,yt as subscribe};